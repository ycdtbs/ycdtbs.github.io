<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java开发的截图直接上传对象存储</title>
    <link href="/2022/05/24/Java%E5%BC%80%E5%8F%91%E7%9A%84%E6%88%AA%E5%9B%BE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"/>
    <url>/2022/05/24/Java%E5%BC%80%E5%8F%91%E7%9A%84%E6%88%AA%E5%9B%BE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="Java截图工具直接上传到阿里云对象存储"><a href="#Java截图工具直接上传到阿里云对象存储" class="headerlink" title="Java截图工具直接上传到阿里云对象存储"></a>Java截图工具直接上传到阿里云对象存储</h4><p>   经常使用markdown编写博客或者文档的朋友们应该知道，需要上传照片到图床是一个很麻烦的时候，我们需要保存图片，然后上传到图床，然后复制地址放入markdown文件当中，市面上支持直接从剪贴板中插入文件的图床几乎都收费且价格很不划算，因此开发了一个工具，截图后直接上传到阿里云对象存储，并将返回的地址存入剪贴板直接使用。<br>Github：<a href="https://github.com/ycdtbs/imagebed">https://github.com/ycdtbs/imagebed</a></p><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>对源码不感兴趣的朋友可以直接下载压缩包修改配置文件</p><p><img src="https://facesearch-hoom.oss-cn-hangzhou.aliyuncs.com/face/09c57784-145a-4a9c-a3e5-ec3e13f45e60.jpg"></p><p>修改config中的文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">aliyun:</span><br>  <span class="hljs-attr">endpoint:</span> <span class="hljs-comment"># 阿里云的节点地址</span><br>  <span class="hljs-attr">keyid:</span>  <span class="hljs-comment"># 填写刚刚生成的AccessKey</span><br>  <span class="hljs-attr">keysecret:</span>   <span class="hljs-comment"># 填写刚刚生成的Accesssecret</span><br>  <span class="hljs-attr">bucketname:</span>  <span class="hljs-comment"># bucket名称</span><br>  <span class="hljs-attr">filehost:</span>     <span class="hljs-comment">#bucket下文件夹的路径</span><br></code></pre></td></tr></table></figure><p>点击bat运行软件（需要java环境）</p><p><img src="https://facesearch-hoom.oss-cn-hangzhou.aliyuncs.com/face/aabd700a-55e6-4417-83a2-5e86cbd9a17b.jpg"></p><p>x @Componentpublic class Setingmodel {    private String imgpath;    private String GroupID;    private String UserID;    private String Quality_Control;    private String Image_Type;    private String Liveness_Control;    private String Userinf;​    public String getUserinf() {        return Userinf;    }​    public void setUserinf(String userinf) {        Userinf &#x3D; userinf;    }​    public Setingmodel() {        &#x2F;**         * 图片类型         * BASE64:图片的base64值，base64编码后的图片数据，编码后的图片大小不超过2M；         * URL:图片的 URL地址( 可能由于网络等原因导致下载图片时间过长)；         * FACE_TOKEN：人脸图片的唯一标识，调用人脸检测接口时         * 会为每个人脸图片赋予一个唯一的FACE_TOKEN         * 同一张图片多次检测得到的FACE_TOKEN是同一个。         <em>&#x2F;        this.Image_Type &#x3D; “BASE64”;        &#x2F;</em>*         * 图片质量控制         * NONE: 不进行控制         * LOW:较低的质量要求         * NORMAL: 一般的质量要求         * HIGH: 较高的质量要求         * 默认 NONE         <em>&#x2F;        this.Quality_Control &#x3D; “NONE”;        &#x2F;</em>*         * 活体检测控制         * NONE: 不进行控制         * LOW:较低的活体要求(高通过率 低攻击拒绝率)         * NORMAL: 一般的活体要求(平衡的攻击拒绝率, 通过率)         * HIGH: 较高的活体要求(高攻击拒绝率 低通过率)         * 默认NONE         *&#x2F;        this.Liveness_Control &#x3D; “NONE”;    }​    public String getImgpath() {        return imgpath;    }​    public void setImgpath(String imgpath) {        this.imgpath &#x3D; imgpath;    }​    public String getGroupID() {        return GroupID;    }​    public void setGroupID(String groupID) {        GroupID &#x3D; groupID;    }​    public String getUserID() {        return UserID;    }​    public void setUserID(String userID) {        UserID &#x3D; userID;    }​    public String getQuality_Control() {        return Quality_Control;    }​    public void setQuality_Control(String quality_Control) {        Quality_Control &#x3D; quality_Control;    }​    public String getImage_Type() {        return Image_Type;    }​    public void setImage_Type(String image_Type) {        Image_Type &#x3D; image_Type;    }​    public String getLiveness_Control() {        return Liveness_Control;    }​    public void setLiveness_Control(String liveness_Control) {        Liveness_Control &#x3D; liveness_Control;    }}java</p>]]></content>
    
    
    <categories>
      
      <category>小工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java GUI编程</tag>
      
      <tag>小工具开发</tag>
      
      <tag>开源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Milvues向量搜索引擎的大规模人脸识别</title>
    <link href="/2022/05/18/%E5%9F%BA%E4%BA%8EMilvues%E5%90%91%E9%87%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E5%A4%A7%E8%A7%84%E6%A8%A1%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    <url>/2022/05/18/%E5%9F%BA%E4%BA%8EMilvues%E5%90%91%E9%87%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E5%A4%A7%E8%A7%84%E6%A8%A1%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="SpringBoot-基于向量搜索引擎及虹软人脸识别SDK的大规模人脸搜索"><a href="#SpringBoot-基于向量搜索引擎及虹软人脸识别SDK的大规模人脸搜索" class="headerlink" title="SpringBoot 基于向量搜索引擎及虹软人脸识别SDK的大规模人脸搜索"></a>SpringBoot 基于向量搜索引擎及虹软人脸识别SDK的大规模人脸搜索</h3><p>[TOC]</p><h4 id="在线环境demo"><a href="#在线环境demo" class="headerlink" title="在线环境demo"></a>在线环境demo</h4><p>​    为了方便大家测试效果，开放了一个在线环境供大家测试并降低了识别门槛和难度，使得照片也可以通过筛选，大家使用前无比观看视频，按照视频方式操作。由于服务器昂贵，资源有限，生产环境的配置为2C 8G，所以服务比较慢用户体验一般，若想测试性能，请在本地部署</p><p>视频地址:<a href="https://space.bilibili.com/97483909">https://space.bilibili.com/97483909</a></p><p>在线环境(演示):<a href="http://120.48.10.164:9528/">http://120.48.10.164:9528/</a> admin 123456</p><p>联系我：<a href="mailto:&#x79;&#99;&#100;&#116;&#x62;&#115;&#64;&#x31;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;">&#x79;&#99;&#100;&#116;&#x62;&#115;&#64;&#x31;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;</a> </p><h5 id="在线环境说明"><a href="#在线环境说明" class="headerlink" title="在线环境说明"></a>在线环境说明</h5><p>在线环境会收集大家数据，请勿上传敏感照片，项目测试数据集均来源于网络公开照片，利用Python脚本爬取，脚本存放于目录中</p><p><strong>在线环境仅用于演示 请勿上传自己数据</strong> </p><p><strong>在线环境仅用于演示 请勿上传自己数据</strong> </p><p><strong>在线环境仅用于演示 请勿上传自己数据</strong> </p><p><strong>在线环境仅用于演示 请勿上传自己数据</strong> </p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​       大四毕业时做毕业设计，用到了百度云人脸识别的API,当时制作了一个demo发到Bilibli上，之后不少同学来问我，于是制作了一个利用虹软SDK的人脸识别的包含人脸库管理的一套服务，一年半来有不少朋友前来咨询人脸识别相关的问题，由于博主本人工作业务不涉及这部分，所以一直无心研究。最近北京疫情在家有了一些时间，利用了几天时间完善了基于虹软的代码。</p><p>​       首先说明一下上个版本的缺陷是什么，首先之前的人脸数据缓存在了Redis当中，当我们解析出特征值时，将数据缓存到redis中，进行逐个必对和判断，<strong>优化的方式也只是单纯的利用多线程和虹软的人基本特征（性别、年龄）</strong>等进行分库，几百个人脸时还好，在上千个人脸时就会出现非常明显的延迟，用户体验效率非常低，因此基于上个版本只满足部分同学的毕业设计、小组作业的场景。偶然在工作中了解到了向量搜索引擎，于是考虑是否可以结合虹软的人脸识别SDK提取特征向量，然后进行分析处理。由于这个demo主要是搭建一个大规模人脸搜索和识别服务的demo，因此没有工程化，系统设计的也比较冗余，没有详细的功能设计，基本是博主想到什么做什么。最后跪求一个 <strong>STAR</strong> 重要的事情说三遍 <strong>STAR STAR STAR</strong></p><h4 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h4><p><img src="https://chengpicture.oss-cn-beijing.aliyuncs.com/%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p><h4 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h4><p>​       系统功能模块较为简单，主要功能就是<strong>新增人脸</strong>和<strong>人脸搜索</strong>两个功能，其中新增人脸使用页面上传和压缩包批量上传两个方式，压缩包上传时文件名称为用户名，下面主要说明人脸搜索的功能流程</p><h5 id="Milvues"><a href="#Milvues" class="headerlink" title="Milvues"></a>Milvues</h5><p>​       在介绍前需要说明一下Mulvus</p><p>​       Milvus 向量数据库能够帮助用户轻松应对海量非结构化数据（图片 &#x2F; 视频 &#x2F; 语音 &#x2F; 文本）检索。单节点 Milvus 可以在秒内完成十亿级的向量搜索</p><p>​       因此虹软的SDK只能提取向量及对比的功能，在大规模人脸识别中，需要搜索引擎对于人脸数据进行初步筛选到一个较小的范围后在利用虹软的SDK进行测试，值得一提的是，博主多次测试后Milvues返回的匹配率足以满足人脸匹配的要求，Milvus的安装部署和使用文档参考 <a href="https://milvus.io/cn/docs/v2.0.x">https://milvus.io/cn/docs/v2.0.x</a></p><p>​       <strong>特别说明的是</strong>虹软提取的数组是一个经过归一后的1032长度的byte数组，我们需要对数组进行转换，去除前8位的版本号，并将1024长度的byte转为256长度的float向量，这部分可以利用Arrays提供的方法进行转换，代码中也有相应的工具类</p><h5 id="人脸上传（单张）"><a href="#人脸上传（单张）" class="headerlink" title="人脸上传（单张）"></a>人脸上传（单张）</h5><p><img src="https://chengpicture.oss-cn-beijing.aliyuncs.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png"></p><h5 id="人脸上传（批量）"><a href="#人脸上传（批量）" class="headerlink" title="人脸上传（批量）"></a>人脸上传（批量）</h5><p>​       批量上传采用本地打包压缩上传到服务器，后台进程进行解压，放到队列中处理，处理结果存储在ES数据库中，实时结果及处理进度通过Websocket发送至前台</p><p>​       <img src="https://chengpicture.oss-cn-beijing.aliyuncs.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%281%29.png"></p><h5 id="人脸搜索"><a href="#人脸搜索" class="headerlink" title="人脸搜索"></a>人脸搜索</h5><p><img src="https://chengpicture.oss-cn-beijing.aliyuncs.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%282%29.png"></p><h4 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h4><h5 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h5><p>​       前端使用了Vue admin temlate 及 Element UI</p><h5 id="后端框架"><a href="#后端框架" class="headerlink" title="后端框架"></a>后端框架</h5><p>​       后端框架主要是SpringBoot</p><h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><ul><li>mysql：存储用户信息，所有的数据以Mysql数据为准</li><li>Elasticsearch：由于批量上传操作是异步的，用ES来收集日志并分析热点数据、成功数据、失败数据（当前版本未实现）</li><li>InfluxDB：用于涉及到数据源较多，事务处理过于麻烦，架构设计中以Mysql中的数据为准，以Mysql数据进行数据同步</li><li>阿里云OSS：负责存储裁切后的人脸照片，负责前台展示及缓存失效时重新加载</li><li>Milvues：<strong>项目的核心数据库向量搜索引擎</strong></li></ul><h5 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h5><ul><li>ActiveMq：由于大规模人脸搜索服务需要大量的照片,一个个手动上传不现实，因此开发了批量上传的功能，需要ActiveMq进行异步上传</li></ul><h5 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h5><ul><li>restful：前后端交互主要使用restful接口</li><li>websocket：负责将后端处理照片的过程及照片实时显示在前端</li></ul><h4 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h4><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><ul><li><p>.env.development 文件配置后端交互地址，<strong>只需要修改所有的IP+端口</strong> 其他路径不要改变</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># just a flag</span><br><span class="hljs-attr">ENV</span> = <span class="hljs-string">&#x27;development&#x27;</span><br><span class="hljs-comment"># base api</span><br><span class="hljs-attr">VUE_APP_BASE_API</span> = <span class="hljs-string">&#x27;http://127.0.0.1:8080/&#x27; </span><br><span class="hljs-comment">#VUE_APP_BASE_API = &#x27;http://120.48.10.164:8080/&#x27;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># uploadFile</span><br><span class="hljs-attr">VUE_APP_BASE_API_UPFILE</span> = <span class="hljs-string">&#x27;http://127.0.0.1:8080/file/getImageUrl&#x27;</span><br><br><span class="hljs-attr">VUE_APP_BASE_API_UPFILE_LIST</span> = <span class="hljs-string">&#x27;http://127.0.0.1:8080/file/getListImageUrl&#x27;</span><br><br><span class="hljs-attr">VUE_APP_BASE_API_WEBSOCKET</span> = <span class="hljs-string">&#x27;ws://127.0.0.1:8080/api/pushMessage/&#x27;</span><br><br><span class="hljs-attr">VUE_APP_BASE_API_UPFILE</span> = <span class="hljs-string">&#x27;http://120.48.10.164:8080/file/getImageUrl&#x27;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#VUE_APP_BASE_API_UPFILE_LIST = &#x27;http://120.48.10.164:8080/file/getListImageUrl&#x27;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#VUE_APP_BASE_API_WEBSOCKET = &#x27;ws://120.48.10.164:8080/api/pushMessage/&#x27;</span><br></code></pre></td></tr></table></figure><p>VUE_APP_BASE_API：后端服务接口</p><p>VUE_APP_BASE_API_UPFILE：单个文件上传地址</p><p>VUE_APP_BASE_API_UPFILE_LIST：文件列表上传地址</p><p>VUE_APP_BASE_API_WEBSOCKET：Websocket地址</p></li><li><p>运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install<br>npm run dev<br>服务端口：ip:9528<br></code></pre></td></tr></table></figure></li></ul><h5 id="后端配置"><a href="#后端配置" class="headerlink" title="后端配置"></a>后端配置</h5><ul><li>application.yml 主要是服务地址<ul><li>修改Redis配置</li><li>修改Mysql配置</li><li>修改ActiveMq配置</li><li>修改Milvues配置</li><li>修改阿里云对象存储地址</li><li>uploadFile配置本地缓存路径，主要是压缩包上传时需要用到</li></ul></li><li>FaceEngineConfig 类<ul><li>配置虹软SDK的APID、SK，引擎地址</li></ul></li></ul><h5 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h5><ul><li>mysql</li><li>redis</li><li>activeMq</li><li>Elasticsearch（此版本不用安装）</li><li>InfluxDB（此版本不用安装）</li><li>Milvus</li></ul><h5 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h5><ul><li>执行face.sql</li></ul><h5 id="人脸数据"><a href="#人脸数据" class="headerlink" title="人脸数据"></a>人脸数据</h5><ul><li>利用python脚本自行爬取</li></ul><h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><h5 id="FaceEngineConfig-类"><a href="#FaceEngineConfig-类" class="headerlink" title="FaceEngineConfig 类"></a>FaceEngineConfig 类</h5><blockquote><p>类的主要功能是配置faceEngine的认证配置信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">FaceEngineConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">APPID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SDKKEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//public static final String SDKKEY = &quot;&quot;;//linux</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LIB</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\face_web\\ArcSoft_ArcFace_Java_Windows_x64_V3.0\\libs\\WIN64&quot;</span>;<br>    <span class="hljs-comment">//public static final String LIB = &quot;&quot;; // linux</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="FaceEnginePoolFactory-引擎对象工厂类"><a href="#FaceEnginePoolFactory-引擎对象工厂类" class="headerlink" title="FaceEnginePoolFactory 引擎对象工厂类"></a>FaceEnginePoolFactory 引擎对象工厂类</h5><blockquote><p>引擎对象工厂类，负责维护一个对象池</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Log4j2</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FaceEnginePoolFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BasePooledObjectFactory</span>&lt;FaceEngine&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在对象池中创建对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FaceEngine <span class="hljs-title function_">create</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">FaceEngine</span> <span class="hljs-variable">faceEngine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FaceEngine</span>(FaceEngineConfig.LIB);<br>        <span class="hljs-comment">//激活引擎</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">errorCode</span> <span class="hljs-operator">=</span> faceEngine.activeOnline(FaceEngineConfig.APPID, FaceEngineConfig.SDKKEY);<br>        <span class="hljs-keyword">if</span> (errorCode != ErrorInfo.MOK.getValue() &amp;&amp; errorCode != ErrorInfo.MERR_ASF_ALREADY_ACTIVATED.getValue()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;引擎激活失败&quot;</span>);<br>        &#125;<br>        ActiveFileInfo activeFileInfo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveFileInfo</span>();<br>        errorCode = faceEngine.getActiveFileInfo(activeFileInfo);<br>        <span class="hljs-keyword">if</span> (errorCode != ErrorInfo.MOK.getValue() &amp;&amp; errorCode != ErrorInfo.MERR_ASF_ALREADY_ACTIVATED.getValue()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;获取激活文件信息失败&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//引擎配置</span><br>        <span class="hljs-type">EngineConfiguration</span> <span class="hljs-variable">engineConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EngineConfiguration</span>();<br>        engineConfiguration.setDetectMode(DetectMode.ASF_DETECT_MODE_IMAGE);<br>        engineConfiguration.setDetectFaceOrientPriority(DetectOrient.ASF_OP_ALL_OUT);<br>        engineConfiguration.setDetectFaceMaxNum(<span class="hljs-number">10</span>);<br>        engineConfiguration.setDetectFaceScaleVal(<span class="hljs-number">16</span>);<br>        <span class="hljs-comment">//功能配置</span><br>        <span class="hljs-type">FunctionConfiguration</span> <span class="hljs-variable">functionConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FunctionConfiguration</span>();<br>        functionConfiguration.setSupportAge(<span class="hljs-literal">true</span>);<br>        functionConfiguration.setSupportFace3dAngle(<span class="hljs-literal">true</span>);<br>        functionConfiguration.setSupportFaceDetect(<span class="hljs-literal">true</span>);<br>        functionConfiguration.setSupportFaceRecognition(<span class="hljs-literal">true</span>);<br>        functionConfiguration.setSupportGender(<span class="hljs-literal">true</span>);<br>        functionConfiguration.setSupportLiveness(<span class="hljs-literal">true</span>);<br>        functionConfiguration.setSupportIRLiveness(<span class="hljs-literal">true</span>);<br>        engineConfiguration.setFunctionConfiguration(functionConfiguration);<br>        <span class="hljs-comment">//初始化引擎</span><br>        errorCode = faceEngine.init(engineConfiguration);<br><br>        <span class="hljs-keyword">if</span> (errorCode != ErrorInfo.MOK.getValue()) &#123;<br>            log.error(<span class="hljs-string">&quot;初始化引擎失败&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> faceEngine;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 包装对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> faceEngine</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PooledObject&lt;FaceEngine&gt; <span class="hljs-title function_">wrap</span><span class="hljs-params">(FaceEngine faceEngine)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPooledObject</span>&lt;&gt;(faceEngine);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 销毁对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> faceEngine 对象池</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception 异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroyObject</span><span class="hljs-params">(PooledObject&lt;FaceEngine&gt; faceEngine)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">super</span>.destroyObject(faceEngine);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验对象是否可用</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> faceEngine 对象池</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对象是否可用结果，boolean</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validateObject</span><span class="hljs-params">(PooledObject&lt;FaceEngine&gt; faceEngine)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.validateObject(faceEngine);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 激活钝化的对象系列操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> faceEngine 对象池</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception 异常信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">activateObject</span><span class="hljs-params">(PooledObject&lt;FaceEngine&gt; faceEngine)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">super</span>.activateObject(faceEngine);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 钝化未使用的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> faceEngine 对象池</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception 异常信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">passivateObject</span><span class="hljs-params">(PooledObject&lt;FaceEngine&gt; faceEngine)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">super</span>.passivateObject(faceEngine);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="faceUtils-人脸识别工具类"><a href="#faceUtils-人脸识别工具类" class="headerlink" title="faceUtils 人脸识别工具类"></a>faceUtils 人脸识别工具类</h5><blockquote><p>核心的人脸识别类，负责提取特征值、截取人脸、特征值对比</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">faceUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> GenericObjectPool&lt;FaceEngine&gt; faceEngineGenericObjectPool;<br>    faceUtils()&#123;<br>        <span class="hljs-comment">// 对象池工厂</span><br>        <span class="hljs-type">FaceEnginePoolFactory</span> <span class="hljs-variable">personPoolFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FaceEnginePoolFactory</span>();<br>        <span class="hljs-comment">// 对象池配置</span><br>        GenericObjectPoolConfig&lt;FaceEngine&gt; objectPoolConfig = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericObjectPoolConfig</span>&lt;&gt;();<br>        objectPoolConfig.setMaxTotal(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">AbandonedConfig</span> <span class="hljs-variable">abandonedConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbandonedConfig</span>();<br><br>        abandonedConfig.setRemoveAbandonedOnMaintenance(<span class="hljs-literal">true</span>); <span class="hljs-comment">//在Maintenance的时候检查是否有泄漏</span><br><br>        abandonedConfig.setRemoveAbandonedOnBorrow(<span class="hljs-literal">true</span>); <span class="hljs-comment">//borrow 的时候检查泄漏</span><br><br>        abandonedConfig.setRemoveAbandonedTimeout(<span class="hljs-number">10</span>); <span class="hljs-comment">//如果一个对象borrow之后10秒还没有返还给pool，认为是泄漏的对象</span><br><br>        <span class="hljs-comment">// 对象池</span><br>        faceEngineGenericObjectPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericObjectPool</span>&lt;&gt;(personPoolFactory, objectPoolConfig);<br>        faceEngineGenericObjectPool.setAbandonedConfig(abandonedConfig);<br>        faceEngineGenericObjectPool.setTimeBetweenEvictionRunsMillis(<span class="hljs-number">5000</span>); <span class="hljs-comment">//5秒运行一次维护任务</span><br>        log.info(<span class="hljs-string">&quot;引擎池开启成功&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 人脸检测</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileInputStream</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span>  List&lt;FaceInfo&gt; <span class="hljs-title function_">faceFind</span><span class="hljs-params">(InputStream fileInputStream)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FaceEngine</span> <span class="hljs-variable">faceEngine</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            faceEngine = faceEngineGenericObjectPool.borrowObject();<br>            <span class="hljs-type">ImageInfo</span> <span class="hljs-variable">imageInfo</span> <span class="hljs-operator">=</span> getRGBData(fileInputStream);<br>            List&lt;FaceInfo&gt; faceInfoList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;FaceInfo&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">errorCode</span> <span class="hljs-operator">=</span> faceEngine.detectFaces(imageInfo.getImageData(), imageInfo.getWidth(), imageInfo.getHeight(), imageInfo.getImageFormat(), faceInfoList);<br>            <span class="hljs-keyword">return</span> faceInfoList;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;出现了异常&quot;</span>);<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;FaceInfo&gt;();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            fileInputStream.close();<br>            <span class="hljs-comment">// 回收对象到对象池</span><br>            <span class="hljs-keyword">if</span> (faceEngine != <span class="hljs-literal">null</span>) &#123;<br>                faceEngineGenericObjectPool.returnObject(faceEngine);<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 人脸截取</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileInputStream</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rect</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span>  String <span class="hljs-title function_">faceCrop</span><span class="hljs-params">(InputStream fileInputStream, Rect rect)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">BufferedImage</span> <span class="hljs-variable">bufImage</span> <span class="hljs-operator">=</span> ImageIO.read(fileInputStream);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> bufImage.getHeight();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> bufImage.getWidth();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> rect.getTop();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">bottom</span> <span class="hljs-operator">=</span> rect.getBottom();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> rect.getLeft();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> rect.getRight();<br>            <span class="hljs-comment">//System.out.println(top + &quot;-&quot; + bottom + &quot;-&quot; + left + &quot;-&quot; + right);</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">BufferedImage</span> <span class="hljs-variable">subimage</span> <span class="hljs-operator">=</span> bufImage.getSubimage(left, top, right - left, bottom - left);<br>                ImageIO.write(subimage, <span class="hljs-string">&quot;png&quot;</span>, stream);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">base64</span> <span class="hljs-operator">=</span> Base64.encode(stream.toByteArray());<br>                <span class="hljs-keyword">return</span> base64;<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                stream.close();<br>                fileInputStream.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 人脸特征值提取</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] faceFeature(InputStream fileInputStream,FaceInfo faceInfo) <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FaceEngine</span> <span class="hljs-variable">faceEngine</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">FaceFeature</span> <span class="hljs-variable">faceFeature</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FaceFeature</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            faceEngine = faceEngineGenericObjectPool.borrowObject();<br>            <span class="hljs-type">ImageInfo</span> <span class="hljs-variable">imageInfo</span> <span class="hljs-operator">=</span> getRGBData(fileInputStream);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">errorCode</span> <span class="hljs-operator">=</span> faceEngine.extractFaceFeature(imageInfo.getImageData(), imageInfo.getWidth(), imageInfo.getHeight(), imageInfo.getImageFormat(), faceInfo, faceFeature);<br>            <span class="hljs-type">byte</span>[] featureData = faceFeature.getFeatureData();<br>            <span class="hljs-keyword">return</span> featureData;<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;出现了异常&quot;</span>);<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>];<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            fileInputStream.close();<br>            <span class="hljs-comment">// 回收对象到对象池</span><br>            <span class="hljs-keyword">if</span> (faceEngine != <span class="hljs-literal">null</span>) &#123;<br>                faceEngineGenericObjectPool.returnObject(faceEngine);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 人脸对比</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">faceCompared</span><span class="hljs-params">(<span class="hljs-type">byte</span> [] source,<span class="hljs-type">byte</span> [] des)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FaceEngine</span> <span class="hljs-variable">faceEngine</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            faceEngine = faceEngineGenericObjectPool.borrowObject();<br>            <span class="hljs-type">FaceFeature</span> <span class="hljs-variable">targetFaceFeature</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FaceFeature</span>();<br>            targetFaceFeature.setFeatureData(source);<br>            <span class="hljs-type">FaceFeature</span> <span class="hljs-variable">sourceFaceFeature</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FaceFeature</span>();<br>            sourceFaceFeature.setFeatureData(des);<br>            <span class="hljs-type">FaceSimilar</span> <span class="hljs-variable">faceSimilar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FaceSimilar</span>();<br>            faceEngine.compareFaceFeature(targetFaceFeature, sourceFaceFeature, faceSimilar);<br>            <span class="hljs-type">float</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> faceSimilar.getScore();<br>            <span class="hljs-keyword">return</span> score;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;出现了异常&quot;</span>);<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 回收对象到对象池</span><br>            <span class="hljs-keyword">if</span> (faceEngine != <span class="hljs-literal">null</span>) &#123;<br>                faceEngineGenericObjectPool.returnObject(faceEngine);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="milvusOperateUtils-Milvues工具类"><a href="#milvusOperateUtils-Milvues工具类" class="headerlink" title="milvusOperateUtils Milvues工具类"></a>milvusOperateUtils Milvues工具类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">milvusOperateUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> GenericObjectPool&lt;MilvusServiceClient&gt; milvusServiceClientGenericObjectPool;  <span class="hljs-comment">// 管理链接对象的池子</span><br>    <span class="hljs-comment">// https://milvus.io/cn/docs/v2.0.x/load_collection.md</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">milvusOperateUtils</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 私有构造方法创建一个池</span><br>        <span class="hljs-comment">// 对象池工厂</span><br>        <span class="hljs-type">MilvusPoolFactory</span> <span class="hljs-variable">milvusPoolFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MilvusPoolFactory</span>();<br>        <span class="hljs-comment">// 对象池配置</span><br>        GenericObjectPoolConfig&lt;FaceEngine&gt; objectPoolConfig = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericObjectPoolConfig</span>&lt;&gt;();<br>        objectPoolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>        <span class="hljs-type">AbandonedConfig</span> <span class="hljs-variable">abandonedConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbandonedConfig</span>();<br><br>        abandonedConfig.setRemoveAbandonedOnMaintenance(<span class="hljs-literal">true</span>); <span class="hljs-comment">//在Maintenance的时候检查是否有泄漏</span><br><br>        abandonedConfig.setRemoveAbandonedOnBorrow(<span class="hljs-literal">true</span>); <span class="hljs-comment">//borrow 的时候检查泄漏</span><br><br>        abandonedConfig.setRemoveAbandonedTimeout(MAX_POOL_SIZE); <span class="hljs-comment">//如果一个对象borrow之后10秒还没有返还给pool，认为是泄漏的对象</span><br><br>        <span class="hljs-comment">// 对象池</span><br>        milvusServiceClientGenericObjectPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericObjectPool</span>(milvusPoolFactory, objectPoolConfig);<br>        milvusServiceClientGenericObjectPool.setAbandonedConfig(abandonedConfig);<br>        milvusServiceClientGenericObjectPool.setTimeBetweenEvictionRunsMillis(<span class="hljs-number">5000</span>); <span class="hljs-comment">//5秒运行一次维护任务</span><br>        log.info(<span class="hljs-string">&quot;milvus 对象池创建成功 维护了&quot;</span> + MAX_POOL_SIZE + <span class="hljs-string">&quot;个对象&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建一个Collection 类似于创建关系型数据库中的一张表</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createCollection</span><span class="hljs-params">(String collection)</span> &#123;<br>        <span class="hljs-type">MilvusServiceClient</span> <span class="hljs-variable">milvusServiceClient</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 通过对象池管理对象</span><br>            milvusServiceClient = milvusServiceClientGenericObjectPool.borrowObject();<br>            <span class="hljs-type">FieldType</span> <span class="hljs-variable">fieldType1</span> <span class="hljs-operator">=</span> FieldType.newBuilder()<br>                    .withName(faceMilvus.Field.USER_NAME)<br>                    .withDescription(<span class="hljs-string">&quot;用户名&quot;</span>)<br>                    .withDataType(DataType.Int64)<br>                    .build();<br>            <span class="hljs-type">FieldType</span> <span class="hljs-variable">fieldType2</span> <span class="hljs-operator">=</span> FieldType.newBuilder()<br>                    .withName(faceMilvus.Field.USER_CODE)<br>                    .withDescription(<span class="hljs-string">&quot;编号&quot;</span>)<br>                    .withDataType(DataType.Int64)<br>                    .withPrimaryKey(<span class="hljs-literal">true</span>)<br>                    .withAutoID(<span class="hljs-literal">false</span>)<br>                    .build();<br>            <span class="hljs-type">FieldType</span> <span class="hljs-variable">fieldType3</span> <span class="hljs-operator">=</span> FieldType.newBuilder()<br>                    .withName(faceMilvus.Field.FEATURE)<br>                    .withDescription(<span class="hljs-string">&quot;特征向量&quot;</span>)<br>                    .withDataType(DataType.FloatVector)<br>                    .withDimension(faceMilvus.FEATURE_DIM)<br>                    .build();<br>            <span class="hljs-type">CreateCollectionParam</span> <span class="hljs-variable">createCollectionReq</span> <span class="hljs-operator">=</span> CreateCollectionParam.newBuilder()<br>                    .withCollectionName(collection)<br>                    .withDescription(<span class="hljs-string">&quot;人脸特征向量库&quot;</span>)<br>                    .withShardsNum(<span class="hljs-number">2</span>)<br>                    .addFieldType(fieldType2)<br>                    .addFieldType(fieldType1)<br>                    .addFieldType(fieldType3)<br>                    .build();<br>            R&lt;RpcStatus&gt; result = milvusServiceClient.createCollection(createCollectionReq);<br>            log.info(<span class="hljs-string">&quot;创建结果&quot;</span> + result.getStatus() + <span class="hljs-string">&quot;0 为成功&quot;</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 回收对象到对象池</span><br>            <span class="hljs-keyword">if</span> (milvusServiceClient != <span class="hljs-literal">null</span>) &#123;<br>                milvusServiceClientGenericObjectPool.returnObject(milvusServiceClient);<br>            &#125;<br>        &#125;<br><br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadingLocation</span><span class="hljs-params">(String collection)</span> &#123;<br>        <span class="hljs-type">MilvusServiceClient</span> <span class="hljs-variable">milvusServiceClient</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 通过对象池管理对象</span><br>            milvusServiceClient = milvusServiceClientGenericObjectPool.borrowObject();<br>            R&lt;RpcStatus&gt; rpcStatusR = milvusServiceClient.loadCollection(<br>                    LoadCollectionParam.newBuilder()<br>                            .withCollectionName(collection)<br>                            .build());<br>            log.info(<span class="hljs-string">&quot;加载结果&quot;</span> + rpcStatusR);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 回收对象到对象池</span><br>            <span class="hljs-keyword">if</span> (milvusServiceClient != <span class="hljs-literal">null</span>) &#123;<br>                milvusServiceClientGenericObjectPool.returnObject(milvusServiceClient);<br>            &#125;<br>        &#125;<br><br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">freedLoaction</span><span class="hljs-params">(String collection)</span> &#123;<br>        <span class="hljs-type">MilvusServiceClient</span> <span class="hljs-variable">milvusServiceClient</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 通过对象池管理对象</span><br>            milvusServiceClient = milvusServiceClientGenericObjectPool.borrowObject();<br>            R&lt;RpcStatus&gt; rpcStatusR = milvusServiceClient.releaseCollection(<br>                    ReleaseCollectionParam.newBuilder()<br>                            .withCollectionName(collection)<br>                            .build());<br>            log.info(<span class="hljs-string">&quot;加载结果&quot;</span> + rpcStatusR);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 回收对象到对象池</span><br>            <span class="hljs-keyword">if</span> (milvusServiceClient != <span class="hljs-literal">null</span>) &#123;<br>                milvusServiceClientGenericObjectPool.returnObject(milvusServiceClient);<br>            &#125;<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">// 删除一个Collection</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delCollection</span><span class="hljs-params">(String collection)</span> &#123;<br>        <span class="hljs-type">MilvusServiceClient</span> <span class="hljs-variable">milvusServiceClient</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 通过对象池管理对象</span><br>            milvusServiceClient = milvusServiceClientGenericObjectPool.borrowObject();<br>            R&lt;RpcStatus&gt; book = milvusServiceClient.dropCollection(<br>                    DropCollectionParam.newBuilder()<br>                            .withCollectionName(collection)<br>                            .build());<br>            log.info(<span class="hljs-string">&quot;删除&quot;</span> + book.getStatus() + <span class="hljs-string">&quot; 0 为成功&quot;</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 回收对象到对象池</span><br>            <span class="hljs-keyword">if</span> (milvusServiceClient != <span class="hljs-literal">null</span>) &#123;<br>                milvusServiceClientGenericObjectPool.returnObject(milvusServiceClient);<br>            &#125;<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">// 插入数据 和对应的字段相同</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String collectionName, String partitionName, List&lt;Long&gt; userName, List&lt;Long&gt; userCode, List&lt;List&lt;Float&gt;&gt; feature)</span> &#123;<br>        <span class="hljs-type">MilvusServiceClient</span> <span class="hljs-variable">milvusServiceClient</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 通过对象池管理对象</span><br>            milvusServiceClient = milvusServiceClientGenericObjectPool.borrowObject();<br>            List&lt;InsertParam.Field&gt; fields = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            fields.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InsertParam</span>.Field(faceMilvus.Field.USER_NAME, DataType.Int64, userName));<br>            fields.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InsertParam</span>.Field(faceMilvus.Field.USER_CODE, DataType.Int64, userCode));<br>            fields.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InsertParam</span>.Field(faceMilvus.Field.FEATURE, DataType.FloatVector, feature));<br>            <span class="hljs-type">InsertParam</span> <span class="hljs-variable">insertParam</span> <span class="hljs-operator">=</span> InsertParam.newBuilder()<br>                    .withCollectionName(collectionName)<br>                    .withPartitionName(partitionName)<br>                    .withFields(fields)<br>                    .build();<br>            R&lt;MutationResult&gt; insertResult = milvusServiceClient.insert(insertParam);<br>            <span class="hljs-keyword">if</span> (insertResult.getStatus() == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> insertResult.getData().getIDs().getIntId().getData(<span class="hljs-number">0</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                log.error(<span class="hljs-string">&quot;特征值上传失败 加入失败队列稍后重试&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 回收对象到对象池</span><br>            <span class="hljs-keyword">if</span> (milvusServiceClient != <span class="hljs-literal">null</span>) &#123;<br>                milvusServiceClientGenericObjectPool.returnObject(milvusServiceClient);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据向量搜索数据</span><br>    <span class="hljs-keyword">public</span> List&lt;?&gt; searchByFeature(String collection,List&lt;List&lt;Float&gt;&gt; search_vectors) &#123;<br>        <span class="hljs-type">MilvusServiceClient</span> <span class="hljs-variable">milvusServiceClient</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 通过对象池管理对象</span><br>            milvusServiceClient = milvusServiceClientGenericObjectPool.borrowObject();<br>            List&lt;String&gt; search_output_fields = Arrays.asList(faceMilvus.Field.USER_CODE);<br>            <span class="hljs-type">SearchParam</span> <span class="hljs-variable">searchParam</span> <span class="hljs-operator">=</span> SearchParam.newBuilder()<br>                    .withCollectionName(collection)<br>                    .withPartitionNames(Arrays.asList(<span class="hljs-string">&quot;one&quot;</span>))<br>                    .withMetricType(MetricType.L2)<br>                    .withOutFields(search_output_fields)<br>                    .withTopK(faceMilvus.SEARCH_K)<br>                    .withVectors(search_vectors)<br>                    .withVectorFieldName(faceMilvus.Field.FEATURE)<br>                    .withParams(faceMilvus.SEARCH_PARAM)<br>                    .build();<br>            R&lt;SearchResults&gt; respSearch = milvusServiceClient.search(searchParam);<br>            <span class="hljs-keyword">if</span> (respSearch.getStatus() == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">SearchResultsWrapper</span> <span class="hljs-variable">wrapperSearch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchResultsWrapper</span>(respSearch.getData().getResults());<br>                List&lt;?&gt; fieldData = wrapperSearch.getFieldData(faceMilvus.Field.USER_CODE, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">return</span> fieldData;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 回收对象到对象池</span><br>            <span class="hljs-keyword">if</span> (milvusServiceClient != <span class="hljs-literal">null</span>) &#123;<br>                milvusServiceClientGenericObjectPool.returnObject(milvusServiceClient);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">milvusOperateUtils</span> <span class="hljs-variable">milvusOperateUtils</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">milvusOperateUtils</span>();<br>        milvusOperateUtils.createCollection(<span class="hljs-string">&quot;face_home&quot;</span>);<br>        <span class="hljs-comment">//milvusOperateUtils.delCollection(&quot;&quot;);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h4><h5 id="虹软"><a href="#虹软" class="headerlink" title="虹软"></a>虹软</h5><p><a href="https://ai.arcsoft.com.cn/">https://ai.arcsoft.com.cn/</a></p><h5 id="Milvus"><a href="#Milvus" class="headerlink" title="Milvus"></a>Milvus</h5><p><a href="https://milvus.io/cn/docs/v2.0.x/create_collection.md">https://milvus.io/cn/docs/v2.0.x/create_collection.md</a></p>]]></content>
    
    
    <categories>
      
      <category>项目文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>人脸识别</tag>
      
      <tag>人脸搜索</tag>
      
      <tag>大规模人脸识别服务</tag>
      
      <tag>向量搜索引擎</tag>
      
      <tag>虹软</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2022/04/09/Redis%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/04/09/Redis%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="1、NoSql数据库"><a href="#1、NoSql数据库" class="headerlink" title="1、NoSql数据库"></a>1、NoSql数据库</h3><p>NoSql数据库的特点</p><p><strong>泛指非关系型数据库</strong></p><ul><li>不支持事物</li><li>不支持ACID</li><li>远超SQL的性能</li></ul><h4 id="1-1-Memcache"><a href="#1-1-Memcache" class="headerlink" title="1.1 Memcache"></a>1.1 Memcache</h4><ul><li>早期的Nosql数据库</li><li>数据都存放在内存中，一般不持久化</li><li>支持简单的kv模式，支持类型单一</li><li>一般作为缓存数据库辅助持久化数据库</li></ul><h4 id="1-2-Redis"><a href="#1-2-Redis" class="headerlink" title="1.2 Redis"></a>1.2 Redis</h4><ul><li>几乎覆盖了Memcache绝大部分功能呢</li><li>数据在内存中支持持久化，主要用作备份恢复</li><li>除了kv形式还支持多种数据类型，例如list set hash zset</li><li>一般作为缓存数据库辅助持久化的数据库</li></ul><h4 id="1-3-MongoDB"><a href="#1-3-MongoDB" class="headerlink" title="1.3  MongoDB"></a>1.3  MongoDB</h4><ul><li><p>高性能、开源、模式自由的文档型数据库</p></li><li><p>数据都在内存中</p></li><li><p>虽然是kv模式，但是对于value提供了丰富的查询功能</p></li><li><p>支持二进制数据及大型对象</p></li><li><p>可以根据数据的特点代替RDBMS的数据库</p></li></ul><h3 id="2、Redis安装"><a href="#2、Redis安装" class="headerlink" title="2、Redis安装"></a>2、Redis安装</h3><h4 id="2-1-Redis概述"><a href="#2-1-Redis概述" class="headerlink" title="2.1 Redis概述"></a>2.1 Redis概述</h4><ul><li>Redis是一个开源的key-value存储系统</li><li>和Memcache一样，它支持存储的value类型相对更多，包括String字符串、list、set、Zset和hash</li><li>这些数据类型都支持push&#x2F;pop add&#x2F;remome 及取交集并集和差集及更丰富的操作，且这些操作都是原子性的</li><li>在此基础上Redis支持不同方式的排序</li><li>与memacched一样，为了保证效率数据都是缓存在内存中的</li><li>Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并在此基础上实现了主从同步</li></ul><h4 id="2-2-Redis安装"><a href="#2-2-Redis安装" class="headerlink" title="2.2 Redis安装"></a>2.2 Redis安装</h4><p>安装GCC环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br>make install<br></code></pre></td></tr></table></figure><p>安装完成后默认存放在 **&#x2F;usr&#x2F;local&#x2F;bin **目录下</p><ul><li>redis-benchmark 性能测试工具</li><li>redis-check-aof 修复有问题的AOF文件</li><li>redis-check-dump 修复有问题的dump.rdb文件</li><li>redis-sentinel Redis集群使用</li><li>redis-server Redis服务启动</li><li>redis-cli 客户端操作入口</li></ul><h4 id="2-3-Redis相关知识"><a href="#2-3-Redis相关知识" class="headerlink" title="2.3 Redis相关知识"></a>2.3 Redis相关知识</h4><p>redis默认16个数据库，类似于数组下标从0开始，初始默认值使用0号库</p><p>使用select dbID来切换数据库</p><p>统一的密码管理</p><p>dbsize 查看数据库数量</p><p><strong>Redis是单线程+多路IO复用</strong></p><h3 id="3、Redis的数据类型"><a href="#3、Redis的数据类型" class="headerlink" title="3、Redis的数据类型"></a>3、Redis的数据类型</h3><p>常用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">keys * ## 查看当前库所有的key<br>set key value ## 设置值<br>exists key ## 判断值是否存在<br>type key ## 查看key是什么类型<br>del key ## 删除key<br>unlink key ## 根据value选择非阻塞删除 并非同步删除<br>expire key 10 ## 设置过期时间<br>ttl key ## 查看过期时间 -1 代表永不过期，-2代表已经过期<br>select 1 ## 切换数据库<br>dbsize 1 ## 查看当前库所有的key的数量<br>flshdb 1 ## 清空当前库<br></code></pre></td></tr></table></figure><h4 id="3-1-Redis字符串"><a href="#3-1-Redis字符串" class="headerlink" title="3.1 Redis字符串"></a>3.1 Redis字符串</h4><p>String 是redis最基本的类型，可以理解成与Memcached一摸一样的类型，一个key对应一个value</p><p>String类型是二进制安全的，意味着Redis的String可以包含任何数据，例如jpge图片或者序列化的对象</p><p>String 类型是Redis最基本的数据类型，一个Redis中字符串value做多是512M</p><ul><li><p>常用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">set name tangcheng ## 加入数据<br>get name ## 获取值<br>append name hahaha ## 追加<br>strlen name ## 获取值的长度<br>setnx key value ## 只有值不存在的时候在设置<br>incr key ## 存储的数字值递增1<br>decr key ## 存储的数字值减1<br>incrby key value ## 增加多少<br>decrby key value ## 减少多少<br>mset k1 v1 k2 v2 ## 设置多个key<br>mget k1 k2 k3 k4 ## 取出多个值<br>setex key time value ## 设置值并指定过期时间<br>getset key value ## 以新值换旧值<br></code></pre></td></tr></table></figure></li></ul><p>内部结构就是一个动态字符串，类似于java当中的arraylist</p><h4 id="3-2-Redis-List"><a href="#3-2-Redis-List" class="headerlink" title="3.2 Redis List"></a>3.2 Redis List</h4><p>Redis的泪飙是一个简单的字符串列表，按照插入顺序进行排序，可以添加一个元素到列表的头部，也可以添加一个元素到列表的尾部</p><p>他的底层是一个双向链表，对两端的操作性能很高，通过索引下标的操作中间环节节点性能会比较差</p><ul><li><p>常用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">lpush key v1 v2 v3 ## 从左侧加入数据<br>lrange k1 0 -1 ## 取值<br>lpop key ## 从左边拿出一个值<br>rpop key ## 从右边拿出一个值<br>rpoplpush k1 k2 ## 从k1右边吐出一个值插入k2左边<br>lindex key index ## 根据索引下标获取到值<br>llen k2 ## 获取列表的长度<br>linsert key before value newvalue ## 在key的 value前面或者后面加入newalue<br>lrem key num value ## 从左边删除 key的 num个value为value的<br><br></code></pre></td></tr></table></figure></li></ul><p>数据结构</p><p>底层的数据结构是一个quickList 首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构式ziplist即压缩列表</p><p>它将所有的元素挨在一起存储，分配的是连续内存</p><p>当数据量比较大的时候会将所有的ziplist链表连在一起，形成quicklist</p><h4 id="3-3-集合-Set"><a href="#3-3-集合-Set" class="headerlink" title="3.3 集合 Set"></a>3.3 集合 Set</h4><p>list和set最大的区别就是无序且自动去重的</p><p>底层是一个hash表</p><ul><li><p>常用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">sadd k1 v1 v2 v3 ## 设置值<br>smembers k1 ## 取出值<br>sismember key value ## 判断集合是否含有该value值<br>scard key value ## 返回集合中元素个数<br>srem key value ## 删除某个集合元素<br>spop key ## 随机取出一个值<br>srandmember key n ## 从集合中随机取出n个值<br>smove k1 k2 value ## 把集合中的一个值移动到另一个集合<br>sinter k1 k2 ## 返回两个集合交集元素<br>sunion k1 k2 ## 返回两个集合中的并集元素<br>sdiff k1 k2 ## 返回两个集合中的差集元素<br></code></pre></td></tr></table></figure></li></ul><p><strong>数据结构</strong></p><p>Set数据结构是dict字典，字典是用哈希表实现的</p><h4 id="3-4-哈希"><a href="#3-4-哈希" class="headerlink" title="3.4 哈希"></a>3.4 哈希</h4><p>Redis hash 是一个String 类型的 field和value的映射表，hash特别使用用于存储对象，类似于Java中的Map&lt;String,Object&gt;</p><ul><li><p>常用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">hset key field value ## 设置key的值<br>hegt key field ## 取值<br>hmset key field value field value ## 批量设置<br>hexists key value ## 查看哈希表的key中给定域的field是否存在<br>hkeys key ## 列出该hash集合的所有field<br>hvals key ## 列出该hash集合的所有value<br>hincrby key fidld increment ## 为哈希表中key中的域fidld的值加上增量1 -1<br><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-5-有序集合"><a href="#3-5-有序集合" class="headerlink" title="3.5 有序集合"></a>3.5 有序集合</h4><p>有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合</p><p>不同之处是有序集合的每个成员都关联了一个评分，这个评分用来按照最低分到最高分的方式排序集合当中的成员，集合的成员是唯一的，但是评分可能是重复的</p><p>因为元素是有序的，所以可以很快的根据评分或者次序来获取一个范围的元素</p><p>访问有序集合的中间元素也是非常快的，因此能够使用有序结合作为一个没有重复成员的只能列表</p><ul><li><p>常用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">zadd key scorel value scorel value2<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 将一个或多个member元素及score值加入到有序集合key当中</span></span><br>zrange key 0 -1 withscores<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 返回排序后的值</span></span><br>zrangebyscore key 100 200 ## 返回100 -200 之间的值<br><br></code></pre></td></tr></table></figure></li></ul><p>数据结构</p><p>它等价于Java的数据结构map&lt;String,double&gt;，可以给每一个元素value赋予一个权重score</p><p>跳跃表</p><p>跳跃表效率堪比红黑树，实现远比红黑树简单</p><h3 id="4、Redis的配置文件"><a href="#4、Redis的配置文件" class="headerlink" title="4、Redis的配置文件"></a>4、Redis的配置文件</h3><h3 id="5、Redis发布订阅"><a href="#5、Redis发布订阅" class="headerlink" title="5、Redis发布订阅"></a>5、Redis发布订阅</h3><p>Redis发布订阅是一种消息通信模式，发送者pub消息，订阅者接收消息</p><p>Redis客户端可以订阅任意数量的<strong>频道</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">publish channel message ## 发送消息<br>substring channel ## 订阅消息<br></code></pre></td></tr></table></figure><h3 id="6、新增的数据类型"><a href="#6、新增的数据类型" class="headerlink" title="6、新增的数据类型"></a>6、新增的数据类型</h3><h4 id="6-1-Bitmaps"><a href="#6-1-Bitmaps" class="headerlink" title="6.1 Bitmaps"></a>6.1 Bitmaps</h4><p>底层是一个字符串只是可以进行位操作</p><h4 id="6-2-HyperLogLog"><a href="#6-2-HyperLogLog" class="headerlink" title="6.2 HyperLogLog"></a>6.2 HyperLogLog</h4><p>基数问题就是不重复元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pfadd <br></code></pre></td></tr></table></figure><h4 id="6-3-Geospatial"><a href="#6-3-Geospatial" class="headerlink" title="6.3 Geospatial"></a>6.3 Geospatial</h4><p>元素的二维坐标，提供范围查询距离查询，经纬度hash</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">geoadd china:city 127.47 31.23 shanghai<br>geopos key name<br>geo dlist ## 获取两个位置之间的直线距离<br></code></pre></td></tr></table></figure><h3 id="7、Jedis-操作Redis"><a href="#7、Jedis-操作Redis" class="headerlink" title="7、Jedis 操作Redis"></a>7、Jedis 操作Redis</h3><p>jedis的相关依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;dependency&gt;<br>            &lt;groupId&gt;redis.clients&lt;/groupId&gt;<br>            &lt;artifactId&gt;jedis&lt;/artifactId&gt;<br>            &lt;version&gt;3.2.0&lt;/version&gt;<br>        &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h4 id="7-1-ping"><a href="#7-1-ping" class="headerlink" title="7.1 ping"></a>7.1 ping</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.64.132&quot;</span>, <span class="hljs-number">6379</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">ping</span> <span class="hljs-operator">=</span> jedis.ping();<br>System.out.println(ping);<br></code></pre></td></tr></table></figure><h4 id="7-2-操作key"><a href="#7-2-操作key" class="headerlink" title="7.2 操作key"></a>7.2 操作key</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; keys = jedis.keys(<span class="hljs-string">&quot;*&quot;</span>); ## 获取所有key<br>keys.stream().forEach(System.out::println);<br>jedis.setex(<span class="hljs-string">&quot;tangcheng&quot;</span>,<span class="hljs-number">12</span>,<span class="hljs-string">&quot;你好&quot;</span>);<br><span class="hljs-type">Long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> jedis.ttl(<span class="hljs-string">&quot;唐成&quot;</span>);<br>System.out.println(time);<br></code></pre></td></tr></table></figure><h4 id="7-3-Springboot-Redis"><a href="#7-3-Springboot-Redis" class="headerlink" title="7.3 Springboot Redis"></a>7.3 Springboot Redis</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">192.168.64.132</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-attr">spring.redis.database</span>=<span class="hljs-string">0</span><br><span class="hljs-attr">spring.redis.timeout</span>=<span class="hljs-string">18000000</span><br><span class="hljs-attr">spring.redis.jedis.pool.max-active</span>=<span class="hljs-string">20</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-wait</span>=<span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.redistest.config;<br><br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<br><span class="hljs-keyword">import</span> org.springframework.cache.CacheManager;<br><span class="hljs-keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;<br><span class="hljs-keyword">import</span> org.springframework.cache.annotation.EnableCaching;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><br><span class="hljs-keyword">import</span> java.time.Duration;<br><br><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span> &#123;<br>    <span class="hljs-comment">//比如验证码</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        template.setConnectionFactory(factory);<br>        <span class="hljs-comment">//key序列化方式</span><br>        template.setKeySerializer(redisSerializer);<br>        <span class="hljs-comment">//value序列化</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-comment">//value hashmap序列化</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-comment">//解决查询缓存转换异常的问题</span><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        <span class="hljs-comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span><br>        <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> RedisCacheConfiguration.defaultCacheConfig()<br>                .entryTtl(Duration.ofSeconds(<span class="hljs-number">600</span>)) <span class="hljs-comment">//缓存过期10分钟 ---- 业务需求。</span><br>                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))<span class="hljs-comment">//设置key的序列化方式</span><br>                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)) <span class="hljs-comment">//设置value的序列化</span><br>                .disableCachingNullValues();<br>        <span class="hljs-type">RedisCacheManager</span> <span class="hljs-variable">cacheManager</span> <span class="hljs-operator">=</span> RedisCacheManager.builder(factory)<br>                .cacheDefaults(config)<br>                .build();<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8、Redis中的事务操作"><a href="#8、Redis中的事务操作" class="headerlink" title="8、Redis中的事务操作"></a>8、Redis中的事务操作</h3><p>Redis的事物式一个单独的隔离操作，事物中的所有命令都会序列化，按照顺寻执行，事物在执行过程中，不会被其他客户端发送来的命令请求所打断</p><p>Redis事物的主要作用就是串联多个命令防止别的命令插队</p><p><strong>redis事物的作用就是串联多个操作防止别的操作插队</strong></p><p>Multi exec discard</p><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但是不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行</p><p>组队的过程中可以通过discard来放弃组队</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; MULTI<br>OK<br>127.0.0.1:6379(TX)&gt; set k1 value1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; get k1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; EXEC<br>1) OK<br>2) &quot;value1&quot;<br>127.0.0.1:6379&gt; MULTI<br>OK<br>127.0.0.1:6379(TX)&gt; DISCARD<br>OK<br>127.0.0.1:6379&gt;<br><br></code></pre></td></tr></table></figure><p><strong>如果组队中某个命令出现了报告错误，执行时整个队列都会被取消</strong></p><p><strong>如果执行过程中某个任务报告了错误，那么只有该命令不会执行</strong></p><h4 id="8-1-事物的冲突问题"><a href="#8-1-事物的冲突问题" class="headerlink" title="8.1 事物的冲突问题"></a>8.1 事物的冲突问题</h4><ul><li>悲观锁</li></ul><p>传统关系型数据库就用到了这种锁机制，比如行锁表锁读写锁</p><p>效率低</p><ul><li>乐观锁</li></ul><p>引入版本号</p><p><strong>Redis使用乐观锁</strong></p><p>在执行multi之前，先执行watch key1 key2 可以监视多个key，如果在事物执行之前，这个key被其他命令打断，那么事物将被打断</p><p><strong>Redis事物三特性</strong></p><p>单独的隔离操作</p><p>没有隔离级别概念</p><p>不保证原子性</p><h4 id="8-2-Lua脚本"><a href="#8-2-Lua脚本" class="headerlink" title="8.2 Lua脚本"></a>8.2 Lua脚本</h4><p>lua嵌入式脚本语言</p><p>lua的优势，将复杂的很多步骤的redis操作写成一个脚本，一次提交给redis执行，减少反复连接的次数，提升性能</p><p>lua脚本式类似redis事物，具有一个顶的原子性，不会被其他命令插队，可以完成一些redis事物性的操作</p><p>利用lua脚本淘汰用户</p><h3 id="9、Redis-持久化"><a href="#9、Redis-持久化" class="headerlink" title="9、Redis 持久化"></a>9、Redis 持久化</h3><p>redis是基于内存的操作，但是也提供了写入内存</p><h4 id="9-1-RDB-redis-database"><a href="#9-1-RDB-redis-database" class="headerlink" title="9.1 RDB redis database"></a>9.1 RDB redis database</h4><p><strong>什么是rdb</strong></p><p>在指定的时间间隔内，将内存中的数据快照写入磁盘，也就是Snapshot快照，他恢复时是将框招文件直接读到内存里</p><p>Redis会单独创建一个fork进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了在用这个临时文件替换上次持久化好的文件，整个过程中主进程是不会进行任何IO操作的，这就确保了极高的性能，如果需要大规模的数据恢复，且对于数据恢复的完整性不是很敏感，那RDB方式要比AOF方式更加高效，<strong>RDB的缺点是，最后一次持久化后的数据可能丢失</strong></p><p>这个过程中用到了一个技术 写时复制技术</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/redis%E6%8C%81%E4%B9%85%E5%8C%96.png"></p><p><strong>为什么不直接同步到文件中？</strong></p><p>保证数据的一致性和完整性</p><p><strong>dump.rdb文件</strong></p><p>在redis.conf中配置文件的名称，dump.rdb</p><p><strong>配置文件配置</strong></p><p>SNAP SHOTTING</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0.png"></p><p>可以配置rdb文件名称</p><p>通过配置文件可以配置rdb文件的路径</p><p>默认启动目录</p><p><strong>stop-writes-on-bgsave-error</strong></p><p>yes</p><p>当Redis无法写入磁盘的话，直接关掉Redis的写操作</p><p><strong>rdbcompression 压缩文件</strong></p><p>持久化的文件是否进行压缩</p><p><strong>rdbchecksum 检查完整性</strong></p><p>在存储快照后，还可以让redis使用crc64算法来进行数据校验，</p><p>这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</p><p><strong>save</strong></p><p>在指定的时间间隔内将内存中的数据集快照写入磁盘</p><p>写操作次数，</p><p>save的规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 20秒内至少有3个key</span></span><br>save 20 3<br></code></pre></td></tr></table></figure><p><strong>bgsave</strong></p><p>自动完成sabe</p><p><strong>RDB的优势</strong></p><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高，更适合使用</li><li>节省磁盘空间</li><li>恢复速度快</li></ul><p><strong>RDB的劣势</strong></p><ul><li>fork的适合内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li><li>虽然redis在fork时使用了写时拷贝技术，但是如果数据庞大还是比较消耗性能的</li><li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down会造成数据丢失</li></ul><p><strong>RDB备份</strong></p><p>启动后会自动的找dump.rdb文件进行恢复同步</p><h4 id="9-2-AOF"><a href="#9-2-AOF" class="headerlink" title="9.2 AOF"></a>9.2 AOF</h4><p>AOF是以日志的形式来记录每个写操作，将Redis执行过的u送有的写指令记录下来</p><p>将redis所有写的指令记录下来，只允许追加文件不允许改写文件</p><p>redis重启的话就是根据日志文件的内容将指令从前到后执行一遍完成数据恢复工作</p><p><strong>AOF默认不开启</strong></p><p><strong>配置</strong></p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%BC%80%E5%90%AFaof.png"></p><p>开启AOF并且配置文件路径</p><p>AOF 和 RDB同时开启，默认读取AOF</p><p>重启redis会自动加载aof的数据</p><p><strong>异常恢复</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 对文件进行修复操作</span></span><br>redis-check-aof --fix appendonly.aof<br></code></pre></td></tr></table></figure><p><strong>AOF同步频率设置</strong></p><ul><li>appendfsync always<ul><li>始终同步，保障数据完整</li></ul></li><li>appendfsync everysec<ul><li>每秒同步，本秒数据可能会丢失</li></ul></li><li>appendfsync no<ul><li>不进行同步，把同步时机交给操作系统</li></ul></li></ul><p><strong>重写压缩 Rewrite</strong></p><ul><li>只关心结果不关心过程</li></ul><p><strong>重写原理</strong></p><p>AOF文件持续增长过大时，会fork出一条新线程来将文件重写</p><p><strong>AOF持久化流程</strong></p><ul><li>客户端请求写命令的时候会被追加到aof缓冲区内</li><li>然后根据缓冲策略写入文件</li><li>aof文件大小超过容量时候重写操作</li><li>服务重启时候会重新load加载aof文件中的写操作达到恢复数据的目的</li></ul><p> <strong>优势</strong></p><ul><li>备份机制更加稳健，丢失数据概率更低</li><li>可读的日志文本，通过操作aof可以处理误操作</li></ul><p><strong>劣势</strong></p><ul><li>比起RDB占用更多的磁盘空间</li><li>恢复备份的速度满</li><li>每次读写同步的话，有一定的性能压力</li></ul><h4 id="9-3-对比"><a href="#9-3-对比" class="headerlink" title="9.3 对比"></a>9.3 对比</h4><ul><li>如果对数据不敏感，单独使用RDB</li><li>不建议单独使用AOF</li><li>如果只做纯内存缓存，可以都不用</li></ul><h3 id="10-、主从复制"><a href="#10-、主从复制" class="headerlink" title="10 、主从复制"></a>10 、主从复制</h3><ul><li>读写分离，高可用</li><li>容灾的快速恢复</li></ul><h4 id="10-1-配置主从复制"><a href="#10-1-配置主从复制" class="headerlink" title="10.1 配置主从复制"></a>10.1 配置主从复制</h4><p>查看机器状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">info replication <br></code></pre></td></tr></table></figure><p>如何配置主从？</p><p><strong>配从不配主</strong></p><p>成为某个对象的从服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">slaveof 192.168.64.132 6379<br></code></pre></td></tr></table></figure><p>查看主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; info replication<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:master<br>connected_slaves:2<br>slave0:ip=192.168.64.133,port=6379,state=online,offset=42,lag=0<br>slave1:ip=192.168.64.134,port=6379,state=online,offset=42,lag=1<br>master_failover_state:no-failover<br>master_replid:6822630792ada5cd8001c81527e73c2b458691b4<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:42<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:42<br><br></code></pre></td></tr></table></figure><h4 id="10-2-常用配置策略"><a href="#10-2-常用配置策略" class="headerlink" title="10.2 常用配置策略"></a>10.2 常用配置策略</h4><p><strong>主从复制原理</strong></p><ul><li>从连接主服务器后，从服务器会向主服务器发送数据同步的消息</li><li>主服务器接到同步消息后会把主服务器的数据进行持久化放到rdb文件中去，然后从服务器拿到rdb文件进行读取</li><li>每次主服务器进行写操作后，都会和从服务器进行数据同步</li></ul><p><strong>如果从服务器，挂了怎么办</strong></p><p><strong>一主二从</strong></p><ul><li>从服务器挂了之后重启不会自动加入服务器</li><li>从服务器回到集群后数据重新完整</li></ul><p>主服务器挂了之后从服务器依旧认主服务器</p><p><strong>薪火相传</strong></p><p>一主多从 </p><p>主服务器只同步到一台从服务器</p><ul><li>缺点<ul><li>不能连续同步</li></ul></li></ul><p><strong>反客为主</strong></p><p>主服务器宕机后从服务器变为主服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">slaveof no one ## 将主机变为从机<br></code></pre></td></tr></table></figure><h4 id="10-3-哨兵模式"><a href="#10-3-哨兵模式" class="headerlink" title="10.3 哨兵模式"></a>10.3 哨兵模式</h4><p>哨兵模式能够后台监控主机是否故障，如果故障了根据投票数自动将从库转为主库</p><p><strong>使用步骤</strong></p><p>一主二仆</p><p>配置哨兵模式</p><ul><li><p>编写配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 新建 sentinel.conf 文件</span></span><br>sentinel monitor mymaster 192.168.64.132 6379 1<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 同意迁移的数量</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 启动哨兵</span></span><br>redis-sentinel sentinel.conf<br></code></pre></td></tr></table></figure></li><li><p>当主机挂掉之后从机选举新的主机</p><ul><li><p>选举规则</p><ul><li>优先靠前的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">slave-priority 100 值越小 优先级越高<br></code></pre></td></tr></table></figure><ul><li>偏移量最大的，也就是和主机同步最多的</li><li>选择runid最小的从服务</li></ul></li></ul></li><li><p>复制延迟</p><ul><li>由于所有的写操作都是先在master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的铲齿，当系统很繁忙的时候延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重</li></ul></li></ul><h3 id="11、集群操作"><a href="#11、集群操作" class="headerlink" title="11、集群操作"></a>11、集群操作</h3><p>容量不够，redis如何进行扩容</p><p>并发写操作，redis如何分摊</p><p><strong>无中心化集群</strong></p><p>任何一台服务器都可以作为入口</p><h4 id="11-1-redis集群简介"><a href="#11-1-redis集群简介" class="headerlink" title="11.1 redis集群简介"></a>11.1 redis集群简介</h4><p>redis集群实现了对redis的水平扩容</p><p>redis通过分区提供一定的可用性，即使集群中一部分服务宕机也可以接着使用</p><h4 id="11-2-redis集群的配置"><a href="#11-2-redis集群的配置" class="headerlink" title="11.2 redis集群的配置"></a>11.2 redis集群的配置</h4><ul><li><p>开启daemonize yes</p></li><li><p>打开集群模式</p><ul><li>cluster-enabled yes</li><li>cluster-config-file nodes-6379.conf 设置节点配置文件名</li><li>cluster-node-timeout 1500 设定节点失联事件，超过该时间集群自动进行主要从切换</li></ul></li><li><p>启动redis</p></li><li><p>将节点合成集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /opt/redis-6.2.1/src<br>redis-cli --cluster create --cluster-replicas 1 ip:port<br><br></code></pre></td></tr></table></figure></li></ul><h4 id="11-3-redis-cluster"><a href="#11-3-redis-cluster" class="headerlink" title="11.3 redis cluster"></a>11.3 redis cluster</h4><p>replicas  表示我们希望为集群中每个主节点创建一个从节点</p><p>分配原则尽量保证主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上</p><p><strong>什么是slots</strong></p><p>一个redis集群包含16384个插槽，数据库中每个键都属于这16384个插槽的其中一个，集群使用crc16(key) % 16384来计算键key属于哪个槽，其中crc16语句用于计算键key的crc16校验和</p><p>集群环境中如何批量插入？</p><p>使用组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mset name&#123;user&#125; lucy age&#123;user&#125; 18<br></code></pre></td></tr></table></figure><h3 id="12、-Redis的问题"><a href="#12、-Redis的问题" class="headerlink" title="12、 Redis的问题"></a>12、 Redis的问题</h3><h4 id="12-1-缓存穿透"><a href="#12-1-缓存穿透" class="headerlink" title="12.1 缓存穿透"></a>12.1 缓存穿透</h4><ul><li><p>应用服务器压力变大了</p></li><li><p>redis命中率低</p><ul><li>一直查询数据库导致数据库崩了</li><li>原因<ul><li>redis查不到数据</li><li>出现了很多非正常的url访问</li></ul></li></ul></li><li><p>对空值做缓存</p><ul><li>设置空结果时间会很短</li></ul></li><li><p>设置可访问的名单</p><ul><li>使用bitmaps类型定义一个可访问的名单</li></ul></li><li><p>采用布隆过滤器</p><ul><li>布隆过滤器是一个很长的二进制向量，位图和一系列所及映射函数</li></ul></li></ul><h4 id="12-2-缓存击穿"><a href="#12-2-缓存击穿" class="headerlink" title="12.2 缓存击穿"></a>12.2 缓存击穿</h4><p><strong>现象</strong></p><p>数据库的访问压力瞬时增大</p><p>redis并没有出现大量的key过期</p><p>redis是正常的运行状态</p><p><strong>原因</strong></p><p>redis的某个key过期了，大量的访问</p><p>热点key过期了</p><ul><li>预先设置热门数据</li><li>实时调整：现场监控哪些热门数据，实时调整key过期时常</li><li>使用锁<ul><li>在缓存失效的时候不是立刻去load db</li></ul></li></ul><h4 id="12-3-缓存雪崩"><a href="#12-3-缓存雪崩" class="headerlink" title="12.3 缓存雪崩"></a>12.3 缓存雪崩</h4><p><strong>现象</strong></p><p>数据库压力过大，应用访问变慢</p><p><strong>原因</strong></p><p>极少时间段内，查询大量key的集中过期情况</p><ul><li><p>构建多级缓存架构</p></li><li><p>使用锁或队列</p><ul><li>不适用高并发情况</li></ul></li><li><p>设置过期标志更新缓存</p><ul><li>记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去实际更新key的缓存</li></ul></li></ul><h4 id="12-4-分布式锁"><a href="#12-4-分布式锁" class="headerlink" title="12.4 分布式锁"></a>12.4 分布式锁</h4><p><strong>单纯的javaAPI 并不能提供分布式锁的能力，为了解决这个问题，需要一种跨JVM的互斥机制来控制共享资源的访问</strong></p><p>分布式锁的主流解决方案</p><ul><li>基于数据库实现分布式锁</li><li>基于缓存</li><li>基于zookeeper</li></ul><p>通过setnx 释放锁</p><p>释放锁用del</p><p>锁一直没有释放，设置过期时间自动释放</p><p><strong>分布式锁可能会导致释放别人的锁</strong></p><p>使用uuid 防止误删</p><ul><li>uuid表示不同的操作</li><li>释放锁的时候判断当前的uuid和要释放的uuid是否相同</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper</title>
    <link href="/2022/04/05/Zookeeper/"/>
    <url>/2022/04/05/Zookeeper/</url>
    
    <content type="html"><![CDATA[<h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><h5 id="1、概览"><a href="#1、概览" class="headerlink" title="1、概览"></a>1、概览</h5><p>zookeeper是一个开源的分布式协调服务，他的设计目的是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的愿语集，并以一系列简单易用的接口提供给用户使用</p><p><strong>Zookeeper为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现数据发布&#x2F;订阅。负载均衡，命名服务，分布式协调通知，集群管理，Master选举，分布式锁和分布式队列等功能</strong></p><p>Zookeeper将数据保存在内存中，性能是非常棒的</p><h6 id="1-1-Zookeeper的特点"><a href="#1-1-Zookeeper的特点" class="headerlink" title="1.1 Zookeeper的特点"></a>1.1 Zookeeper的特点</h6><ul><li><strong>顺序一致性</strong>：从同一个客户端发起的事物请求，最终会严格的按照顺序被应用到Zookeeper中去</li><li><strong>原子性</strong>：所有事物请求的处理结果在整个集群中所有的应用情况是一致的</li><li><strong>单一系统映像</strong>：无论客户端连接到哪一个Zookeeper服务器上，其看到的服务端数据模型都是一致的</li><li><strong>可靠性</strong>：一旦一次更改请求被应用，更改的结果就会被持久化，直到下一次被更改</li></ul><h6 id="1-2-Zookeeper的应用场景"><a href="#1-2-Zookeeper的应用场景" class="headerlink" title="1.2 Zookeeper的应用场景"></a>1.2 Zookeeper的应用场景</h6><ul><li><strong>分布式锁</strong>：通过创建唯一节点获得分布式锁，获得锁的乙方执行完成相关代码后就释放锁</li><li><strong>命名服务</strong>：通过顺序节点生成唯一ID</li><li><strong>发布订阅</strong>：通过watch机制可以很方便的实现数据发布订阅</li></ul><h6 id="1-3-Zookeeper的重要概念"><a href="#1-3-Zookeeper的重要概念" class="headerlink" title="1.3 Zookeeper的重要概念"></a>1.3 Zookeeper的重要概念</h6><p><strong>Data model 数据模型</strong></p><p>Zookeeper数据模型是采用层次化的多叉树结构，每个节点上都可以存储数据，这些数据可以是数字，字符串或者是二进制序列，并且，每个节点还可以拥有n哥子节点，最上层是根节点，每个数据节点在Zookeeper中被称为Znode，他是Zookeeper中数据的最小单元，并且每个znode都是唯一的路径标志</p><p><strong>Znode 数据节点</strong></p><p>znode是Zookeeper中数据的最小单元，要存放的数据就放在上面</p><p><strong>Znode的4种类型</strong></p><ul><li>持久节点：一旦创建就一直存在，即便zookeeper集群宕机，知道将其删除</li><li>临时节点：零食节点的生命周期是与客户端会话绑定的，会话小时则节点消失，临时节点只能做叶子节点，不能创建子节点</li><li>持久顺序节点：除了具有持久节点的特点之后，子节点的名称还具有顺序性</li><li>临时顺序节点：除了具备临时节点的特征之外，子节点的名称还具有顺序性</li></ul><p><strong>znode的数据结构</strong></p><p>每个znode由两部分组成</p><ul><li>stat：状态信息</li><li>data：节点存放的数据的具体内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 6] get /dubbo<br><span class="hljs-meta prompt_"># </span><span class="language-bash">该数据节点关联的数据内容为空</span><br>null<br><span class="hljs-meta prompt_"># </span><span class="language-bash">下面是该数据节点的一些状态信息，其实就是 Stat 对象的格式化输出</span><br>cZxid = 0x2<br>ctime = Tue Nov 27 11:05:34 CST 2018<br>mZxid = 0x2<br>mtime = Tue Nov 27 11:05:34 CST 2018<br>pZxid = 0x3<br>cversion = 1<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 0<br>numChildren = 1<br><br></code></pre></td></tr></table></figure><table><thead><tr><th>znode 状态信息</th><th>解释</th></tr></thead><tbody><tr><td>cZxid</td><td>create ZXID，即该数据节点被创建时的事务 id</td></tr><tr><td>ctime</td><td>create time，即该节点的创建时间</td></tr><tr><td>mZxid</td><td>modified ZXID，即该节点最终一次更新时的事务 id</td></tr><tr><td>mtime</td><td>modified time，即该节点最后一次的更新时间</td></tr><tr><td>pZxid</td><td>该节点的子节点列表最后一次修改时的事务 id，只有子节点列表变更才会更新 pZxid，子节点内容变更不会更新</td></tr><tr><td>cversion</td><td>子节点版本号，当前节点的子节点每次变化时值增加 1</td></tr><tr><td>dataVersion</td><td>数据节点内容版本号，节点创建时为 0，每更新一次节点内容(不管内容有无变化)该版本号的值增加 1</td></tr><tr><td>aclVersion</td><td>节点的 ACL 版本号，表示该节点 ACL 信息变更次数</td></tr><tr><td>ephemeralOwner</td><td>创建该临时节点的会话的 sessionId；如果当前节点为持久节点，则 ephemeralOwner&#x3D;0</td></tr><tr><td>dataLength</td><td>数据节点内容长度</td></tr><tr><td>numChildren</td><td>当前节点的子节点个数</td></tr></tbody></table><p><strong>版本</strong></p><p>对于每个znode，zookeeper都会为其维护一个叫做stat的数据结构，stat中记录了这个znode的三个相关版本</p><ul><li>dataVersion：当前node节点的版本号</li><li>cversion：当前znode子节点的版本</li><li>aclVersion：当前znode的ACL的版本</li></ul><p><strong>权限控制</strong></p><p>ZooKeeper 采用 ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。</p><p>对于 znode 操作的权限，ZooKeeper 提供了以下 5 种：</p><ul><li><strong>CREATE</strong> : 能创建子节点</li><li><strong>READ</strong> ：能获取节点数据和列出其子节点</li><li><strong>WRITE</strong> : 能设置&#x2F;更新节点数据</li><li><strong>DELETE</strong> : 能删除子节点</li><li><strong>ADMIN</strong> : 能设置节点 ACL 的权限</li></ul><p>其中尤其需要注意的是，<strong>CREATE</strong> 和 <strong>DELETE</strong> 这两种权限都是针对 <strong>子节点</strong> 的权限控制。</p><p>对于身份认证，提供了以下几种方式：</p><ul><li><strong>world</strong> ： 默认方式，所有用户都可无条件访问。</li><li><strong>auth</strong> :不使用任何 id，代表任何已认证的用户。</li><li><strong>digest</strong> :用户名:密码认证方式： <em>username:password</em> 。</li><li><strong>ip</strong> : 对指定 ip 进行限制</li></ul><h6 id="1-4-Watch-事件监听器"><a href="#1-4-Watch-事件监听器" class="headerlink" title="1.4 Watch 事件监听器"></a>1.4 Watch 事件监听器</h6><p>事件监听器是zookeeper中一个很重要的特性，zookeeper允许用户在指定节点上注册一下watcher，并且在一些特定事件触发的时候，zookeeper服务端会将事件通知到感兴趣的客户端上去，该机制是zookeeper实现分布式协调服务的重要特性</p><h6 id="1-5-会话"><a href="#1-5-会话" class="headerlink" title="1.5 会话"></a>1.5 会话</h6><p>Session 可以看作是 ZooKeeper 服务器与客户端的之间的一个 TCP 长连接，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watcher 事件通知。</p><p>Session 有一个属性叫做：<code>sessionTimeout</code> ，<code>sessionTimeout</code> 代表会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在<code>sessionTimeout</code>规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p><p>另外，在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 <code>sessionID</code>。由于 <code>sessionID</code>是 ZooKeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 <code>sessionID</code> 的，因此，无论是哪台服务器为客户端分配的 <code>sessionID</code>，都务必保证全局唯一。</p><h6 id="1-6-集群"><a href="#1-6-集群" class="headerlink" title="1.6 集群"></a>1.6 集群</h6><p>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。通常 3 台服务器就可以构成一个 ZooKeeper 集群了。ZooKeeper 官方提供的架构图就是一个 ZooKeeper 集群整体对外提供服务。</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/zookeeper%E9%9B%86%E7%BE%A4.png"></p><p>上图中每一个 Server 代表一个安装 ZooKeeper 服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 ZAB 协议（ZooKeeper Atomic Broadcast）来保持数据的一致性。</p><p><strong>最典型集群模式： Master&#x2F;Slave 模式（主备模式）</strong>。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务</p><p><strong>但是在Zookeeper中没有选择传统的主备概念，而是引入了Leader、Followe、Observe</strong></p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E9%80%89%E4%B8%BE%E6%A8%A1%E5%BC%8F.png"></p><p>Zookeeper集群中所有的机器通过一个Leader选举过程来选定一台成为leader的机器，leader既可以为客户端提供写服务，也可以提供读服务，follower和observer只能提供读服务器，Follower和Observer的唯一区别是observer不参与leader的选举过程，也不参与过半写成功的策略，因此observer机器可以在不影响性能的情况下提升集群的读性能</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>Leader</td><td>为客户端提供读和写的服务，负责投票的发起和决议，更新系统状态。</td></tr><tr><td>Follower</td><td>为客户端提供读服务，如果是写服务则转发给 Leader。参与选举过程中的投票。</td></tr><tr><td>Observer</td><td>为客户端提供读服务，如果是写服务则转发给 Leader。不参与选举过程中的投票，也不参与“过半写成功”策略。在不影响写性能的情况下提升集群的读性能。此角色于 ZooKeeper3.3 系列新增的角色。</td></tr></tbody></table><p>选举的过程：</p><ol><li>选举阶段：只要一个节点得到半数节点的票数，就可当选leader</li><li>发现阶段：follower节点跟谁leader通信，同步followers最近接受的事物</li><li>同步阶段：同步阶段主要是利用leader前一阶段获得的最新提议历史，同步集群中所有的副本</li><li>广播阶段：到了这个阶段，zookeeper才能正式对外提供事物服务，并且leader可以进行消息广播，同时如果有新的节点加入，还需要对新的节点进行同步</li></ol><p><strong>集群状态</strong></p><ul><li><strong>LOOKING</strong> ：寻找 Leader。</li><li><strong>LEADING</strong> ：Leader 状态，对应的节点为 Leader。</li><li><strong>FOLLOWING</strong> ：Follower 状态，对应的节点为 Follower。</li><li><strong>OBSERVING</strong> ：Observer 状态，对应节点为 Observer，该节点不参与 Leader 选举。</li></ul><p><strong>zookeeper集群为什么是奇数台</strong></p><p>zookeeper集群在宕掉几个zookeeper服务后，如果剩下的zookeeper服务个数大于宕机的个数整个zookeeper才可以使用，</p><p>所有服务个数必须大于n&#x2F;2，所以2n和2n-1的容忍度是一样的</p><p><strong>如果防止集群脑裂</strong></p><p>脑裂现象就是在集群被割裂成了几个小集群，各个集群各自选出了leader的情况</p><p><strong>过半机制防止脑裂</strong></p><p>ZooKeeper 的过半机制导致不可能产生 2 个 leader，因为少于等于一半是不可能产生 leader 的，这就使得不论机房的机器如何分配都不可能发生脑裂。</p><h6 id="1-7-ZAB协议和Paxos算法"><a href="#1-7-ZAB协议和Paxos算法" class="headerlink" title="1.7 ZAB协议和Paxos算法"></a>1.7 ZAB协议和Paxos算法</h6><h5 id="2、安装Zookeeper"><a href="#2、安装Zookeeper" class="headerlink" title="2、安装Zookeeper"></a>2、安装Zookeeper</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">docker pull zookeeper:<span class="hljs-number">3.5</span><span class="hljs-number">.8</span><br>docker run -d --name zookeeper -p <span class="hljs-number">2181</span>:<span class="hljs-number">2181</span> zookeeper:<span class="hljs-number">3.5</span><span class="hljs-number">.8</span><br>docker run exec -it ID /bin/bash<br>./zkCli.sh -server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span><br></code></pre></td></tr></table></figure><h5 id="3、常用命令"><a href="#3、常用命令" class="headerlink" title="3、常用命令"></a>3、常用命令</h5><h6 id="3-1-创建节点-crerate命令"><a href="#3-1-创建节点-crerate命令" class="headerlink" title="3.1 创建节点 crerate命令"></a>3.1 创建节点 crerate命令</h6><p>通过create命令在根目录创建了node1节点，与他关联的字符串是node1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">create /node1 &quot;node1&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">create /node1/node1.1 123<br></code></pre></td></tr></table></figure><h6 id="3-2-更新节点-set命令"><a href="#3-2-更新节点-set命令" class="headerlink" title="3.2 更新节点 set命令"></a>3.2 更新节点 set命令</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set /node1 &quot;Set node1&quot;<br></code></pre></td></tr></table></figure><h6 id="3-3-获取节点-get命令"><a href="#3-3-获取节点-get命令" class="headerlink" title="3.3 获取节点 get命令"></a>3.3 获取节点 get命令</h6><p>get命令可以获取指定节点的数据内容和节点状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set /node1 &quot;Set node1&quot;<br></code></pre></td></tr></table></figure><h6 id="3-4-查看某个目录下的子节点（ls命令）"><a href="#3-4-查看某个目录下的子节点（ls命令）" class="headerlink" title="3.4 查看某个目录下的子节点（ls命令）"></a>3.4 查看某个目录下的子节点（ls命令）</h6><p>通过ls命令查看根目录下的节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls /<br></code></pre></td></tr></table></figure><p>通过ls命令查看&#x2F;node1目录下的节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls /node1<br></code></pre></td></tr></table></figure><h6 id="3-5-查看节点状态-stat-命令"><a href="#3-5-查看节点状态-stat-命令" class="headerlink" title="3.5 查看节点状态(stat)命令"></a>3.5 查看节点状态(stat)命令</h6><p>通过stat 命令查看节点状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">stat /node1<br></code></pre></td></tr></table></figure><h6 id="3-6-查看节点信息和状态-ls2-命令"><a href="#3-6-查看节点信息和状态-ls2-命令" class="headerlink" title="3.6 查看节点信息和状态(ls2)命令"></a>3.6 查看节点信息和状态(ls2)命令</h6><p>通过stat 命令查看节点状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls2 /node1<br><br>[node1.1]<br>cZxid = 0x2<br>ctime = Mon Jun 06 00:44:36 UTC 2022<br>mZxid = 0x4<br>mtime = Mon Jun 06 00:47:12 UTC 2022<br>pZxid = 0x3<br>cversion = 1<br>dataVersion = 1<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 8<br>numChildren = 1<br><br></code></pre></td></tr></table></figure><h6 id="3-7-删除节点（delete命令）"><a href="#3-7-删除节点（delete命令）" class="headerlink" title="3.7 删除节点（delete命令）"></a>3.7 删除节点（delete命令）</h6><p>通过stat 命令查看节点状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">delete /node1/node1.1<br></code></pre></td></tr></table></figure><h5 id="4、ZookeeperJava客户端Curator简单使用"><a href="#4、ZookeeperJava客户端Curator简单使用" class="headerlink" title="4、ZookeeperJava客户端Curator简单使用"></a>4、ZookeeperJava客户端Curator简单使用</h5><p>curator 是由Netfix开源的一个java连接客户端</p><p>依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;<br>    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">4.2</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;<br>    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">4.2</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h6 id="4-1-连接zookeeper客户端"><a href="#4-1-连接zookeeper客户端" class="headerlink" title="4.1 连接zookeeper客户端"></a>4.1 连接zookeeper客户端</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">zookeeperTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BASE_SLEEP_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_RETRIES</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br><span class="hljs-comment">// Retry strategy. Retry 3 times, and will increase the sleep time between retries.</span><br>        <span class="hljs-type">RetryPolicy</span> <span class="hljs-variable">retryPolicy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(BASE_SLEEP_TIME, MAX_RETRIES);<br>        <span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">zkClient</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory.builder()<br>                <span class="hljs-comment">// the server to connect to (can be a server list)</span><br>                .connectString(<span class="hljs-string">&quot;192.168.64.132:2181&quot;</span>)<br>                .retryPolicy(retryPolicy)<br>                .build();<br>        zkClient.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>基本参数说明：BASE_SLEEP_TIME 重试之间等待的初始时间</li><li>MAX_RETRIES：最大重试次数</li><li>connectString：要链接的服务器列表</li><li>retryPolicy：重试策略</li></ul><h6 id="4-2-数据节点的增删改查"><a href="#4-2-数据节点的增删改查" class="headerlink" title="4.2 数据节点的增删改查"></a>4.2 数据节点的增删改查</h6><ul><li><p>创建持久化节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().forPath(<span class="hljs-string">&quot;/node2/00001&quot;</span>);<br>zkClient.create().withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/node2/00002&quot;</span>);<br></code></pre></td></tr></table></figure><p>上述的代码中创建了两个节点，默认的都是持久化节点</p><p>但是上述的代码会报错，因为我们没有node2节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">KeeperErrorCode = NoNode <span class="hljs-keyword">for</span> /node2/<span class="hljs-number">00001</span><br></code></pre></td></tr></table></figure></li><li><p>创建持久化节点（父节点不存在）</p><p>当父节点不存在的时候，可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/node2/00001&quot;</span>);<br>  <br></code></pre></td></tr></table></figure></li><li><p>创建节点并指定数据内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>.getBytes());<br>zkClient.getData().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<span class="hljs-comment">//获取节点的数据内容，获取到的是 byte数组</span><br></code></pre></td></tr></table></figure></li><li><p>检测节点是否创建成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.checkExists().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<span class="hljs-comment">//不为null的话，说明节点创建成功</span><br></code></pre></td></tr></table></figure></li><li><p>删除节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.delete().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>删除一个节点及下面的所有节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">&quot;/node1&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>获取节点内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>.getBytes());<br>zkClient.getData().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<span class="hljs-comment">//获取节点的数据内容</span><br>zkClient.setData().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>,<span class="hljs-string">&quot;c++&quot;</span>.getBytes());<span class="hljs-comment">//更新节点数据内容</span><br></code></pre></td></tr></table></figure></li><li><p>获取某个节点的所有子节点路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; childrenPaths = zkClient.getChildren().forPath(<span class="hljs-string">&quot;/node1&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h5 id="4-3-监听器"><a href="#4-3-监听器" class="headerlink" title="4.3 监听器"></a>4.3 监听器</h5><p>如何给某个节点注册子节点监听器，注册了监听器之后，这个子节点发生变化，比如增加、减少或者更新的时候，可以自定义回调操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/node1&quot;</span>;<br><span class="hljs-type">PathChildrenCache</span> <span class="hljs-variable">pathChildrenCache</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathChildrenCache</span>(zkClient, path, <span class="hljs-literal">true</span>);<br><span class="hljs-type">PathChildrenCacheListener</span> <span class="hljs-variable">pathChildrenCacheListener</span> <span class="hljs-operator">=</span> (curatorFramework, pathChildrenCacheEvent) -&gt; &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;;<br>pathChildrenCache.getListenable().addListener(pathChildrenCacheListener);<br>pathChildrenCache.start();<br></code></pre></td></tr></table></figure><p>如果要获取节点事件类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">pathChildrenCacheEvent.getType()<br></code></pre></td></tr></table></figure><p>一共有下面几种类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Type</span> &#123;<br>    CHILD_ADDED,<span class="hljs-comment">//子节点增加</span><br>    CHILD_UPDATED,<span class="hljs-comment">//子节点更新</span><br>    CHILD_REMOVED,<span class="hljs-comment">//子节点被删除</span><br>    CONNECTION_SUSPENDED,<br>    CONNECTION_RECONNECTED,<br>    CONNECTION_LOST,<br>    INITIALIZED;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Type</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2022/03/29/JVM/"/>
    <url>/2022/03/29/JVM/</url>
    
    <content type="html"><![CDATA[<h2 id="JVM-基础学习"><a href="#JVM-基础学习" class="headerlink" title="JVM 基础学习"></a>JVM 基础学习</h2><p>jvm实际上是一个标准，每个厂商有不同的java虚拟机的实现</p><h3 id="1、JVM的内存结构"><a href="#1、JVM的内存结构" class="headerlink" title="1、JVM的内存结构"></a>1、JVM的内存结构</h3><h4 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h4><p>程序计数器是记住程序吓一跳执行执行的内存地址，由于我们的Java是多线程执行的，如果一个程序执行到一部分，然而此时CPU分配的时间片用完了，需要利用程序计数器记住程序执行的位置</p><p>程序计数器是线程私有的</p><p>程序计数器是利用了操作系统中的寄存器实现的，寄存器是我们操作系统中运行最快的部分</p><h4 id="1-2-虚拟机栈"><a href="#1-2-虚拟机栈" class="headerlink" title="1.2 虚拟机栈"></a>1.2 虚拟机栈</h4><p>虚拟机栈是线程运行的空间，我们每产生一个线程，就会创建一个虚拟机栈，虚拟机栈的单位叫做栈帧，每次调用一次方法就会产生一个栈帧，<strong>栈帧是一个方法运行时候需要的内存</strong></p><p><strong>垃圾回收机制是否需要处理虚拟机栈</strong></p><p>垃圾回收机制不处理栈当中的内存，因为我们的虚拟机栈方法调用完毕出栈后会自己释放内存</p><p><strong>栈内存是越大越好吗</strong></p><p>栈内存不是越大越好，如果我们的栈内存大会导致我们的线程数变少</p><p><strong>方法区内的变量是否线程安全</strong></p><p>方法区内的线程是线程安全的，但是要注意变量是否逃离了方法区</p><p><strong>如何设置栈内存</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-Xss  ## 虚拟机参数 可以设置栈内存<br></code></pre></td></tr></table></figure><p><strong>栈内存溢出</strong></p><p>一般栈内存溢出的原因都是因为递归调用导致的，或者栈帧过大导致了栈内存溢出</p><p>例如我们在fastjson中类循环调用的时候，会导致栈内存溢出</p><p><strong>如何查看栈内存</strong></p><ul><li>案例一 cpu占用过高<ul><li>首先使用top命令查看占用情况</li><li>利用ps -eo pid,tid %cpu 查看cpu占用ing看</li><li>使用jstack 进程id查看代码哪里出现了问题</li></ul></li><li>案例二 程序长时间无返回<ul><li>查看是否有死锁</li></ul></li></ul><h4 id="1-3-本地方法区"><a href="#1-3-本地方法区" class="headerlink" title="1.3 本地方法区"></a>1.3 本地方法区</h4><p>本地方法区是为了调用本地方法而设置的区域</p><h4 id="1-4-堆内存"><a href="#1-4-堆内存" class="headerlink" title="1.4 堆内存"></a>1.4 堆内存</h4><p>堆是线程共享的内存，通过new关键字创建的都会放在堆内存中，堆内存是受到垃圾回收机制所影响的区域，Java中几乎所有的对象都在这里被分配</p><p><strong>如何设置堆内存大小</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-xmx ## 设置堆内存大小<br></code></pre></td></tr></table></figure><p><strong>如何查看堆内存溢出</strong></p><ul><li>JPS命令</li><li>JMP命令</li><li>Jconsole命令</li><li>Jmp-heap命令</li><li>jvisualvm</li></ul><h4 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h4><p>方法区是各个线程共享的区域，用于存储已经呗虚拟机加载的类型信息，常量静态常量等等，从逻辑上来讲他是堆内存的一部分，不同时期的虚拟机对于方法区定义的位置不同，在jdk1.8以前，方法区存放在永久代中，所以当时经常会发生内存溢出，jdk1.8之后，将方法区独立出来，使用了元空间，元空间直接由内存管理，但是最终留下了运行时常量池</p><p><strong>常量池</strong></p><p>常量池就是一张表，虚拟机根据这张表要找到执行的类名，方法名，参数类型，字面量等信息</p><p><strong>运行时常量池</strong></p><p>常量池是class文件中的，当类被加载完毕后，常量池的信息会放到内存当中，成为运行时常量池</p><p><strong>StringTable 串池</strong></p><ul><li><p>常量池中的字符串仅仅是符号，第一次用到时才变为对象</p></li><li><p>利用传池的机制，来避免重复创建字符串对象</p></li><li><p>字符串变量拼接的原理是Stringbuilder</p></li><li><p>字符串常量拼接的原理是编译器优化</p></li><li><p>可以使用interin方法，主动将串池中还没有的字符串对象放入串池</p><ul><li>1.8将这个字符串对象尝试放入串池，如果有则不会放入，没有没有则放入串池，会把串池中的对象返回</li></ul></li></ul><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="1、-垃圾回收器"><a href="#1、-垃圾回收器" class="headerlink" title="1、 垃圾回收器"></a>1、 垃圾回收器</h3><h4 id="1-1-垃圾回收器分类"><a href="#1-1-垃圾回收器分类" class="headerlink" title="1.1 垃圾回收器分类"></a>1.1 垃圾回收器分类</h4><ol><li>串行的垃圾回收器<ul><li>单线程</li><li>堆内存较小，适用于个人电脑</li></ul></li><li>吞吐量优先的垃圾回收器<ul><li>多线程的</li><li>堆内存较大，需要多核CPU支持</li><li>在单位时间内stw的时间最短</li></ul></li><li>响应时间优先<ul><li>多线程</li><li>堆内存较大、多核CPU</li><li>尽可能的让单次的stw的时间最短</li></ul></li></ol><h4 id="1-2-串行的垃圾回收器"><a href="#1-2-串行的垃圾回收器" class="headerlink" title="1.2 串行的垃圾回收器"></a>1.2 串行的垃圾回收器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">--XX:+UseSerialGC=Serial + SerialOld<br></code></pre></td></tr></table></figure><ul><li>Serial 工作在新生代使用复制算法、</li><li>SerialOld 工作在老年代，使用的是标记整理算法</li></ul><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/JVm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220621115010.png"></p><h4 id="1-3-吞吐量优先的垃圾回收器"><a href="#1-3-吞吐量优先的垃圾回收器" class="headerlink" title="1.3 吞吐量优先的垃圾回收器"></a>1.3 吞吐量优先的垃圾回收器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+UseParallelGC~ -XX:+UseParallelOldGC ## 默认开启<br>-XX:+UseAdaptiveSizePolicy ## 采用自适应的大小策略<br>-XX:+GCTimeRatio=ratio ## GC tiee ratio 调整垃圾回收时间和总时间的占比<br>-XX:+MaxGCpauseMillis=ms ## 最大暂停毫秒数<br>-XX:+ParallelGCThreads=n ## <br></code></pre></td></tr></table></figure><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220621115010.png"></p><h4 id="1-4-响应时间优先"><a href="#1-4-响应时间优先" class="headerlink" title="1.4 响应时间优先"></a>1.4 响应时间优先</h4><p>老年代垃圾回收器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+UseConcMarkSweepGC~-XX:+UseParaNewGC~SerialOld<br>-XX:+ParallelGCThreads=n~ -XX:ConcGCThreads=threads ## 并发线程数，垃圾回收器<br>-XX:+CMSInitiatigOccupancyFraction=percent ## 执行CMS的占比<br>-XX:+CMSScavengeBeforeRemark ## <br></code></pre></td></tr></table></figure><h3 id="2、G1-垃圾回收器"><a href="#2、G1-垃圾回收器" class="headerlink" title="2、G1 垃圾回收器"></a>2、G1 垃圾回收器</h3><p><strong>Garbage First</strong></p><p>适用场景</p><ul><li>同事注重吞吐量和低延迟，默认的暂停目标是200ms</li><li>超大堆内存，会将堆划分为多个大小相等的Region</li><li>整体上是标记整理算法，两个区域之间是复制算法</li></ul><p>相关参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+UseG1GC<br>-XX:+G1HeapRegionSize=size<br>-XX:+MaxGCPauseMillis=time<br></code></pre></td></tr></table></figure><p><strong>垃圾回收阶段</strong></p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5.png"></p><p><strong>新生代 Young Collection阶段</strong></p><p>新生代垃圾回收会触发STW，使用复制算法放入幸存区</p><p><strong>新生代 + 并发标记阶段</strong></p><ul><li>在yougc时进行初始标记</li><li>当老年代占用的堆空间比例达到阈值时，进行并发标记，不会stw</li></ul><p><strong>Mixed Collection</strong></p><p>会对eso进行全面垃圾回收</p><ul><li>最终标记 会stw</li><li>拷贝存活 会stw</li></ul><p><strong>Young Collection 跨代引用</strong></p><p>新生代youngcollection 的时候首先寻找跟对象，然后检查然后复制，那么如果寻找的过程中需要调用老年代的节点怎么办，会造成速度下降</p><p>老年代中分为了还多的card，如果这个card中有引用新生代的对象，就会被标记为脏的card区</p><p>新生代总有一个remberset中记录了脏card</p><p>在引用变更通过写屏障+dirty card queue变更</p><p><strong>并发标记阶段和重新标记阶段</strong></p><p>只要对象的引用发生了变化，写屏障的指令就会被执行</p><h3 id="3、垃圾回收调优"><a href="#3、垃圾回收调优" class="headerlink" title="3、垃圾回收调优"></a>3、垃圾回收调优</h3><p><strong>调优领域</strong></p><ul><li>内存</li><li>锁竞争</li><li>cpu占用</li><li>io</li></ul><p><strong>调优的目标</strong></p><ul><li>低延迟还是高吞吐量，选择合适的回收器</li><li>CMS，G1，ZGC</li><li>ParallelGC</li></ul><h4 id="3-1-新生代调优"><a href="#3-1-新生代调优" class="headerlink" title="3.1 新生代调优"></a>3.1 新生代调优</h4><p>新生代的特点</p><ul><li>所有的new操作的内存分配非常廉价<ul><li>TLAB thread-local allocation buffer</li></ul></li><li>死亡对象的回收代价是0</li><li>大部分对象用过即死</li><li>Minor Gc的时间远低于Full GC</li></ul><p>新生代越大越好吗</p><p>-Xmn</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS 原理</title>
    <link href="/2022/03/15/AQS-%E5%8E%9F%E7%90%86/"/>
    <url>/2022/03/15/AQS-%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="Java-并发编程实战-AQS原理"><a href="#Java-并发编程实战-AQS原理" class="headerlink" title="Java 并发编程实战 - AQS原理"></a>Java 并发编程实战 - AQS原理</h3><p>Aqs其实类似于Sychronized的重量级锁，是一套阻塞式锁的同步器工具的框架，他的特点就是维护了一个 <strong>int</strong> 类型的status代表锁定状态，如果被请求的共享资源被占用，那么就需要一套线程组赛等待及被唤醒时锁分配的机制，这个机制AQS是CLH队列锁实现的，把暂时获取不到锁的线程放到队列中去</p><h4 id="1、什么是clh队列"><a href="#1、什么是clh队列" class="headerlink" title="1、什么是clh队列"></a>1、什么是clh队列</h4><p>CLH队列是一个虚拟的双向队列，我们的线程和一个Node节点进行关联，来实现锁的分配，实际上是用线程的LockSupport的park和unpark来实现的。</p><h4 id="2、park-amp-unpark的原理"><a href="#2、park-amp-unpark的原理" class="headerlink" title="2、park &amp; unpark的原理"></a>2、park &amp; unpark的原理</h4><p>每个线程都与一个Park对象相关联，这个条件变量的结构如下</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/park%E5%AF%B9%E8%B1%A1.png"></p><p>每一个park对象的结构都如上图所示</p><ul><li>mutex 为互斥锁</li><li>cond 为条件变量</li><li>counter 为计数</li></ul><p>判断线程是否需要停止或者继续执行的原理是，判断conter，如果counter是0，则进入cond进行等待，如果counter是1则不需要打断线程</p><p>所以在此基础上 <strong>park 和 unpark</strong> 就可以不按顺序的调用，调用park 就是检查counter的值，调用unpark就是给设置counter为1，所以如果先调用park 再调用unpark 就是常规的打断线程，线程继续执行，如果先unpark再park的话，线程就不会中断，继续执行</p><h4 id="3、ReentrantLock原理"><a href="#3、ReentrantLock原理" class="headerlink" title="3、ReentrantLock原理"></a>3、ReentrantLock原理</h4><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/returnlock%20%E5%8E%9F%E7%90%86.png"></p><p>RentrantLock也是实现了Lock接口</p><h5 id="3-1-加锁流程"><a href="#3-1-加锁流程" class="headerlink" title="3.1 加锁流程"></a>3.1 加锁流程</h5><p>首先是非公平锁的加锁流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates an instance of &#123;<span class="hljs-doctag">@code</span> ReentrantLock&#125;.</span><br><span class="hljs-comment"> * This is equivalent to using &#123;<span class="hljs-doctag">@code</span> ReentrantLock(false)&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码中可以看到，默认的锁是非公平锁，同步器实现的是NofairSync</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0.png"></p><p><strong>查看其非公平锁实现</strong></p><p>Nonfairsync的结构</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B1.png"></p><p>以上是一个同步器的结构，分别是状态，头节点，尾节点和所属的线程</p><p>查看源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="hljs-comment"> * acquire on failure.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>        setExclusiveOwnerThread(Thread.currentThread());<br>    <span class="hljs-keyword">else</span><br>        acquire(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>加锁成功</strong></p><ul><li>当第一个线程来的时候，cas state 如果成功的话，进入加锁流程</li><li>设置所属线程为当前的线程</li></ul><p><strong>加锁失败</strong></p><ul><li><p>此时cas state失败，进入else的acquire</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>再代码中会再次尝试如果尝试失败了会调用  acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，这个的作用就是创建一个Node节点与与线程进行关联</li></ul></li><li><p>进入acquireQueued</p><ul><li>进入方法后第一次会创建两个节点，一个是刚才和线程进行关联的节点，还有一个是哑元节点，并将双线量表的首位进行相连</li></ul></li></ul><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%8A%A0%E9%94%81%E5%A4%B1%E8%B4%A5.png"></p><p>​</p><ul><li><p>进入 selfInterrupt 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这方法中，无线循环中，会再次尝试获取到锁，获取失败后进入 shouldParkAfterFailedAcquire </p></li><li><p>shouldParkAfterFailedAcquire方法会将前驱节点的状态改为 -1 </p></li><li><p>在下次循环的时候就会调用 parkAndCheckInterrupt() 方法执行park，此时线程被打断</p></li></ul><p>此时还有多个线程进入，如果线程0依旧没有释放锁，最后就会变成如下的局面</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%89%8D%E8%B6%8B%E8%8A%82%E7%82%B9.png"></p><h5 id="3-2-解锁流程"><a href="#3-2-解锁流程" class="headerlink" title="3.2 解锁流程"></a>3.2 解锁流程</h5><p>此时Thread0结束后，会调用 release 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>此时设置owner为null，设置状态&#x3D; 0</p></li><li><p>当队列尾部null并且waitStatus &#x3D; -1 的时候调用unpark方法</p></li><li><p>unpark方法此时调用unpark方法恢复线程运行</p></li><li><p>此时如果线程获取到了锁，继续执行，同时进入加锁流程</p><ul><li>加锁流程会修改状态，同时删除原来的哑元节点，将第二个节点的信息设置为null</li></ul></li><li><p>由于当前是非公平锁，所以如果此时还有新的线程一起抢占锁，那么此时再次阻塞，加入队尾</p></li></ul><h5 id="3-3-可重入的原理"><a href="#3-3-可重入的原理" class="headerlink" title="3.3 可重入的原理"></a>3.3 可重入的原理</h5><p>判断当前线程是否等于owner线程，如果相等的话就设置状态 加 1</p><p>解锁时只是将计数 -1 只有当state为0的时候才会唤醒其他线程</p><h5 id="3-4-可打断原理"><a href="#3-4-可打断原理" class="headerlink" title="3.4 可打断原理"></a>3.4 可打断原理</h5><p><code>不可中断的含义</code>： 第一个线程获得某把锁后，第二个线程也想要获得该锁，则它必须处于阻塞或等待状态。如果第一个线程不释放锁，那第二个线程就会一直阻塞或等待，不可被中断。</p><p>Reentrantlock默认是不可大段的，及时被打断，任然会驻留再AQS队列中，等获得锁以后才会继续运行，只是打断标记被设置为true</p><p>可打断模式需要调用accquireInteruptibly 方法</p><p>如果有人打断，则会抛出异常，不会再队列中继续等</p><h5 id="3-5-公平锁的原理"><a href="#3-5-公平锁的原理" class="headerlink" title="3.5 公平锁的原理"></a>3.5 公平锁的原理</h5><p>公平锁的原理很简单，原理与非公平锁相同，再cas之前会检查AQS中是否有前驱节点，没有的话才回去竞争</p><h5 id="3-6-条件变量-Condition-的原理"><a href="#3-6-条件变量-Condition-的原理" class="headerlink" title="3.6 条件变量 Condition 的原理"></a>3.6 条件变量 Condition 的原理</h5><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86.png"></p><ul><li>如果线程需要进入到condtion中的话，就会放入到condtion当作，condition中是一个单项链表，维护了头节点和尾节点，同时设置他的状态为-2，代表目前在等待</li><li>然后会进行解锁，将他占有的锁全部释放 使用fullRelease</li><li>然后唤醒等待队列的下一个节点</li></ul><p><strong>唤醒流程 signal</strong></p><ul><li>首先判断唤醒的线程是否是主线程</li><li>然后找到condition中的第一个元素调用doSigna</li><li>将节点从条件变量中断开，然后加入到等待锁的队列当中去</li></ul><h4 id="4、读写锁-ReentrantReadWriteLock原理"><a href="#4、读写锁-ReentrantReadWriteLock原理" class="headerlink" title="4、读写锁 ReentrantReadWriteLock原理"></a>4、读写锁 ReentrantReadWriteLock原理</h4><p>共享锁和独占锁，共享锁可以被多个线程拥有，比如读锁，独占锁又叫排他锁，只能被一个线程所拥有</p><p>如果当前的操作远远的高于写的操作的时候，这个时候使用读写锁可以让读读并发，来提高性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">reentrantReadWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>ReentrantReadWriteLock.<span class="hljs-type">ReadLock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> reentrantReadWriteLock.readLock(); <span class="hljs-comment">// 读锁</span><br>ReentrantReadWriteLock.<span class="hljs-type">WriteLock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> reentrantReadWriteLock.writeLock();<span class="hljs-comment">// 写锁</span><br></code></pre></td></tr></table></figure><p>读写锁的使用事项</p><p>读锁不支持条件变量，写锁支持条件变量</p><p>重入不支持锁升级，但是支持锁降级，降级的时候</p><h5 id="4-1-加锁原理"><a href="#4-1-加锁原理" class="headerlink" title="4.1 加锁原理"></a>4.1 加锁原理</h5><p>虽然状态是两个，但是实际上使用的还是statu字段来分辨读锁和写锁，写锁的状态占了低16位，读锁状态占了高16位</p><ul><li>加锁和公平锁差不多</li><li>增加了判断的流程，判断当前是读锁还是写锁</li></ul><p><strong>加读锁</strong></p><ul><li>t2执行r.lock这时进入读锁的 sync.acquireShared 流程，首先会进入 tryAcquireShard流程，如果有写独占锁那么返回 -1 表示失败，如果返回 1 表示成功</li><li>加节点后添加的共享的节点类型所有的读锁的节点状态为shart，所有的写锁的状态是EX</li></ul><p><strong>t3 加读锁 t4 加写锁</strong></p><p><strong>写锁解锁</strong></p><ul><li>写锁解锁时 -1 判断是否减到 0</li><li>设置owner为null</li><li>进入唤醒流程</li><li>唤醒了等待的节点</li></ul><p><strong>如果解锁遇到了共享锁</strong></p><ul><li>先将头节点改为 0 防止别的线程唤醒</li><li>重新换新头结点的后节点</li><li>会连续的将所有的读节点都唤醒，直到遇到一个独占节点</li></ul><p><strong>读锁的解锁流程</strong></p><h4 id="5、StampedLock-戳"><a href="#5、StampedLock-戳" class="headerlink" title="5、StampedLock 戳"></a>5、StampedLock 戳</h4><p>为了进一步优化读取性能，原理就是再读取的时候会返回一个戳，使用了乐观读的方法，没有加任何的锁，真正的读取之前需要验证戳，如果验戳失败，则进入锁升级</p><h4 id="6、Semphore-信号量"><a href="#6、Semphore-信号量" class="headerlink" title="6、Semphore 信号量"></a>6、Semphore 信号量</h4><p>信号量是用来限制访问共享资源的线程上限</p><p>Reentrantlock是独占锁，Semphore限制访问共享资源的线程的上限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br>       <span class="hljs-comment">// 十个线程执行</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span> ; i++) &#123;<br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   semaphore.acquire();<br>                   System.out.println(<span class="hljs-string">&quot;running&quot;</span>);<br>                   <span class="hljs-keyword">try</span> &#123;<br>                       Thread.sleep(<span class="hljs-number">1000</span>);<br>                   &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                       e.printStackTrace();<br>                   &#125;<br>                   semaphore.release();<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace();<br>               &#125;<br><br>           &#125;).start();<br>       &#125;<br></code></pre></td></tr></table></figure><p><strong>原理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireSharedInterruptibly(arg);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>     <span class="hljs-keyword">for</span> (;;) &#123;<br>         <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>         <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>         <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>             compareAndSetState(available, remaining))<br>             <span class="hljs-keyword">return</span> remaining;<br>     &#125;<br> &#125;<br><br></code></pre></td></tr></table></figure><ul><li>加锁成功后，资源数 - 1</li><li>当state减成0了，就会进入加锁失败的流程</li></ul><p><strong>release 方法</strong>解锁</p><ul><li>拿到后就</li></ul><h4 id="7、CountdownLatch"><a href="#7、CountdownLatch" class="headerlink" title="7、CountdownLatch"></a>7、CountdownLatch</h4><p>用来进行线程同步协作等待所有线程完成倒计时</p><p>其中构造参数用来初始化等待计数值，await用来等待计数归零，countDown用来让计数 - 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;begin &quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            countDownLatch.countDown();<br><br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;begin &quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            countDownLatch.countDown();<br><br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;begin &quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            countDownLatch.countDown();<br><br>        &#125;).start();<br>        countDownLatch.await();<br>        System.out.println(<span class="hljs-string">&quot;结束了&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>为什么不适用join 而是使用coundownLatch？</p><p>因为Coundownlatch封装性更好，功能更多可以和线程池紧密的配合</p><h4 id="8、Cyclibaiier-循环栅栏"><a href="#8、Cyclibaiier-循环栅栏" class="headerlink" title="8、Cyclibaiier 循环栅栏"></a>8、Cyclibaiier 循环栅栏</h4><p>用法和CountdownLauth差不多</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>AQS 原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty学习笔记</title>
    <link href="/2022/03/05/Netty%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/03/05/Netty%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="Netty基础知识"><a href="#Netty基础知识" class="headerlink" title="Netty基础知识"></a>Netty基础知识</h3><h4 id="1、Netty是什么"><a href="#1、Netty是什么" class="headerlink" title="1、Netty是什么"></a>1、Netty是什么</h4><p>netty是一个异步的基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p><ul><li>Netty VS NIO 工作量大bug多<ul><li>需要自己构建协议</li><li>解决TCP传输问题半包等问题</li><li>epoll空轮询导致cpu100</li><li>对API进行增强使之更容易使用</li></ul></li></ul><h4 id="2、Helloworld"><a href="#2、Helloworld" class="headerlink" title="2、Helloworld"></a>2、Helloworld</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 启动器，负责组装netty的组件并启动服务器</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>                <span class="hljs-comment">// BosseventLoop,workeventloop</span><br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>                <span class="hljs-comment">// 选择服务器的Serversocketchannel实现</span><br>                .channel(NioServerSocketChannel.class)<br>                <span class="hljs-comment">// boss负责处理连接 worker负责处理读写，决定了worker能执行哪些操作 handler</span><br>                .childHandler(<br>                        <span class="hljs-comment">// 代表和客户端进行数据读写的通道Initializer的初始化</span><br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                <span class="hljs-comment">// 添加具体的handeler</span><br>                                ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>());<span class="hljs-comment">// 将bytebuf转为字符串</span><br>                                ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123; <span class="hljs-comment">// 自定义事件</span><br>                                    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 读事件</span><br>                                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                        System.out.println(msg);<br>                                    &#125;<br>                                &#125;);<br>                            &#125;<br>                        &#125;<br>                ).bind(<span class="hljs-number">8888</span>);<br></code></pre></td></tr></table></figure><p>以上是一个启动的代码</p><p>编写一个客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>               .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>               .channel(NioSocketChannel.class)<br>               .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>                   <span class="hljs-meta">@Override</span><span class="hljs-comment">// 连接建立后被调用</span><br>                   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                       ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                   &#125;<br>               &#125;).connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">8888</span>))<br>               .sync()<br>               .channel()<br>               .write(<span class="hljs-string">&quot;123&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>Hellowolrd中的一些概念</strong></p><ul><li>channle 是数据传输的通道</li><li>mag理解为流动的数据，最开始是ByteBuf，经过pipline的加工，会变成其他类的对象，最后输出成Bytebyf</li><li>handler理解为数据处理工序<ul><li>工序又多道，合在一起就是piplinepipline负责发布事件，传播给每一个handeler</li><li>handelr对自己感兴趣的事件进行处理</li><li>handeler分为inbound和outbound两类</li></ul></li><li>eventLoop理解为处理数据的工人<ul><li>工人可以管理多个channle的io操作，并且一旦工人负责了某个channle就虚则到底</li><li>工人既可以进行io操作，也可以进行任务处理，每位工人又任务队列，队列里面可以对方多个channel的待处理任务，任务分为普通任务和定时任务</li><li>工人按照pipline的书讯一次按照handler的规划处理数据，可以为每道工序指定不同的工人</li></ul></li></ul><h4 id="3、Netty的组件"><a href="#3、Netty的组件" class="headerlink" title="3、Netty的组件"></a>3、Netty的组件</h4><h5 id="3-1-EventLoop（事件循环对象）"><a href="#3-1-EventLoop（事件循环对象）" class="headerlink" title="3.1 EventLoop（事件循环对象）"></a>3.1 EventLoop（事件循环对象）</h5><p>Evetloop本质上是一个单线程的的执行器，然后自身维护了一个Selector，里面有一个RUN方法能够源源不断地处理IO的事件</p><p>他的继承关系较为复杂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">EventLoop</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OrderedEventExecutor</span>, EventLoopGroup <br></code></pre></td></tr></table></figure><ul><li>他继承了 ScheduledExecutorService</li><li>也继承了OrderedEventExecutor</li></ul><p>事件循环组</p><p><strong>EventExecutorGroup</strong></p><p>事件循环组是一组Eventloop,Channel一般回调用EventLoopGroup的register方法来绑定其中一个Eventloop，后续这个Channel上的io事件都由这个EventLoop来处理，保证了IO事件处理时的线程安全</p><ul><li>继承自netty自己的EventExecutorGroup<ul><li>实现了Iterable接口提供遍历EventLoop的能力</li><li>nex方法获取集合中下一个EventLoop</li></ul></li></ul><p><strong>创建事件循环组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">eventLoopGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br></code></pre></td></tr></table></figure><p>EventLoopGroup是一个接口，有很多的实现类，这里选择NIO默认的事件循环组</p><p>不同的事件循环组可以执行的任务的类型不同</p><ul><li>NioEventLoopGroup 定时任务、IO任务、普通任务</li></ul><p><strong>构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">NioEventLoopGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>        <span class="hljs-built_in">this</span>(nThreads, (Executor)<span class="hljs-literal">null</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>组内Eventloop的数量，几个线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">eventLoopGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">2</span>);<br>System.out.println(eventLoopGroup.next());<br>System.out.println(eventLoopGroup.next());<br>System.out.println(eventLoopGroup.next());<br>System.out.println(eventLoopGroup.next());<br></code></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby">io.netty.channel.nio.NioEventLoop<span class="hljs-variable">@527740a2</span><br>io.netty.channel.nio.NioEventLoop<span class="hljs-variable">@13a5fe33</span><br>io.netty.channel.nio.NioEventLoop<span class="hljs-variable">@527740a2</span><br>io.netty.channel.nio.NioEventLoop<span class="hljs-variable">@13a5fe3</span>3<br></code></pre></td></tr></table></figure><hr><p><strong>如何执行其他任务</strong>、</p><p>因为继承了线程池，所以可以实现一些线程池的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">eventLoopGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">2</span>);<br>eventLoopGroup.next().submit(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;123&quot;</span>);<br>&#125;);<br>System.out.println(<span class="hljs-number">1234</span>);<br></code></pre></td></tr></table></figure><p>以及可以执行一些定时任务</p><p><strong>处理IO事件（本职工作）</strong></p><p>结论：一旦建立连接后，channle就会和一个Eventlop绑定，后续的读写都会和eventloop进行绑定</p><p><strong>多个EventloopGroup</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">.group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br></code></pre></td></tr></table></figure><p>group方法又两个操作，分工一下，Bossgroup用来处理连接请求，Workergroup设置为处理请求</p><p><strong>是否可以再次细分</strong></p><p>我们如何把一些比较耗时的任务给其他的EventloopGroup去做呢</p><p>在addlist中可以指定哪一个Eventgrouploop执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">.addLast(group,<span class="hljs-string">&quot;handler2&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 会在连接建立后执行</span><br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;handler1&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                msg = (ByteBuf) msg;<br>                                <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> ((ByteBuf) msg).toString(Charset.defaultCharset());<br>                                log.debug(s);<br>                                ctx.fireChannelRead(msg);<br>                            &#125;<br>                        &#125;).addLast(group,<span class="hljs-string">&quot;handler2&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                log.debug(<span class="hljs-string">&quot;handler 2&quot;</span>);<br>                                msg = (ByteBuf) msg;<br>                                <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> ((ByteBuf) msg).toString(Charset.defaultCharset());<br>                                log.debug(s);<br>                            &#125;<br>                        &#125;);<br></code></pre></td></tr></table></figure><p>根据职责的不同，对某个handler可以独立出group继续执行</p><p><strong>Handler是如何在中途更换线程的？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeChannelRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>), next);<br>    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        next.invokeChannelRead(m);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                next.invokeChannelRead(m);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果两个handler绑定的是同一个线程，那么久直接调用，否则把要调用的代码封装为一个任务对象，由下一个handler线程来调用</p><h5 id="3-2-Channel"><a href="#3-2-Channel" class="headerlink" title="3.2 Channel"></a>3.2 Channel</h5><p>channle 的主要作用</p><ul><li>close可以用来关闭channle</li><li>closeFuture用来处理channel的关闭<ul><li>sync方法作用是等待channel关闭</li><li>addListener方法是异步等待cahnnel关闭</li></ul></li><li>pipeline方法是添加处理器</li><li>write方法是将数据写入</li><li>writeAndFlush方法将数据写入并立刻刷出</li></ul><h5 id="3-3-ChannleFuture"><a href="#3-3-ChannleFuture" class="headerlink" title="3.3 ChannleFuture"></a>3.3 ChannleFuture</h5><p>channelFuturen.sync（）</p><p>connect是一个异步非阻塞</p><p>带有Future和Promise都是和异步方法有关，都是正确处理结果的方法</p><ul><li><p>使用sync方法来同步处理结果</p><ul><li>调用sync后线程会阻塞，等待连接建立</li></ul></li><li><p>使用addListenner方法处理异步结果</p><ul><li>就是把所有的任务对给别的线程，回调</li><li>connect.addListener</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">connect.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                channelFuture.channel().writeAndFlush(<span class="hljs-string">&quot;1qaz2wsx3edc&quot;</span>);<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure></li></ul><p><strong>ChannleFuture 的关闭问题</strong></p><ul><li><p>同步模式</p><ul><li>利用closeFuture来处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> channel.closeFuture();<br>log.debug(<span class="hljs-string">&quot;等待关闭&quot;</span>);<br>channelFuture.sync();<br>channel.close();<br>log.debug(<span class="hljs-string">&quot;关闭完毕&quot;</span>);<br>  <br></code></pre></td></tr></table></figure></li><li><p>异步模式</p><ul><li>closeFuture</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> channel.closeFuture();<br>channelFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        log.debug(<span class="hljs-string">&quot;处理关闭之后的操作&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>优雅的停止eventgroup</p><ul><li>eventExecutors.shutdownGracefully();</li></ul></li></ul><h5 id="3-4-Future和Proximise"><a href="#3-4-Future和Proximise" class="headerlink" title="3.4 Future和Proximise"></a>3.4 Future和Proximise</h5><p>在异步处理的时候，经常用到这两个接口</p><p>Future与JDK中的future同名，但是是两个接口，netty的Futuren继承自jdk的Future，而Primise又对netty Future进行了拓展</p><ul><li>jdk Future只能同步等待任务结束才能得到结果</li><li>netty Futuren可以同步等待任务结束得到结果，也可以异步方式得到结果，但是都要等待任务结束</li><li>netty Promise不仅有netty Future功能，而且脱离了任务独立存在，只作为两个线程见传递结果的容器</li></ul><p><strong>Future</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>Future&lt;Integer&gt; submit = executorService.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;);<br>log.debug(<span class="hljs-string">&quot;等待结果&quot;</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> submit.get();<br>log.debug(integer.toString());<br></code></pre></td></tr></table></figure><p><strong>Future -netty</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">eventLoopGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">EventLoop</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> eventLoopGroup.next();<br>        Future&lt;Integer&gt; submit = next.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> submit.get();<br>        log.debug(integer.toString());<br></code></pre></td></tr></table></figure><p>可以使用异步获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">submit.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="hljs-built_in">super</span> Integer&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(Future&lt;? <span class="hljs-built_in">super</span> Integer&gt; future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> future.get();<br>                log.debug(object.toString());<br>            &#125;<br>        &#125;);<br>        log.debug(<span class="hljs-string">&quot;异步 我已经执行到这咯&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>promise</strong></p><p>promise 就是一个结果容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">eventLoopGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>       <span class="hljs-type">EventLoop</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> eventLoopGroup.next();<br>       Promise&lt;Integer&gt; promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPromise</span>&lt;Integer&gt;(next);<br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>               promise.setSuccess(<span class="hljs-number">80</span>);<br>           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>               promise.setFailure(e);<br>               e.printStackTrace();<br>           &#125;<br>       &#125;).start();<br>       log.debug(<span class="hljs-string">&quot;准备获取数据&quot;</span>);<br>       <span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> promise.get();<br>       log.debug(integer.toString());<br></code></pre></td></tr></table></figure><h5 id="3-5-handler-amp-pipline"><a href="#3-5-handler-amp-pipline" class="headerlink" title="3.5 handler &amp; pipline"></a>3.5 handler &amp; pipline</h5><p>ChannelHandelr用来处理Channel上的各种事件，分为入栈出栈两种，所有的channelHandler被连成一串就是pipline</p><ul><li>入站处理器通常是ChannelInboundhandlerAdapter的子类，用来读取客户端的数据，写回结果</li><li>出站处理器通常是ChannelOutboundHandlerAdapter的子类，主要对写回结果进行加工</li></ul><p><strong>PIPline中有多个handler是如何执行的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">eventExecutors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>                .group(eventExecutors)<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel channel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        channel.pipeline().addLast(<span class="hljs-string">&quot;h1&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>                                <span class="hljs-built_in">super</span>.channelRead(ctx,msg);<br>                            &#125;<br>                        &#125;);<br>                        channel.pipeline().addLast(<span class="hljs-string">&quot;h2&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                                <span class="hljs-built_in">super</span>.channelRead(ctx,msg);<br>                            &#125;<br>                        &#125;);<br>                        channel.pipeline().addLast(<span class="hljs-string">&quot;h3&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                log.debug(<span class="hljs-string">&quot;3&quot;</span>);<br>                                channel.writeAndFlush(ByteBuffer.wrap(<span class="hljs-string">&quot;hellow&quot;</span>.getBytes()));<br>                                <span class="hljs-built_in">super</span>.channelRead(ctx,msg);<br>                            &#125;<br>                        &#125;);<br>                        channel.pipeline().addLast(<span class="hljs-string">&quot;h4&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span>()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                log.debug(<span class="hljs-string">&quot;4&quot;</span>);<br>                                <span class="hljs-built_in">super</span>.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                        channel.pipeline().addLast(<span class="hljs-string">&quot;h5&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span>()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                log.debug(<span class="hljs-string">&quot;5&quot;</span>);<br>                                <span class="hljs-built_in">super</span>.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                        channel.pipeline().addLast(<span class="hljs-string">&quot;h6&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span>()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                log.debug(<span class="hljs-string">&quot;6&quot;</span>);<br>                                <span class="hljs-built_in">super</span>.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;).bind(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure><ul><li>以上代码的最终输出结果是</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">14:40:20 [DEBUG] [nioEventLoopGroup-2-2] d.N.test.test04 - 1<br>14:40:20 [DEBUG] [nioEventLoopGroup-2-2] d.N.test.test04 - 2<br>14:40:20 [DEBUG] [nioEventLoopGroup-2-2] d.N.test.test04 - 3<br>14:40:20 [DEBUG] [nioEventLoopGroup-2-2] d.N.test.test04 - 6<br>14:40:20 [DEBUG] [nioEventLoopGroup-2-2] d.N.test.test04 - 5<br>14:40:20 [DEBUG] [nioEventLoopGroup-2-2] d.N.test.test04 - 4<br></code></pre></td></tr></table></figure><p>可以看出，入栈从前往后执行，出战从后往前执行</p><p>ctx.channel.write 从最后往前找</p><p>ctx.write从当前往前找</p><h5 id="3-6-Bytebuf"><a href="#3-6-Bytebuf" class="headerlink" title="3.6 Bytebuf"></a>3.6 Bytebuf</h5><ul><li>创建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>Bytebuf是可以动态增加的</p><ul><li>调试工具</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(ByteBuf buffer)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> buffer.readableBytes();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> length / <span class="hljs-number">16</span> + (length % <span class="hljs-number">15</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>) + <span class="hljs-number">4</span>;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(rows * <span class="hljs-number">80</span> * <span class="hljs-number">2</span>)<br>        .append(<span class="hljs-string">&quot;read index:&quot;</span>).append(buffer.readerIndex())<br>        .append(<span class="hljs-string">&quot; write index:&quot;</span>).append(buffer.writerIndex())<br>        .append(<span class="hljs-string">&quot; capacity:&quot;</span>).append(buffer.capacity())<br>        .append(NEWLINE);<br>    appendPrettyHexDump(buf, buffer);<br>    System.out.println(buf.toString());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer();<br>        log(buffer);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3000</span> ; i++) &#123;<br>            stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;<br>        buffer.writeBytes(stringBuilder.toString().getBytes());<br>        log(buffer);<br></code></pre></td></tr></table></figure><ul><li>直接内存、堆内存<ul><li>直接内存是放到系统的内存当中的，创建和销毁的代价高但是读写快速</li><li>Netty默认创建的是直接内存</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.directBuffer();<br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf1</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.heapBuffer();<br></code></pre></td></tr></table></figure><ul><li>池化、非池化</li></ul><p>对于创建耗时的对象预先池化，netty中默认开启了池化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;<br></code></pre></td></tr></table></figure><ul><li>Bytebuf的组成<ul><li>capacity 容量</li><li>max capacity 最大容量</li><li>readIndex 读指针</li><li>writeIndex 写指针</li><li>四个部分<ul><li>废弃部分</li><li>可读部分</li><li>可写部分</li><li>可扩容部分</li></ul></li></ul></li><li>bytebuf的优点<ul><li>动态扩容</li><li>两个指针</li></ul></li><li>API</li></ul><p>方法列表，省略一些不重要的方法</p><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td>用一字节 01|00 代表 true|false</td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian，即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian，即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 ByteBuffer</td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td></td></tr></tbody></table><blockquote><p>注意</p><ul><li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用</li><li>网络传输，默认习惯是 Big Endian</li></ul></blockquote><ul><li>读取方法</li></ul><h5 id="3-7-Bytebuf-内存回收"><a href="#3-7-Bytebuf-内存回收" class="headerlink" title="3.7 Bytebuf 内存回收"></a>3.7 Bytebuf 内存回收</h5><ul><li>heapBytebuffer使用的是JVM的内存，只需要等待GC进行垃圾回收即可</li><li>DirectBytebuf使用的是直接内存，需要特殊的方法来回收内存</li><li>PooldBytebuffer和他的子类使用了池化机制，需要更复杂的规则来进行垃圾会搜</li></ul><p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。</p><ul><li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li><li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li><li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><blockquote><p>回收内存的源码实现，请关注下面方法的不同实现</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span>()</span><br></code></pre></td></tr></table></figure></blockquote><p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p><ul><li>每个 ByteBuf 对象的初始计数为 1</li><li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li><li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li><li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li></ul><p>谁来负责 release 呢？</p><p>不是我们想象的（一般情况下）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ...<br><span class="hljs-keyword">try</span> &#123;<br>    ...<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    buf.release();<br>&#125;<br></code></pre></td></tr></table></figure><p>请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p><p>基本规则是，<strong>谁是最后使用者，谁负责 release</strong>，详细分析如下</p><ul><li>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</li><li>入站 ByteBuf 处理原则<ul><li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li><li>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</li><li>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</li><li>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</li><li>假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li></ul></li><li>出站 ByteBuf 处理原则<ul><li>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</li></ul></li><li>异常处理原则<ul><li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li></ul></li></ul><h5 id="3-8-一些API"><a href="#3-8-一些API" class="headerlink" title="3.8 一些API"></a>3.8 一些API</h5><ul><li><strong>slice方法</strong></li></ul><p>零拷贝的体现之一，对原始的Bytebuf进行切片成多个Bytebuf，切片后的Bytebuf并没有发生内存复制，还是是永远是的Bytebuf内存，切片后的Bytebuf维护独立的read write指针</p><p>切片后会对容量进行限制</p><p>如果对原有的切片进行了release进行释放，那么就会影响到切片后的</p><p>duplicate</p><p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p><ul><li><strong>copy</strong></li></ul><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</p><ul><li><strong>CompositeByteBuf</strong></li></ul><p>【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝</p><p>有两个 ByteBuf 如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf1</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">5</span>);<br>buf1.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf2</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">5</span>);<br>buf2.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;);<br>System.out.println(ByteBufUtil.prettyHexDump(buf1));<br>System.out.println(ByteBufUtil.prettyHexDump(buf2));<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？</p><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf3</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT<br>    .buffer(buf1.readableBytes()+buf2.readableBytes());<br>buf3.writeBytes(buf1);<br>buf3.writeBytes(buf2);<br>System.out.println(ByteBufUtil.prettyHexDump(buf3));<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>这种方法好不好？回答是不太好，因为进行了数据的内存复制操作</p><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CompositeByteBuf</span> <span class="hljs-variable">buf3</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();<br><span class="hljs-comment">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span><br>buf3.addComponents(<span class="hljs-literal">true</span>, buf1, buf2);<br></code></pre></td></tr></table></figure><p>结果是一样的</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</p><ul><li>优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li><li>缺点，复杂了很多，多次操作会带来性能的损耗</li></ul><ul><li>Unpooled</li></ul><p>Unpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作</p><p>这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf1</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">5</span>);<br>buf1.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf2</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">5</span>);<br>buf2.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;);<br><br><span class="hljs-comment">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf</span><br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf3</span> <span class="hljs-operator">=</span> Unpooled.wrappedBuffer(buf1, buf2);<br>System.out.println(ByteBufUtil.prettyHexDump(buf3));<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>也可以用来包装普通字节数组，底层也不会有拷贝操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf4</span> <span class="hljs-operator">=</span> Unpooled.wrappedBuffer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;);<br>System.out.println(buf4.getClass());<br>System.out.println(ByteBufUtil.prettyHexDump(buf4));<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">class io.netty.buffer.CompositeByteBuf<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 05 06                               |......          |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h5 id="3-9-ByteBuf优点"><a href="#3-9-ByteBuf优点" class="headerlink" title="3.9 ByteBuf优点"></a>3.9 ByteBuf优点</h5><ul><li>池化，可以重用池中的Bytebuf实例，节约内存，减少内存溢出可能</li><li>读写指针分离，不需要切换模式</li><li>可以自动扩容</li><li>支持链式调用</li><li>体现零拷</li></ul><h3 id="Netty进阶知识"><a href="#Netty进阶知识" class="headerlink" title="Netty进阶知识"></a>Netty进阶知识</h3><h4 id="1、Netty的粘包和半包"><a href="#1、Netty的粘包和半包" class="headerlink" title="1、Netty的粘包和半包"></a>1、Netty的粘包和半包</h4><ul><li>TCP以一个段segment为单位，每发送一个段就需要进行一次确认应答ack处理，但是如果这么做，缺点就是包的往返时间越长，性能就越差</li><li>为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值</li><li>窗口实际上就i起到了一个缓冲区的作用，同时也能起到流量控制的作用</li></ul><p><strong>粘包现象</strong></p><p>发送abc def 接收 abcdef</p><ul><li>原因<ul><li>应用层：接收方ByteBuf设置过大，netty默认1024</li><li>滑动窗口：假设发送方256bytes表示一个完整保温，但是由于接收方处理不及时且窗口大小足够大，这256字节就会缓冲在接收方的滑动窗口中，当缓冲区缓冲了多个报文就会导致粘包</li><li>Nagle算法：会造成粘包</li></ul></li></ul><p><strong>半包现象</strong></p><p>发送abcdef 接收 abc def</p><ul><li>原因<ul><li>应用层：接收方ByteBuf小于实际发送的数据量</li><li>滑动窗口：加入接收方窗口之剩下128 发送方的报文大小是256bytes，这时候放不下了，只能先发送前128bytes，等待ack后才能发送剩余部分，这就造成了半包</li><li>MSS限制：当发送的数据超过MSS先之后，会将数据切分发送，就会造成半包</li></ul></li></ul><p>本质是TCP的消息是无边界的</p><p><strong>如何解决粘包和半包</strong></p><p>1、短链接方式</p><ul><li>短链接方式，让每一次建立连接后就断开连接，不给机会</li></ul><p>短链接方式并不能解决半包问题，只能解决粘包问题</p><p><strong>如何复现半包</strong></p><p>服务端设置还手缓冲区大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置缓冲区大小，最小值，初始值，最大值</span><br>serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR,<span class="hljs-keyword">new</span> <span class="hljs-title class_">AdaptiveRecvByteBufAllocator</span>(<span class="hljs-number">16</span>,<span class="hljs-number">16</span>,<span class="hljs-number">16</span>));<br></code></pre></td></tr></table></figure><p><strong>解决方式</strong></p><ul><li>定长解码器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FixedLengthFrameDecoder</span>(<span class="hljs-number">10</span>));<br><br></code></pre></td></tr></table></figure><p>定长解码器会对消息长度进去处理，遇到定长的消息才截取</p><ul><li>分隔符界定消息边界</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">LineBasedFrameDecoder</span>(<span class="hljs-number">1024</span>)<br></code></pre></td></tr></table></figure><p>默认的换行符解码器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">DelimiterBasedFrameDecoder</span>(<span class="hljs-number">1024</span>, ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="hljs-string">&quot;&amp;&amp;&quot;</span>.getBytes()))<br></code></pre></td></tr></table></figure><p>自定义的符号</p><p>缺点：效率低</p><ul><li>基于长度字段的帧解码器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">lengthFieldOffset   = <span class="hljs-number">0</span> <span class="hljs-comment">// 长度字段偏移量</span><br>lengthFieldLength   = <span class="hljs-number">2</span> <span class="hljs-comment">// 长度字段长度</span><br>lengthAdjustment    = <span class="hljs-number">0</span> <span class="hljs-comment">// 长度字段基准。还有几个字节是内容</span><br>initialBytesToStrip = <span class="hljs-number">0</span> (= <span class="hljs-keyword">do</span> not strip header)<span class="hljs-comment">// 从头剥离几个字节</span><br>  <br>BEFORE <span class="hljs-title function_">DECODE</span> <span class="hljs-params">(<span class="hljs-number">14</span> bytes)</span>         AFTER <span class="hljs-title function_">DECODE</span> <span class="hljs-params">(<span class="hljs-number">14</span> bytes)</span><br>+--------+----------------+      +--------+----------------+<br>| Length | Actual Content |-----&gt;| Length | Actual Content |<br>| <span class="hljs-number">0x000C</span> | <span class="hljs-string">&quot;HELLO, WORLD&quot;</span> |      | <span class="hljs-number">0x000C</span> | <span class="hljs-string">&quot;HELLO, WORLD&quot;</span> |<br>+--------+----------------+      +--------+----------------+<br></code></pre></td></tr></table></figure><ul><li><p>说明</p><ul><li><p>lengthFieldOffset ：整个消息14个字节，长度是第几个字节</p></li><li><p>lengthFieldLength：长度占几个字节？</p></li><li><p>initialBytesToStrip：如果最后不想要长度这些数据了，那么就可以把长度剥离出去 </p></li><li><p>lengthAdjustment：从长度开始算，还有几个字节是内容</p></li></ul></li></ul><h4 id="2、协议的设计与解析"><a href="#2、协议的设计与解析" class="headerlink" title="2、协议的设计与解析"></a>2、协议的设计与解析</h4><h5 id="1、Redis"><a href="#1、Redis" class="headerlink" title="1、Redis"></a>1、Redis</h5><p>redis的协议，设置一个key</p><p>set name tangcheng</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">client</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] LINE = &#123;<span class="hljs-number">13</span>,<span class="hljs-number">10</span>&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">eventExecutors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>        bootstrap.group(eventExecutors);<br>        bootstrap.channel(NioSocketChannel.class);<br>        bootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel channel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                channel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br>                channel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer();<br>                        buffer.writeBytes(<span class="hljs-string">&quot;*3&quot;</span>.getBytes());<br>                        buffer.writeBytes(LINE);<br>                        buffer.writeBytes(<span class="hljs-string">&quot;$3&quot;</span>.getBytes());<br>                        buffer.writeBytes(LINE);<br>                        buffer.writeBytes(<span class="hljs-string">&quot;set&quot;</span>.getBytes());<br>                        buffer.writeBytes(LINE);<br>                        buffer.writeBytes(<span class="hljs-string">&quot;$4&quot;</span>.getBytes());<br>                        buffer.writeBytes(LINE);<br>                        buffer.writeBytes(<span class="hljs-string">&quot;name&quot;</span>.getBytes());<br>                        buffer.writeBytes(LINE);<br>                        buffer.writeBytes(<span class="hljs-string">&quot;$9&quot;</span>.getBytes());<br>                        buffer.writeBytes(LINE);<br>                        buffer.writeBytes(<span class="hljs-string">&quot;tangcheng&quot;</span>.getBytes());<br>                        buffer.writeBytes(LINE);<br>                        ctx.writeAndFlush(buffer);<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                       <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>                        System.out.println(byteBuf.toString());<br>                    &#125;<br><br><br>                &#125;);<br><br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;120.48.10.164&quot;</span>, <span class="hljs-number">6379</span>));<br>        connect.sync();<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h5 id="2、Http"><a href="#2、Http" class="headerlink" title="2、Http"></a>2、Http</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">BossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">WorkGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>        serverBootstrap.group(BossGroup,WorkGroup);<br>        <span class="hljs-comment">//serverBootstrap.option(ChannelOption.SO_RCVBUF,10);</span><br>        <span class="hljs-comment">// 设置缓冲区大小，最小值，初始值，最大值</span><br>        serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR,<span class="hljs-keyword">new</span> <span class="hljs-title class_">AdaptiveRecvByteBufAllocator</span>(<span class="hljs-number">16</span>,<span class="hljs-number">16</span>,<span class="hljs-number">16</span>));<br>        serverBootstrap.channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel channel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                       channel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br>                       channel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerCodec</span>());<br>                       channel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;() &#123;<br>                           <span class="hljs-meta">@Override</span><br>                           <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, HttpRequest httpRequest)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                               <span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> httpRequest.uri();<br>                               System.out.println(<span class="hljs-string">&quot;请求地址&quot;</span> + uri);<br>                               <span class="hljs-type">DefaultFullHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultFullHttpResponse</span>(httpRequest.protocolVersion(), HttpResponseStatus.OK);<br>                               <span class="hljs-type">byte</span>[] bytes = <span class="hljs-string">&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;</span>.getBytes();<br>                               response.headers().setInt(CONTENT_LENGTH,bytes.length);<br>                               response.content().writeBytes(bytes);<br>                               channelHandlerContext.writeAndFlush(response);<br>                           &#125;<br>                       &#125;);<br>                    &#125;<br>                &#125;);<br>        serverBootstrap.bind(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure><p>其中要注意的是，我们只需要处理header请求，</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">channel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;()<br></code></pre></td></tr></table></figure><p>netty给我们提供了一些协议</p><h5 id="3、自定义协议的要素"><a href="#3、自定义协议的要素" class="headerlink" title="3、自定义协议的要素"></a>3、自定义协议的要素</h5><ul><li>魔数：用来在第一时间判定是否是无效数据包</li><li>版本号：可以支持协议的升级</li><li>序列化算法：消息正文到底采用哪种序列化和反序列化的方式，可以由此拓展json，protobuf，hessian，jdk</li><li>指令类型：登录、注册、单聊、群聊。。和业务相关</li><li>请求需要：为了双工通信，提供异步能力</li><li>正文长度</li><li>消息正文：json、xml、对象流等等</li></ul><h5 id="4、handler是否可以被共享"><a href="#4、handler是否可以被共享" class="headerlink" title="4、handler是否可以被共享"></a>4、handler是否可以被共享</h5><ul><li>加了Sharable注解的可以被共享</li><li>如果我们确定我们自定义的编解码器线程安全的，我们就可以继承别的父类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">MessageToMessageCodec<br></code></pre></td></tr></table></figure><h3 id="Netty实战"><a href="#Netty实战" class="headerlink" title="Netty实战"></a>Netty实战</h3><h5 id="1、连接假死"><a href="#1、连接假死" class="headerlink" title="1、连接假死"></a>1、连接假死</h5><p>原因</p><ul><li>网络设备出现故障，例如网卡，机房，或者底层的tcp连接已经断开了，但是应用程序没有感知到，任然占用着资源</li><li>公用网络不稳定。出现丢包，如果连续出现丢包，这个时候现象就是客户端数据发送不出去，服务端也一直收不到数据，就这么一直耗着</li><li>应用程序线程阻塞，无法进行数据读写</li></ul><p>问题</p><ul><li>假死的连接占用的资源不能自动释放</li><li>向假死的连接发送数据，得到的反馈是发送超时</li></ul><h5 id="2、检测连接假死"><a href="#2、检测连接假死" class="headerlink" title="2、检测连接假死"></a>2、检测连接假死</h5><ul><li>IdleStateHandler<ul><li>参数1：读空闲时间</li><li>参数2：写空闲时间</li><li>参数3：读写都空闲</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateHandler</span>(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><ul><li>ChannelDuplexHandler</li></ul><p>既可以处理入栈操作，也可以进行出站操作</p><p><strong>当超过我们设置的时间的时候，会触发一个事件，这个事件是一个自定义事件，需要我们自己手动的去处理这些事件,分别是</strong></p><ul><li>IdleState.READER_IDLE</li><li>IdleState.WRITER_IDLE</li><li>IdleState.ALL_IDLE</li></ul><p><strong>这三个事件，那么我们要编写代码自己去处理这三个事件</strong></p><h5 id="3、处理自定义事件-userEventTriggered"><a href="#3、处理自定义事件-userEventTriggered" class="headerlink" title="3、处理自定义事件 userEventTriggered"></a>3、处理自定义事件 userEventTriggered</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelDuplexHandler</span>()&#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-built_in">super</span>.userEventTriggered(ctx, evt);<br>                        &#125;<br>                    &#125;);<br></code></pre></td></tr></table></figure><p>通过事件消息类型来判断时间的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelDuplexHandler</span>()&#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">idleStateEvent</span> <span class="hljs-operator">=</span> (IdleStateEvent) evt;<br>                            <span class="hljs-keyword">if</span> (idleStateEvent.state() == IdleState.READER_IDLE)&#123;<br>                                System.out.println(<span class="hljs-string">&quot;发生了读空闲事件&quot;</span>);<br>                            &#125;<br>                        &#125;<br>                    &#125;);<br></code></pre></td></tr></table></figure><h5 id="4、心跳机制"><a href="#4、心跳机制" class="headerlink" title="4、心跳机制"></a>4、心跳机制</h5><p>如果检测出来了事件，那我们应该怎么办？</p><p>所以正常的流程是</p><ul><li>客户端监测写空闲事件<ul><li>每隔三秒向服务端发送一个心跳包</li></ul></li><li>服务端监测读空闲事件</li></ul><h4 id="优化和源码"><a href="#优化和源码" class="headerlink" title="优化和源码"></a>优化和源码</h4><h5 id="1、扩展序列化算法"><a href="#1、扩展序列化算法" class="headerlink" title="1、扩展序列化算法"></a>1、扩展序列化算法</h5><p>序列化、反序列化主要使用在消息正文的转换上</p><ul><li>序列化时，需要将java对象变为要传输的数据</li><li>反序列化时需要将传入的正文数据还原成java对象便于处理</li></ul><p>JDK自带的序列化、反序列化工具</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span><br></code></pre></td></tr></table></figure><h5 id="2、连接超时"><a href="#2、连接超时" class="headerlink" title="2、连接超时"></a>2、连接超时</h5><ul><li>设置超时异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ChannelOption.CONNECT_TIME_MILLTS<br></code></pre></td></tr></table></figure><h5 id="3、调优参数"><a href="#3、调优参数" class="headerlink" title="3、调优参数"></a>3、调优参数</h5><ul><li>CONNECT_TIMEOUT_MILLLS<ul><li>属于SocketChannel参数</li><li>用在客户端建立连接时侯，如果指定毫秒内无法连接，会抛出timeout异常</li><li>SO_TIMEOUT主要用在阻塞IO ，阻塞IO中的accept、read等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间</li></ul></li><li>SO_BACKLOG<ul><li>TCP中有一个半边连接队列和全连接队列</li><li>设置的是全连接队列的大小</li><li>如何查找backlog默认值</li></ul></li><li>ulimit -m</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>网络编程</tag>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql</title>
    <link href="/2022/02/18/Mysql/"/>
    <url>/2022/02/18/Mysql/</url>
    
    <content type="html"><![CDATA[<h2 id="Mysql-高级"><a href="#Mysql-高级" class="headerlink" title="Mysql 高级"></a>Mysql 高级</h2><h3 id="1、存储引擎"><a href="#1、存储引擎" class="headerlink" title="1、存储引擎"></a>1、存储引擎</h3><p>查看命令</p><p>show engines</p><p><strong>InnoDB 和 MyISAM</strong></p><table><thead><tr><th>对比</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>主外键</td><td>不支持</td><td>支持</td></tr><tr><td>事物</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁</td><td>行锁</td></tr><tr><td>缓存</td><td>只缓存索引不缓存真实数据</td><td></td></tr><tr><td>表空间</td><td>小</td><td>大</td></tr><tr><td>关注点</td><td>性能</td><td>事物</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr></tbody></table><h3 id="2、索引优化分析"><a href="#2、索引优化分析" class="headerlink" title="2、索引优化分析"></a>2、索引优化分析</h3><h4 id="2-1-七种JOIN理论"><a href="#2-1-七种JOIN理论" class="headerlink" title="2.1 七种JOIN理论"></a>2.1 七种JOIN理论</h4><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%86%85%E8%BF%9E%E6%8E%A5.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span>  tableA <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> tableB <span class="hljs-keyword">on</span> a.key <span class="hljs-operator">=</span> b.key<br></code></pre></td></tr></table></figure><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%B7%A6%E8%BF%9E%E6%8E%A5.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tableA <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <span class="hljs-keyword">table</span> b <span class="hljs-keyword">on</span> a.key <span class="hljs-operator">=</span> b.key<br></code></pre></td></tr></table></figure><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%85%B6%E4%BB%96.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tableA A <span class="hljs-keyword">Left</span> <span class="hljs-keyword">join</span> TableB B <span class="hljs-keyword">ON</span> A.key <span class="hljs-operator">=</span> B.key <span class="hljs-keyword">where</span> B.key <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%85%A8%E8%BF%9E%E6%8E%A5.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> TableA A <span class="hljs-keyword">full</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> TableB B <span class="hljs-keyword">ON</span> a.key <span class="hljs-operator">=</span> b.key<br></code></pre></td></tr></table></figure><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/notin.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> TableA A <span class="hljs-keyword">full</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <span class="hljs-keyword">Table</span> B <span class="hljs-keyword">On</span> a.key <span class="hljs-operator">=</span> b.key <span class="hljs-keyword">where</span> a.key <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">or</span> b.key <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h4 id="2-2-练习"><a href="#2-2-练习" class="headerlink" title="2.2 练习"></a>2.2 练习</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tbl_emp` (<br>`id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`name` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`deptId` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (`id`) ,<br>KEY `fk_dept_id`(`deptId`)<br>)ENGINE <span class="hljs-operator">=</span> InnoDB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">=</span> utf8;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tbl_dept` (<br>`id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`deptName` <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`locAdd` <span class="hljs-type">varchar</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">=</span> utf8;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tbl_dept(deptName,locAdd) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;RD&#x27;</span>,<span class="hljs-number">11</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tbl_dept(deptName,locAdd) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;HR&#x27;</span>,<span class="hljs-number">12</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tbl_dept(deptName,locAdd) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;MK&#x27;</span>,<span class="hljs-number">13</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tbl_dept(deptName,locAdd) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;MIS&#x27;</span>,<span class="hljs-number">14</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tbl_dept(deptName,locAdd) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;FD&#x27;</span>,<span class="hljs-number">15</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tbl_emp(NAME,deptId) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;z3&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tbl_emp(NAME,deptId) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;z4&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tbl_emp(NAME,deptId) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;z5&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tbl_emp(NAME,deptId) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;w5&#x27;</span>,<span class="hljs-number">2</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tbl_emp(NAME,deptId) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;w6&#x27;</span>,<span class="hljs-number">2</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tbl_emp(NAME,deptId) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;s7&#x27;</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tbl_emp(NAME,deptId) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;s8&#x27;</span>,<span class="hljs-number">4</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tbl_emp(NAME,deptId) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;s9&#x27;</span>,<span class="hljs-number">51</span>);<br></code></pre></td></tr></table></figure><p><strong>公有部分</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tbl_emp a <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> tbl_dept b <span class="hljs-keyword">on</span> a.deptId <span class="hljs-operator">=</span> b.id<br></code></pre></td></tr></table></figure><p><strong>全A</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tbl_emp a <span class="hljs-keyword">left</span> <span class="hljs-keyword">JOIN</span> tbl_dept b <span class="hljs-keyword">on</span> a.deptId <span class="hljs-operator">=</span> b.id<br></code></pre></td></tr></table></figure><p><strong>全B</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tbl_emp a <span class="hljs-keyword">right</span> <span class="hljs-keyword">JOIN</span> tbl_dept b <span class="hljs-keyword">on</span> a.deptId <span class="hljs-operator">=</span> b.id<br></code></pre></td></tr></table></figure><p><strong>A的独有</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tbl_emp a <span class="hljs-keyword">left</span> <span class="hljs-keyword">JOIN</span> tbl_dept b <span class="hljs-keyword">on</span> a.deptId <span class="hljs-operator">=</span> b.id <span class="hljs-keyword">where</span> b.id <span class="hljs-operator">=</span> <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p><strong>AB全连接</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tbl_emp a <span class="hljs-keyword">left</span> <span class="hljs-keyword">JOIN</span> tbl_dept b <span class="hljs-keyword">on</span> a.deptId <span class="hljs-operator">=</span> b.id <br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tbl_emp a <span class="hljs-keyword">right</span> <span class="hljs-keyword">JOIN</span> tbl_dept b <span class="hljs-keyword">on</span> a.deptId <span class="hljs-operator">=</span> b.id <br></code></pre></td></tr></table></figure><h4 id="2-3-索引简介"><a href="#2-3-索引简介" class="headerlink" title="2.3 索引简介"></a>2.3 索引简介</h4><p>索引是帮助mysql高效获取数据的数据结构</p><p>索引就是排好序的快速查找数据结构</p><p>索引用于排序和快速查找</p><p>在数据之外，数据库系统还维护满足了特定查找算法的数据结构，这些数据结构以某种方式指向数据</p><p><strong>索引的优势</strong></p><p>提高了数据检索的效率，降低数据库的IO成本</p><p>通过索引堆数据进行排序，降低数据排序的成本降低了CPU的消耗</p><p><strong>索引的劣势</strong></p><p>实际索引也是一张表，所以索引列也是要占用空间的</p><p>虽然䫅大大提高了查询速度，但是会降低更新表的速度，如对表进行插入更新删除，因为更新表时，mysql不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段</p><p>索引只是提高效率的因素，如果mysql有大数据量的表，就需要花时间研究建立优秀的索引</p><h4 id="2-4-索引分类和创建"><a href="#2-4-索引分类和创建" class="headerlink" title="2.4 索引分类和创建"></a>2.4 索引分类和创建</h4><p><strong>索引的分类</strong></p><p>单值索引：一个索引只包含单个列</p><p>唯一索引：索引列的值必须唯一，单允许有空值</p><p>复合索引：一个索引包含多个列</p><p><strong>基本语法</strong></p><p><strong>创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index indexname <span class="hljs-keyword">on</span> mybatie(colum(len))<br></code></pre></td></tr></table></figure><p><strong>删除</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> inde <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span><br></code></pre></td></tr></table></figure><p><strong>查看</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span><br></code></pre></td></tr></table></figure><h4 id="2-5-索引创建的规则"><a href="#2-5-索引创建的规则" class="headerlink" title="2.5 索引创建的规则"></a>2.5 索引创建的规则</h4><p><strong>哪些情况需要建索引</strong></p><ul><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>频繁更新的字段不适合创建索引</li><li>where条件里用不到的字段不创建索引</li><li>单键&#x2F;组合索引选who </li><li>查询中排序的字段需要创建索引</li><li>查询中统计或者分组字段</li></ul><p>哪些情况不需要索引</p><ul><li>表记录太少</li><li>经常增删改的表</li><li>数据重复且分布平均的表不需要建立</li></ul><h4 id="2-6-SQL性能分析"><a href="#2-6-SQL性能分析" class="headerlink" title="2.6 SQL性能分析"></a>2.6 SQL性能分析</h4><p>Mysql Query Optimizer mysql查询优化器</p><p>mysql中有专门负责优化的select模块，通过分析系统中的统计信息，为客户端请求的query提供他认为最优的执行计划</p><p>Explain 可以模拟优化器执行SQL语句，从而直到Mysql是如何处理SQL语句的</p><p><strong>Explain + SQL</strong></p><p>执行计划包含的信息</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/explain.png" alt="UD"></p><p>字段解释</p><p><strong>ID</strong></p><ul><li>ID select查询的序列号，表示查询中执行select子句活操作表的顺序</li><li>三种情况<ul><li>id相同：执行顺序由上到下</li><li>id不同：如果是子查询，ID的序号会递增，id值越大的越先被执行</li><li>id如果相同可以认为是一组，从上往下顺序执行</li></ul></li></ul><p>作用：看表的读取顺序</p><p><strong>select type</strong></p><ul><li>查询的类型，主要用来区别普通查询，联合查询，子查询和复合查询<ul><li>SIMPLE 简单的select查询，插叙不包含子查询和union</li><li>primary 查询中若包含任何复杂的子查询，最外层标记为PRIMARY</li><li>SUBQUERY 包含了子查询</li><li>DERIVED 在from列表中包含的子查询被标记为DERIVED mysql会递归执行这些子查询，把结果放到临时表中</li><li>UNION </li><li>UNION result 两种UNIO结果的合并</li></ul></li></ul><p>作用：数据读取操作的操作类型</p><p><strong>table</strong></p><p>作用：数据是哪张表</p><p><strong>type</strong></p><p>访问类型排列</p><p>从最好到最差依次是</p><p>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p><p>一般来说，得保证查询至少到range级别，最好能达到ref</p><ul><li><p>system 表只有一行记录，等于系统表</p></li><li><p>const 表示通过索引一次就找到了，const用于比较primary key或者unique索引，因为只匹配了一行数据，所以很快，如将主键置与where列表中，mysql就能将该查询转换为一个常量</p></li><li><p>eq_ref 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或者唯一索引扫描</p></li><li><p>ref 非唯一性索引扫描，返回匹配某个单独值的所有行，但是可能会找到多个行，属于查找和扫描的混合体</p></li><li><p>range 只检索给定范围的行，使用一个索引来选择行，key列显示使用了哪个索引，一般就是在where语句中出现了betwnne where等的查询</p></li><li><p>index：只便利了索引树，全索引扫描</p></li><li><p>ALL：全表扫描</p></li></ul><p><strong>possible_keys key</strong></p><p>显示可能应用在这张表的索引，一个或多个，若存在索引，索引会被列出，单不一定会被实际使用</p><p>key  最后实际用到的索引</p><p><strong>key_len</strong></p><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引长度，在不损失精度的情况下，长度越短越好</p><p>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</p><p><strong>ref</strong></p><p>显示所有的哪一列被使用了，如果可能的话是一个常数，那些列或常量被用于查找索引列上的值</p><p><strong>rows</strong></p><p>根据表统计信息，大致估算出读取到记录需要读取到的行数</p><p><strong>Extra</strong></p><p>十分重要的信息</p><ul><li>usering filesort : mysql会对数据使用一个外部的索引排序，而不是按照表内的u偶姻顺序进去读取，Mysql中无法利用索引完成的拍戏操作称为文件排序</li><li>usering temporary：新建了临时表保存中间结果，常见于order by 和 group by</li><li>using index：表示了响应的select操作中使用了覆盖索引，避免了访问表的数据行，效率不错，如果同时出现了using where，表明索引被用来执行索引键值的查找<ul><li>覆盖索引，就是select的数据列只需要从索引当中就可以取得，不必读取数据行，mysql可以利用索引返回select列表中的字段，换句话说就是查询列要被所建的索引覆盖</li></ul></li><li>useing where joinbuffer </li><li>impossible where where子句的值是false</li><li>select tables optimized away 在没有Group by子句的情况下，基于索引优化min&#x2F;max操作或者对于Myisam存储引擎优化count操作</li><li>distinct 找到第一个匹配后就结束</li></ul><h3 id="3、索引优化实战"><a href="#3、索引优化实战" class="headerlink" title="3、索引优化实战"></a>3、索引优化实战</h3><h4 id="3-1-单表"><a href="#3-1-单表" class="headerlink" title="3.1 单表"></a>3.1 单表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `article`(<br>`id` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>`author_id` <span class="hljs-type">INT</span> (<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`category_id` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> , <br>`views` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> , <br>`comments` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`title` <span class="hljs-type">VARBINARY</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`content` TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `article`(author_id,category_id,views,comments,title,content) <span class="hljs-keyword">values</span><br>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>),<br>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>),<br>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>查询category_id 为1 且 comments 大于 1的情况下view最多的article_id</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> `article` <span class="hljs-keyword">AS</span> a <span class="hljs-keyword">where</span> a.comments <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> a.views <span class="hljs-keyword">desc</span> limit <span class="hljs-number">1</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> `article` <span class="hljs-keyword">AS</span> a <span class="hljs-keyword">where</span> a.comments <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> a.views <span class="hljs-keyword">desc</span> limit <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/sql%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C.png"></p><p>select Type 简单查询</p><p>table a表</p><p>type 访问类型 全表扫描</p><p>可能用到的索引 无</p><p>实际用到的索引 无</p><p>索引字节数 无</p><p>扫描了多少行 3行</p><p>产生了外部排序</p><p><strong>结论Type 是ALL 必须做优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> index idx_ccv <span class="hljs-keyword">on</span> article(category_id,comments,views)<br></code></pre></td></tr></table></figure><h4 id="3-2-两表"><a href="#3-2-两表" class="headerlink" title="3.2 两表"></a>3.2 两表</h4><p>连接操作，左表一定一定有全表扫描，所以关联字段的右表加索引</p><h4 id="3-3-三表"><a href="#3-3-三表" class="headerlink" title="3.3 三表"></a>3.3 三表</h4><p>加在每一个连接的右表中</p><p>小表驱动大表</p><h4 id="3-4-如何避免索引失效"><a href="#3-4-如何避免索引失效" class="headerlink" title="3.4 如何避免索引失效"></a>3.4 如何避免索引失效</h4><ul><li>全职匹配我最爱</li><li>最佳左前缀法则<ul><li>如果索引了多列，要遵守最佳左前缀法则，不跳过索引中的列</li></ul></li><li>不在索引上左任何操作 计算函数类型转换</li><li>存储引擎不能使用范围右边的列</li><li>尽量使用覆盖索引，减少select *</li><li>使用！&#x3D; 或者&lt;&gt;的时候会导致全表扫描</li><li>is null is not null 也不会使用索引</li><li>like以%开头会让索引失效造成全表扫描<ul><li>可以使用覆盖索引来解决全表扫描的问题</li></ul></li><li>字符串不加单引号索引失效</li><li>or 连接时索引会失效</li></ul><h3 id="4、-查询截取优化"><a href="#4、-查询截取优化" class="headerlink" title="4、 查询截取优化"></a>4、 查询截取优化</h3><p>1、观察，查看慢sql情况</p><p>2、开启慢查询日志，设置阈值，超过5s就是慢sql并将他抓取出来</p><p>3、explain+慢sql分析</p><p>4、show profile</p><h4 id="4-1-永远小表驱动大表"><a href="#4-1-永远小表驱动大表" class="headerlink" title="4.1 永远小表驱动大表"></a>4.1 永远小表驱动大表</h4><p>小的数据集驱动大的数据集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> b)<br>当b表的数据远远小于A表时，推荐使用<span class="hljs-keyword">in</span><br>当A表的数据小于b表时推荐使用<span class="hljs-keyword">exists</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> b.id <span class="hljs-operator">=</span> a.id)<br>## 将著查询的数据放到子查询中左条件验证，根据验证结果决定是否返回<br><br></code></pre></td></tr></table></figure><h4 id="4-2-Order-By-排序优化"><a href="#4-2-Order-By-排序优化" class="headerlink" title="4.2 Order By 排序优化"></a>4.2 Order By 排序优化</h4><p>Order by 子句尽量使用Index方式排序，避免使用FileSert方式排序</p><p>最左前缀法则</p><p>如果不在索引列上，就使用单路排序，和双路排序</p><ul><li>双路排序<ul><li>双路排序就是进行两次IO操作，首先根据字段排序然后再取出其他字段</li></ul></li><li>单路排序<ul><li>再buffer中进行排序，然后扫描排序后进行列表输出，会使用更多空间</li><li>单路使用存在的问题<ul><li>如果读取的数据太多占用了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据进行排序</li></ul></li></ul></li></ul><p>mysql 可以为排序与查询使用相同的索引</p><h4 id="4-3-Group-by-优化"><a href="#4-3-Group-by-优化" class="headerlink" title="4.3 Group by 优化"></a>4.3 Group by 优化</h4><p>group by的实质是先排序后进行分组，按照索引建的最佳左前缀法则</p><p>当无法使用索引列，增大max_length_for_sort_data参数的设置，增大sort_buffer_size参数的设置</p><p>where 高于 having 能卸载</p><h3 id="5、慢查询日志"><a href="#5、慢查询日志" class="headerlink" title="5、慢查询日志"></a>5、慢查询日志</h3><p>Mysql 的慢查询日志是Mysql提供的一种日志记录，它用来记录再Mysql中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的sql则会被记录到慢查询日志中</p><p>默认mysql 没有开启慢查询，一般不建议启动该参数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> slow_query_log<span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p> 设置慢查询阈值时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> long_query_time<span class="hljs-operator">=</span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h5 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h5><h3 id="6、Show-profile"><a href="#6、Show-profile" class="headerlink" title="6、Show profile"></a>6、Show profile</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> profile cpu,block io <span class="hljs-keyword">for</span> query <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>分析show profile关注的指标</p><p>convert HEAP to MyISAM 内存不够可</p><p>create tmp table 创建了临时表</p><p>copying to tmp table on disk 把内存中临时表复制到磁盘</p><p>locked 锁</p><p>全局查询日志</p><p>永远不要再生产环境开启这个功能</p><h3 id="7、Mysql的锁机制"><a href="#7、Mysql的锁机制" class="headerlink" title="7、Mysql的锁机制"></a>7、Mysql的锁机制</h3><p>锁分为表锁和行锁及页锁</p><p>表锁分为读锁和写锁</p><p>行锁支持事物</p><p>事物的ACID特性</p><p>A 原子性 表示事物的操作是一个原子，要么都成功要么都失败</p><p>C 表示一致性，事物从开始到完成前的数据是不变的</p><p>I 隔离性，事物之间是隔离的对外部不可见的</p><p>D 持久性，事物结束后对数据的修改是持久的</p><p><strong>事物的问题</strong></p><ul><li>脏读<ul><li>事物A读到了事物B已经修改尚未提交的数据，如果此时A回滚，b就会拿到错误的数据</li></ul></li><li>不可重复读<ul><li>事物A读取到了事物B已经提交修改的数据，不符合隔离性</li></ul></li><li>幻读<ul><li>事物A读取到了事物B的新增数据</li></ul></li></ul><p><strong>间隙锁</strong></p><p>mysql再进行范围条件时并设置了共享或者排他锁是，innoDB会给符合条件的已有数据记录的索引项加锁，对于键值再条件范围内但是并不存在的记录叫做间隙</p><h3 id="8、主从复制"><a href="#8、主从复制" class="headerlink" title="8、主从复制"></a>8、主从复制</h3><p>slave会从master读取binlog来进行数据同步</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO基础知识</title>
    <link href="/2022/02/14/NIO/"/>
    <url>/2022/02/14/NIO/</url>
    
    <content type="html"><![CDATA[<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><h4 id="1、NIO"><a href="#1、NIO" class="headerlink" title="1、NIO"></a>1、NIO</h4><h5 id="1-1-NIO三大组件"><a href="#1-1-NIO三大组件" class="headerlink" title="1.1 NIO三大组件"></a>1.1 NIO三大组件</h5><ul><li>Channel &amp; Buffer</li></ul><p>channel是读取数据的双向通道，可以从channel将数据读到buffer，也可以将buffer的数据写入channel，而之前的stream要么是输入，要么是输出，channel比stream更为底层</p><p>常见的channel有</p><ul><li>FileChannel 文件读取</li><li>DatagramChannel UDP编程</li><li>SocketChannel 服务器编程</li><li>ServerSocketChannle 服务器编程用于服务端</li></ul><h5 id="1-2、buffer"><a href="#1-2、buffer" class="headerlink" title="1.2、buffer"></a>1.2、buffer</h5><p>buffer用来缓冲读写数据，常见的buffer有</p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeaoByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><h5 id="1-3-Selector-选择器"><a href="#1-3-Selector-选择器" class="headerlink" title="1.3 Selector 选择器"></a>1.3 Selector 选择器</h5><p>在传统的多线程版本服务器开发过程中，每次来一个客户端都需要使用一个线程去操作客户端</p><ul><li>缺点<ul><li>内存占用高</li><li>xxxxxxxxxx source &#x2F;etc&#x2F;profileshell</li><li>只适合连接数较少的情况</li></ul></li></ul><p>多线程版服务器的设计</p><p><strong>线程池</strong></p><p>线程池可以控制线程数</p><ul><li>缺点<ul><li>阻塞模式下，一个线程只能处理一个Socket链接</li><li>仅适合短链接场景线程的利用率不高</li></ul></li></ul><p><strong>Select版本的设计</strong></p><p>一个线程管理一个Selector，获取这些channle上发生的事件，这些channle工作在非阻塞模式下，不会让线程吊死在一个channle上，适合连接数特别多，但是流量低的场景</p><p>调用selector的select会阻塞直到channel发生了读写就绪时间，这些事件发大声，select方法会返回这些事件交给thread来处理</p><h5 id="1-2-ByteBuffer"><a href="#1-2-ByteBuffer" class="headerlink" title="1.2 ByteBuffer"></a>1.2 ByteBuffer</h5><ul><li>示例，用bytebuffer读取数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\学习\\代码\\javabingfa\\nettystudy\\data.txt&quot;</span>).getChannel()) &#123;<br>            <span class="hljs-comment">// 准备缓冲区</span><br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">allocate</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(allocate);<br>                <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                allocate.flip();<br>                <span class="hljs-keyword">while</span> (allocate.hasRemaining())&#123;<br>                    <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> allocate.get();<br>                    log.debug(<span class="hljs-string">&quot;读取到的字节&quot;</span> + b);<br>                &#125;<br>                allocate.flip();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br><br>        &#125;<br></code></pre></td></tr></table></figure><ul><li><p>使用步骤</p><ul><li>向bytebuffer写入数据，例如调用Channel.read</li><li>调用flip切换至读模式</li><li>从buffer读取数据</li><li>调用clear或者compect切换至写模式</li><li>重复</li></ul></li><li><p>ByteBuffer结构</p><ul><li>capacity</li><li>position</li><li>limit</li></ul></li></ul><p>一开始的时候，position位于数组的0，capacity&#x3D;limit等于最大容量</p><p>写模式下，position是写入的位置，当写入了四个字节后，position后移</p><p>调用flip动作后，切换写为读取，此时会将position重新指向0，position切换为读指针，然后limit变成了读取限制，等于前面position的位置</p><p>读取完毕后调用clear</p><p>状态又回到最初的时候</p><p><strong>compat和clear的区别</strong></p><ul><li>如果某种原因没有读完立马开始写，则需要compat方法压缩</li><li>不会把position放到0的位置</li></ul><p><strong>初始化一个Bytebuffer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>        byteBuffer.put((<span class="hljs-type">byte</span>) <span class="hljs-number">0x97</span>);<br>        ByteBufferUtil.debugAll(byteBuffer);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rub">position: [1], limit: [10]<br>         +-------------------------------------------------+<br>0         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>0+--------+-------------------------------------------------+----------------+<br>0|00000000| 97 00 00 00 00 00 00 00 00 00                   |..........      |<br>0+--------+-------------------------------------------------+----------------+<br><br></code></pre></td></tr></table></figure><p>position是1，limit是10</p><p><strong>如果不切换读模式会怎么样</strong></p><p>如果不切换读模式会会导致position不会回到0，那么读取到的是1的位置</p><p><strong>Bytebuffer常见方法</strong></p><ul><li><p>allocate</p><ul><li>分配内存</li><li>bytebuffer的内存创建后不能更改大小</li><li>创建的是heapBytebuffer，存放在java的堆内存中的</li></ul></li><li><p>allocateDirect</p><ul><li>创建的是DirectBytebuffer</li><li>堆内存的读写效率较低，堆内存会受到垃圾回收的影响</li></ul></li><li><p>写入数据</p><ul><li>调用channel的read方法</li><li>调用buffer自己的put方法</li></ul></li><li><p>读取数据</p><ul><li><p>调用channel的write方法</p></li><li><p>调用buffer的get方法</p><ul><li>get方法可以让读指针向后走</li><li>如何想要重复读取数据可以调用rewind方法将position后移或者使用get（i），但是position不会后移</li></ul></li><li><p>调用rewind方法就是将position设置为0</p></li><li><p>mark 和 reset方法</p><p>mark 是记录position的位置</p><p>reset 是将position重置到mark位置</p><p>使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">byteBuffer.flip();<br>byteBuffer.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1</span>]);<br>byteBuffer.mark(); <span class="hljs-comment">// 记录position的位置</span><br><span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> byteBuffer.position();<br>System.out.println(position);<br>byteBuffer.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span>]);<br>byteBuffer.reset();<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> byteBuffer.get();<br>System.out.println((<span class="hljs-type">char</span>) b);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Bytebuffer与字符串的转换</p><ul><li><p>字符串转为byteBuffer</p><ul><li><p>字符串转为byte数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">allocate</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">20</span>);<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">put</span> <span class="hljs-operator">=</span> allocate.put(<span class="hljs-string">&quot;你好&quot;</span>.getBytes());<br>ByteBufferUtil.debugAll(put);<br></code></pre></td></tr></table></figure></li><li><p>StandardCharsets 指定字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">hellow</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;你好&quot;</span>);<br>ByteBufferUtil.debugAll(hellow);<br></code></pre></td></tr></table></figure></li><li><p>ByteBuffer.wrap</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">wrap</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-string">&quot;你好&quot;</span>.getBytes());<br>      <br></code></pre></td></tr></table></figure></li><li><p>bytebuffer转字符串</p></li></ul></li><li><p>分散读，集中写</p><ul><li>分散读取到多个bytebuffer</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;D:\\学习\\代码\\javabingfa\\nettystudy\\data.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> rw.getChannel();<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">allocate1</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">3</span>);<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">allocate2</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">3</span>);<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">allocate3</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>channel.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBuffer</span>[]&#123;allocate1, allocate2, allocate3&#125;);<br>allocate1.flip();<br>allocate2.flip();<br>allocate3.flip();<br>ByteBufferUtil.debugAll(allocate1);<br>ByteBufferUtil.debugAll(allocate2);<br>ByteBufferUtil.debugAll(allocate3);<br></code></pre></td></tr></table></figure><ul><li>集中写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">rw2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;D:\\学习\\代码\\javabingfa\\nettystudy\\data2.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel1</span> <span class="hljs-operator">=</span> rw2.getChannel();<br>channel1.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBuffer</span>[]&#123;allocate1,allocate2,allocate3,allocate3&#125;);<br></code></pre></td></tr></table></figure></li><li><p>Bytebyffer 解决粘包拆包</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">split</span><span class="hljs-params">(ByteBuffer allocate)</span>&#123;<br>        allocate.flip();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; allocate.limit(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (allocate.get(i) == <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>                System.out.println(allocate.get(i));<br>                <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span> - allocate.position();<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(length);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>                    desc.put(allocate.get());<br>                &#125;<br>                ByteBufferUtil.debugAll(desc);<br><br>            &#125;<br>        &#125;<br>        allocate.compact();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">allocate</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">32</span>);<br>        allocate.put(<span class="hljs-string">&quot;hellow,word\nI&#x27;m zhangsan\nHo&quot;</span>.getBytes());<br>        split(allocate);<br>        allocate.put(<span class="hljs-string">&quot;w are you?\n&quot;</span>.getBytes());<br>        split(allocate);<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="1-3-网络编程"><a href="#1-3-网络编程" class="headerlink" title="1.3 网络编程"></a>1.3 网络编程</h5><ul><li><p>阻塞模式</p><ul><li>创建一个服务端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">allocate</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">open</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        open.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8888</span>));<br>        ArrayList&lt;SocketChannel&gt; socketChannels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            log.debug(<span class="hljs-string">&quot;Connect.....&quot;</span>);<br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">accept</span> <span class="hljs-operator">=</span> open.accept();<br>            log.debug(<span class="hljs-string">&quot;ConnectSucceed&quot;</span>);<br>            socketChannels.add(accept);<br>            <span class="hljs-keyword">for</span> (SocketChannel channle:socketChannels<br>                 ) &#123;<br>                channle.read(allocate);<br>                allocate.flip();<br>                ByteBufferUtil.debugAll(allocate);<br>                allocate.clear();<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><ul><li>创建一个客户端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">open</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> open.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">8888</span>));<br><br></code></pre></td></tr></table></figure><blockquote><p>阻塞模式下，一个方法的执行会影响另一个方法</p></blockquote></li><li><p>非阻塞模式</p><ul><li>修改为非阻塞模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">open.configureBlocking(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure></li></ul><h5 id="1-4-Selector"><a href="#1-4-Selector" class="headerlink" title="1.4 Selector"></a>1.4 Selector</h5><ul><li>创建一个Selector</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br></code></pre></td></tr></table></figure><ul><li>将channel交给selector管理<ul><li>返回值是selectionKey，我们可以通过selectionKey获取事件和channel</li><li>什么是事件<ul><li>accept 连接事件</li><li>connect 客户端连接建立后触发的事件</li><li>read 对于socket来说，表示数据到了，可读事件</li><li>write 可写事件</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> socketChannel.register(selector, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);<span class="hljs-comment">// 注册到上面</span><br></code></pre></td></tr></table></figure><ul><li>设置ssk关注的事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">selectionKey.interestOps(SelectionKey.OP_ACCEPT); <span class="hljs-comment">// 枚举值</span><br></code></pre></td></tr></table></figure><ul><li>select方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">selector.select(); <span class="hljs-comment">//没有事件线程会阻塞</span><br></code></pre></td></tr></table></figure><ul><li>处理事件<ul><li>selectionKeys中包含了所有的可执行的事件</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); <span class="hljs-comment">// 拿到所有可用的事件</span><br>Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); <span class="hljs-comment">// 拿到所有可用的事件</span><br>            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>                <span class="hljs-comment">// 拿到了事件的key</span><br>                log.debug(key.toString());<br>                <span class="hljs-comment">// 通过key 拿到了channle</span><br>                <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                channel.accept(); <span class="hljs-comment">// 建立连接</span><br>                System.out.println(<span class="hljs-string">&quot;有人建立了连接&quot;</span>);<br>            &#125;<br></code></pre></td></tr></table></figure><ul><li>如果不处理事件会发生什么？<ul><li>他会认为事件没有进行处理，无线循环，不会阻塞</li></ul></li><li>读取事件处理</li></ul><p>在处理读取事件之前，我们必须知道怎么去区分事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">key.isAcceptable()<br>key.isReadable()<br></code></pre></td></tr></table></figure><ul><li>区分事件后，处理读取的事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (key.isReadable())&#123;<br>                    System.out.println(<span class="hljs-string">&quot;可读请求&quot;</span>);<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>                    channel.read(byteBuffer);<br>                    byteBuffer.flip();<br>                    ByteBufferUtil.debugAll(byteBuffer);<br>                    byteBuffer.clear();<br>                    iterator.remove();<br>                &#125;<br></code></pre></td></tr></table></figure><p><strong>注意：发生事件的key我们必须手动删除key</strong></p><ul><li>处理客户端断开</li></ul><p>​在客户端断开时候，处理异常需要反注册，也就是需要从keyset中注销以上是非正常断开</p><p>​那么正常断开应该怎么处理呢</p><ul><li>根据read的结果判断是否需要移除key</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">key.cancel();<br></code></pre></td></tr></table></figure><ul><li><p>消息边界问题</p><ul><li>固定消息长度，数据包大小一样，服务器按照预定长度读取，缺点是浪费带宽</li><li>按照分隔符拆分，缺点是效率低</li><li>将长度信息放到头部动态处理消息边界<ul><li>LTV模式</li></ul></li></ul></li><li><p>附件与扩容</p><ul><li>注册的时候关联附件 确保一个channle关联一个bytebuffer</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">register</span> <span class="hljs-operator">=</span> accept.register(selector, <span class="hljs-number">0</span>, ByteBuffer.allocate(<span class="hljs-number">16</span>));<br></code></pre></td></tr></table></figure><ul><li>使用key.attachment()获取附件</li><li>设置新的附件key.attach(newByteBuffer);</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">split(byteBuffer);<br><span class="hljs-comment">// 扩容</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">newByteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(byteBuffer.capacity() * <span class="hljs-number">2</span>);<br>newByteBuffer.put(byteBuffer);<br>key.attach(newByteBuffer);<br>byteBuffer.clear();<br>iterator.remove();<br></code></pre></td></tr></table></figure></li><li><p>Bytebuffer的大小怎么分配</p><ul><li>每个Channel都需要记录可能被切分的消息，因为Bytebuffer不能被多个channel共同使用，因此需要设计大小可变的Bytebuffer</li><li>Bytebuffer不能太大，比如一个Bytebuffer 1MB的话需要支持百万连接就要1TB内存，因此需要设计大小可变的Bytebuffer<ul><li>一种思想是先分配一个比较小的buffer，然后如果不够在进行扩容</li><li>另一种思路是用多个数组组成buffer吗，一个数组不够把多余的内容写入新的数组，在于前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li></ul></li></ul></li><li><p>可写事件</p><ul><li>建立连接后服务端给客户端发送数据，如果一次性发不完，关注一个可写事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">dataBuffer</span> <span class="hljs-operator">=</span> Charset.defaultCharset().encode(stringBuilder.toString());<br>acceptChannel.write(dataBuffer);<span class="hljs-comment">//先进行写入操作</span><br><span class="hljs-keyword">if</span> (dataBuffer.hasRemaining())&#123;<br><span class="hljs-comment">// 如果有数据则关注一个可写事件</span><br>acceptChannel.register(selector,SelectionKey.OP_ACCEPT + SelectionKey.OP_WRITE);<br><span class="hljs-comment">// 将剩余的数据一起带过去</span><br>key.attach(dataBuffer);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对可写事件进行处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (key.isWritable())&#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">attachment</span> <span class="hljs-operator">=</span> (ByteBuffer) key.attachment();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> channel.write(attachment);<br>    System.out.println(<span class="hljs-string">&quot;继续写入&quot;</span> + write);<br>    <span class="hljs-keyword">if</span> (!attachment.hasRemaining())&#123;<br>        key.attach(<span class="hljs-literal">null</span>);<br>        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE); <span class="hljs-comment">// 不再关注可写事件</span><br>    &#125;<br>&#125;<br>  <br></code></pre></td></tr></table></figure></li></ul><h5 id="1-5-多线程"><a href="#1-5-多线程" class="headerlink" title="1.5 多线程"></a>1.5 多线程</h5><p>利用多线程，主线程只负责连接事件，连接事件将任务分发给多个线程去处理，work1负责处理读事件，work2负责处理写事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 主线程作为BOSS</span><br>        Thread.currentThread().setName(<span class="hljs-string">&quot;BOSS&quot;</span>);<br>        <span class="hljs-comment">// 创建Selector</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">boss</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-comment">// 创建socker</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        serverSocketChannel.register(boss, SelectionKey.OP_ACCEPT,<span class="hljs-literal">null</span>);<br>        serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8888</span>));<br>        <span class="hljs-type">Worker</span> <span class="hljs-variable">work1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&quot;Work1&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            boss.select();<br>            Set&lt;SelectionKey&gt; selectionKeys = boss.selectedKeys();<br>            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>                <span class="hljs-keyword">if</span> (key.isAcceptable())&#123;<br>                    <span class="hljs-comment">// 是连接请求</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">accept</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>                    accept.configureBlocking(<span class="hljs-literal">false</span>);<br>                    work1.initWorker(accept);<br><br>                &#125;<br>                iterator.remove();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>        <span class="hljs-keyword">private</span> Thread thread;<br>        <span class="hljs-keyword">private</span> Selector workerSelector;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">private</span> ConcurrentLinkedDeque&lt;Runnable&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initWorker</span><span class="hljs-params">(SocketChannel accept)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-keyword">if</span> (!flag)&#123;<br>                System.out.println(<span class="hljs-string">&quot;初始化&quot;</span>);<br>                workerSelector = Selector.open();<br>                flag = <span class="hljs-literal">true</span>;<br>                thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>);<br>                thread.start();<br>            &#125;<br>            deque.add(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    accept.register(workerSelector,SelectionKey.OP_READ,<span class="hljs-literal">null</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (ClosedChannelException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            workerSelector.wakeup(); <span class="hljs-comment">// 唤醒select</span><br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// worker的工作就是监测读写事件</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    workerSelector.select();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> deque.poll();<br>                <span class="hljs-keyword">if</span> (task != <span class="hljs-literal">null</span>)&#123;<br>                    task.run();<br>                &#125;<br>                Set&lt;SelectionKey&gt; selectionKeys = workerSelector.selectedKeys();<br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>                    iterator.remove();<br>                    <span class="hljs-keyword">if</span> (key.isReadable())&#123;<br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            socketChannel.read(buffer);<br>                            buffer.flip();<br>                            ByteBufferUtil.debugAll(buffer);<br>                        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>存在的问题<ul><li>由于是多线程运行，work在注册之前，select已经阻塞了，没有办法执行已经注册了的事件，必须有下一个事件进来的时候才能执行，因此，我们需要在注册完成后就对select进行唤醒</li></ul></li><li>调用wakeup方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">workerSelector.wakeup(); <span class="hljs-comment">// 唤醒select</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>网络编程</tag>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch-基础知识</title>
    <link href="/2022/02/07/Elasticsearch/"/>
    <url>/2022/02/07/Elasticsearch/</url>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch-基础知识"><a href="#Elasticsearch-基础知识" class="headerlink" title="Elasticsearch-基础知识"></a>Elasticsearch-基础知识</h2><h3 id="1、为什么要学习Elasticsearch"><a href="#1、为什么要学习Elasticsearch" class="headerlink" title="1、为什么要学习Elasticsearch"></a>1、为什么要学习Elasticsearch</h3><p><strong>Elasticsearch的主要功能</strong></p><ul><li>分布式搜索引擎</li><li>大数据近实时分析引擎</li></ul><p><strong>产品特性</strong></p><ul><li>高性能</li><li>容易使用和扩展</li></ul><h3 id="2、Elasticsearch简介和发展历史"><a href="#2、Elasticsearch简介和发展历史" class="headerlink" title="2、Elasticsearch简介和发展历史"></a>2、Elasticsearch简介和发展历史</h3><p>Elasticsearch是基于Java语言开发的搜索引擎库类</p><p>创建于1999不阿不，2005年成为Apache顶级开源项目</p><p>Lucene具有高性能容易扩展的优点</p><p><strong>Lucene的局限性</strong></p><ul><li>只能基于Java语言开发</li><li>类库的接口学习曲线陡峭</li><li>原生并并不支持水平拓展</li></ul><p><strong>主要功能</strong></p><p>海量数据的分布式存储和集群管理</p><p>近实时搜索，性能卓越</p><ul><li>结构化&#x2F;全文&#x2F;地理位置&#x2F;自动完成</li></ul><p>海量数据的近实时分析</p><ul><li>聚合功能</li></ul><h3 id="3、Elastic-Stack生态圈"><a href="#3、Elastic-Stack生态圈" class="headerlink" title="3、Elastic Stack生态圈"></a>3、Elastic Stack生态圈</h3><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/elk%E6%8A%80%E6%9C%AF%E6%A0%88.png"></p><h4 id="3-1-Logstash-数据处理管道"><a href="#3-1-Logstash-数据处理管道" class="headerlink" title="3.1 Logstash 数据处理管道"></a>3.1 Logstash 数据处理管道</h4><p><strong>Logstash是开源的数据处理管道，支持从不同来源采集数据转换数据，并将数据发送到不同的存储库中</strong></p><p>特点</p><ul><li>实时解析和转换数据<ul><li>从IP地址破译出地理坐标</li><li>将PLL数据匿名化，完全排除敏感字段</li></ul></li><li>可扩展<ul><li>200多个插件</li></ul></li><li>可靠性安全性<ul><li>Logstash会通过持久化队列来保证至少将运行中的事件送达一次</li><li>数据传输加密</li></ul></li><li>监控</li></ul><h4 id="3-2-Kibana-可视化分析利器"><a href="#3-2-Kibana-可视化分析利器" class="headerlink" title="3.2 Kibana 可视化分析利器"></a>3.2 Kibana 可视化分析利器</h4><p><strong>数据可视化工具</strong></p><ul><li>提供可视化图表</li><li>利用机器学习</li></ul><h4 id="3-3-BEATS-轻量的数据采集器"><a href="#3-3-BEATS-轻量的数据采集器" class="headerlink" title="3.3 BEATS 轻量的数据采集器"></a>3.3 BEATS 轻量的数据采集器</h4><p><strong>GO语言开发的</strong>针对不同的数据源进行数据采集器</p><h4 id="3-4-X-Pack-商业化套件"><a href="#3-4-X-Pack-商业化套件" class="headerlink" title="3.4 X-Pack 商业化套件"></a>3.4 X-Pack 商业化套件</h4><p><strong>收费</strong></p><h4 id="3-5-应用场景"><a href="#3-5-应用场景" class="headerlink" title="3.5 应用场景"></a>3.5 应用场景</h4><ul><li>搜索<ul><li>网站搜索</li><li>垂直搜索</li><li>代码搜索</li></ul></li><li>分析<ul><li>日志管理与分析</li><li>安全指标监控</li><li>应用性能监控</li><li>web抓取舆情分析</li></ul></li></ul><p><strong>日志收集</strong></p><p>日志搜集-格式化分析-全文检索-风险告警</p><p><strong>Elasticsearch与数据库的集成</strong></p><ul><li>单独使用Elasticsearch存储</li><li>以下情况可以考虑与数据库集成<ul><li>与现有系统的集成</li><li>需要考虑事务性</li><li>数据更新频繁</li></ul></li></ul><p><strong>指标分析&#x2F;日志分析</strong></p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E6%8C%87%E6%A0%87%E5%88%86%E6%9E%90%20%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90.png"></p><h3 id="4、Elasticsearch安装与简单部署"><a href="#4、Elasticsearch安装与简单部署" class="headerlink" title="4、Elasticsearch安装与简单部署"></a>4、Elasticsearch安装与简单部署</h3><h4 id="4-1-Elasticsearch的文件目录结构"><a href="#4-1-Elasticsearch的文件目录结构" class="headerlink" title="4.1 Elasticsearch的文件目录结构"></a>4.1 Elasticsearch的文件目录结构</h4><table><thead><tr><th>目录</th><th>配置文件</th><th>描述</th></tr></thead><tbody><tr><td>bin</td><td></td><td>脚本文件、包括启动ES、安装插件、运行统计数据等等</td></tr><tr><td>config</td><td>sleaticsearch.yml</td><td>集群配置文件，user，role based相关配置</td></tr><tr><td>JDK</td><td></td><td>Java运行环境</td></tr><tr><td>data</td><td>path.data</td><td>数据文件</td></tr><tr><td>lib</td><td></td><td>Java类库</td></tr><tr><td>logs</td><td>path.log</td><td>日志文件</td></tr><tr><td>modules</td><td></td><td>包含所有ES模块</td></tr><tr><td>plugins</td><td></td><td>包含所有已安装插件</td></tr></tbody></table><h4 id="4-2-JVM配置"><a href="#4-2-JVM配置" class="headerlink" title="4.2 JVM配置"></a>4.2 JVM配置</h4><ul><li>修改JVM -config&#x2F;jvm.options</li><li>配置建议<ul><li>XMS和XMS设置成一样</li><li>Xmx不要超过机器内存的50%</li><li>不要超过30GB</li></ul></li></ul><h4 id="4-3-安装"><a href="#4-3-安装" class="headerlink" title="4.3 安装"></a>4.3 安装</h4><p><a href="https://www.elastic.co/cn/downloads">https://www.elastic.co/cn/downloads</a></p><p>安装过程中可能会出现的一些问题总结</p><blockquote><p>1、seccomp unavailable 错误</p><p><strong>解决方法</strong>：elasticsearch.yml 配置</p><p>bootstrap.memory_lock: false</p><p>bootstrap.system_call_filter: false</p><p>2、max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536]</p><p><strong>解决方法</strong>：修改 &#x2F;etc&#x2F;security&#x2F;limits.conf</p><p>hard nofile 80000 </p><p>soft nofile 80000</p><p>3、 max virtual memory areas vm.max_map_count [65530] is too low</p><p><strong>解决方法</strong>：修改 &#x2F;etc&#x2F;sysctl.conf</p><p>vm.max_map_count &#x3D; 262144</p><p>然后 sysctl -p 生效</p><p>4、the default discovery settings are unsuitable…., last least one of [….] must be configured</p><p><strong>解决方法</strong>：elasticsearch.yml 开启配置：</p><p>node.name: node-1</p><p>cluster.initial_master_nodes: [“node-1”]</p></blockquote><h4 id="4-4-安装插件（示例）"><a href="#4-4-安装插件（示例）" class="headerlink" title="4.4 安装插件（示例）"></a>4.4 安装插件（示例）</h4><p>安装analysis-icu分词器</p><p><strong>查看安装的插件列表</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./elasticsearch-plugin list<br></code></pre></td></tr></table></figure><p><strong>安装anaylysis-icu分词器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./elasticsearch-plugin install analysis-icu <br></code></pre></td></tr></table></figure><h4 id="4-5-如何运行多个Elasticsearch-实例"><a href="#4-5-如何运行多个Elasticsearch-实例" class="headerlink" title="4.5 如何运行多个Elasticsearch 实例"></a>4.5 如何运行多个Elasticsearch 实例</h4><h4 id="4-6-Docker环境中运行ELK"><a href="#4-6-Docker环境中运行ELK" class="headerlink" title="4.6 Docker环境中运行ELK"></a>4.6 Docker环境中运行ELK</h4><p>后续补充</p><h4 id="4-7-启动多个实例"><a href="#4-7-启动多个实例" class="headerlink" title="4.7 启动多个实例"></a>4.7 启动多个实例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">./elasticsearch -E node.name=node-1 -E cluster.name=elasticsearch -E path.data=node1_data -E http.port=9200<br><br>./elasticsearch -E node.name=node-2 -E cluster.name=elasticsearch -E path.data=node2_data -E http.port=9201<br><br>./elasticsearch -E node.name=node-3 -E cluster.name=elasticsearch -E path.data=node3_data -E http.port=9203<br></code></pre></td></tr></table></figure><h3 id="5、安装Kibana"><a href="#5、安装Kibana" class="headerlink" title="5、安装Kibana"></a>5、安装Kibana</h3><h4 id="5-1-安装下载"><a href="#5-1-安装下载" class="headerlink" title="5.1 安装下载"></a>5.1 安装下载</h4><p><a href="https://www.elastic.co/cn/downloads">https://www.elastic.co/cn/downloads</a></p><h4 id="5-2-Kibana添加样例数据"><a href="#5-2-Kibana添加样例数据" class="headerlink" title="5.2 Kibana添加样例数据"></a>5.2 Kibana添加样例数据</h4><p>kibana为我们准备了一些学习数据，包括日志，订单，航班数据等等</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/Kibana%E6%B7%BB%E5%8A%A0%E6%A0%B7%E4%BE%8B%E6%95%B0%E6%8D%AE.png"></p><h4 id="5-3-DEV-Tool"><a href="#5-3-DEV-Tool" class="headerlink" title="5.3 DEV Tool"></a>5.3 DEV Tool</h4><p>dev tool 帮助我们调试</p><h3 id="6、Logstash"><a href="#6、Logstash" class="headerlink" title="6、Logstash"></a>6、Logstash</h3><p>安装Logstash，并且导入Movielens的测试数据集</p><h4 id="6-1-下载"><a href="#6-1-下载" class="headerlink" title="6.1 下载"></a>6.1 下载</h4><p><a href="https://www.elastic.co/cn/downloads/logstash">https://www.elastic.co/cn/downloads/logstash</a></p><h4 id="6-2-下载数据集并且导入数据"><a href="#6-2-下载数据集并且导入数据" class="headerlink" title="6.2 下载数据集并且导入数据"></a>6.2 下载数据集并且导入数据</h4><p><a href="https://grouplens.org/datasets/movielens/">https://grouplens.org/datasets/movielens/</a> 数据集</p><p><strong>配置文件</strong></p><p>此文件只为了导入数据使用，需要修改的是下载的数据源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs config">input &#123;<br>  file &#123;<br>    path =&gt; &quot;/tangcheng/logstash-7.3.0/import/movies.csv&quot;<br>    start_position =&gt; &quot;beginning&quot;<br>    sincedb_path =&gt; &quot;/dev/null&quot;<br>  &#125;<br>&#125;<br>filter &#123;<br>  csv &#123;<br>    separator =&gt; &quot;,&quot;<br>    columns =&gt; [&quot;id&quot;,&quot;content&quot;,&quot;genre&quot;]<br>  &#125;<br><br>  mutate &#123;<br>    split =&gt; &#123; &quot;genre&quot; =&gt; &quot;|&quot; &#125;<br>    remove_field =&gt; [&quot;path&quot;, &quot;host&quot;,&quot;@timestamp&quot;,&quot;message&quot;]<br>  &#125;<br><br>  mutate &#123;<br><br>    split =&gt; [&quot;content&quot;, &quot;(&quot;]<br>    add_field =&gt; &#123; &quot;title&quot; =&gt; &quot;%&#123;[content][0]&#125;&quot;&#125;<br>    add_field =&gt; &#123; &quot;year&quot; =&gt; &quot;%&#123;[content][1]&#125;&quot;&#125;<br>  &#125;<br><br>  mutate &#123;<br>    convert =&gt; &#123;<br>      &quot;year&quot; =&gt; &quot;integer&quot;<br>    &#125;<br>    strip =&gt; [&quot;title&quot;]<br>    remove_field =&gt; [&quot;path&quot;, &quot;host&quot;,&quot;@timestamp&quot;,&quot;message&quot;,&quot;content&quot;]<br>  &#125;<br><br>&#125;<br>output &#123;<br>   elasticsearch &#123;<br>     hosts =&gt; &quot;http://localhost:9200&quot;<br>     index =&gt; &quot;movies&quot;<br>     document_id =&gt; &quot;%&#123;id&#125;&quot;<br>   &#125;<br>  stdout &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>执行脚本导入数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./logstash -f ../config/logstash.conf<br></code></pre></td></tr></table></figure><h3 id="7、Elasticsearch-的基本概念"><a href="#7、Elasticsearch-的基本概念" class="headerlink" title="7、Elasticsearch 的基本概念"></a>7、Elasticsearch 的基本概念</h3><h4 id="7-1-文档-doucument"><a href="#7-1-文档-doucument" class="headerlink" title="7.1 文档 doucument"></a>7.1 文档 doucument</h4><p>Elasticsearch是面向文档的，文档是所有可搜索的数据的最小单位，例如</p><ul><li>日志中的日志项</li><li>一本电影的具体信息</li></ul><p>文档会被序列化成JSON格式保存在Elasticsearch中</p><ul><li>JSON对象由字段组成</li><li>每个字段都有对应的字段类型（字符串&#x2F;数值&#x2F;布尔&#x2F;日期&#x2F;二进制&#x2F;范围类型）</li></ul><p>每个文档都有一个ID</p><ul><li>可以自己指定ID</li><li>也可以自动生成ID</li></ul><p><strong>文档的元数据</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;movies&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;_doc&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3510&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_seq_no&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2625</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_primary_term&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;found&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_source&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Frequency&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;genre&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;Drama&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;Thriller&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;year&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2000</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3510&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>元数据<ul><li>_index 文档所属的索引名</li><li>_type 文档所属的类型名</li><li>_id 文档唯一ID</li><li>_source 文档原始JSON数据</li><li>_version 文档的版本信息</li><li>_source 相关性打分</li></ul></li></ul><h4 id="7-2-索引-Index"><a href="#7-2-索引-Index" class="headerlink" title="7.2 索引 Index"></a>7.2 索引 Index</h4><p><strong>索引Index是文档的容器</strong></p><ul><li>index体现了逻辑空间的概念，每个索引都有自己的mapping定义</li><li>Shard体现了物理空间上的概念，索引中的数据分散在Shard上</li></ul><p><strong>索引的Mapping与Settings</strong></p><ul><li>Mapping定义文档字段的类型</li><li>Seting定义不同的数据分布</li></ul><h4 id="7-3-类型-Type"><a href="#7-3-类型-Type" class="headerlink" title="7.3 类型 Type"></a>7.3 类型 Type</h4><p>在7.0中type已被废除</p><h4 id="7-4-与关系型数据库的类比"><a href="#7-4-与关系型数据库的类比" class="headerlink" title="7.4 与关系型数据库的类比"></a>7.4 与关系型数据库的类比</h4><table><thead><tr><th>关系型数据库</th><th>ES</th><th>说明</th></tr></thead><tbody><tr><td>Table</td><td>Index、Type</td><td>表</td></tr><tr><td>Row</td><td>Document</td><td>一行数据</td></tr><tr><td>Column</td><td>Filed</td><td>字段</td></tr><tr><td>Schema</td><td>Maping</td><td>表定义</td></tr><tr><td>SQL</td><td>DSL</td><td>查询语句</td></tr></tbody></table><p>和关系型数据库的区别</p><p>Elasticsearch - Schemaless 相关性，高性能全文检索</p><p>RDMS 事物性</p><h4 id="7-5-分布式特性"><a href="#7-5-分布式特性" class="headerlink" title="7.5 分布式特性"></a>7.5 分布式特性</h4><p><strong>分布式系统的可用性与拓展性</strong></p><ul><li>高可用性<ul><li>表现在服务可用性:允许有节点停止服务</li><li>数据可用性：部分节点丢失不会丢失数据</li></ul></li><li>可扩展性<ul><li>请求量提升&#x2F;数据的不断增长</li></ul></li></ul><p><strong>Elasticsearch分布式架构的好处</strong></p><ul><li>存储的水平扩容</li><li>提供系统的可用性，部分节点停止服务后，整个集群服务不受影响</li></ul><p><strong>Elasticsearch的分布式架构</strong></p><ul><li>不同的集群通过不同的名字来区分，默认名字”elasticsearch“</li><li>通过配置文件修改</li><li>一个集群可以有一个或多个节点</li></ul><h4 id="7-6-节点-Node"><a href="#7-6-节点-Node" class="headerlink" title="7.6 节点 Node"></a>7.6 节点 Node</h4><p><strong>节点是一个Elasticsearch实例</strong></p><ul><li>节点的本质是一个java进程</li><li>一台机器上可以运行多个Elasticsearch进行</li></ul><p><strong>每一个节点都有名字，通过配置文件配置</strong></p><p><strong>每一个节点启动之后都会分配一个UID，保存在data目录下</strong></p><p>不同的节点会承担不同的角色</p><h5 id="7-6-1-Master-eligible-nodes-和-Master-Node"><a href="#7-6-1-Master-eligible-nodes-和-Master-Node" class="headerlink" title="7.6.1 Master-eligible nodes 和 Master Node"></a>7.6.1 Master-eligible nodes 和 Master Node</h5><p>每个节点启动后默认就是一个Master-eligible节点</p><blockquote><p>可以设置node.master:false</p></blockquote><p>Master-eligible节点可以参加选举为主机点成为Master节点</p><p>第一个启动的节点会将自己选举为Master节点</p><p>每个节点都保存了集群的状态，但是只有Master节点可以修改集群的状态</p><ul><li>集群的状态维护了一个集群中必要的信息<ul><li>所有节点的信息</li><li>所有索引和其他相关的mapping 和 Seting信息</li><li>分片和路由信息</li></ul></li><li>任意节点都能修改信息会导致数据的不一致性</li></ul><h5 id="7-6-2-Data-Node-Coordinating-Node"><a href="#7-6-2-Data-Node-Coordinating-Node" class="headerlink" title="7.6.2 Data Node Coordinating Node"></a>7.6.2 Data Node Coordinating Node</h5><p><strong>Data Node</strong> </p><p>Data Node 是可以不存数据的节点，负责保存分片数据</p><p><strong>Corrdination Node</strong></p><p>负责接收client请求并分发的合适的节点并把最终的结果汇总在一起</p><p>每个街斗都默认起到了Corrdination 的职责</p><h5 id="7-6-3-其他节点类型"><a href="#7-6-3-其他节点类型" class="headerlink" title="7.6.3 其他节点类型"></a>7.6.3 其他节点类型</h5><p><strong>Hot &amp; Warm Node</strong></p><p>冷热节点代表了不同配置的节点，降低集群部署成本</p><p><strong>Machine Learn Node</strong></p><p>负责跑机器学习的Job，用来做异常检测</p><p><strong>Tribe Node</strong></p><h5 id="7-6-4-配置节点类型"><a href="#7-6-4-配置节点类型" class="headerlink" title="7.6.4 配置节点类型"></a>7.6.4 配置节点类型</h5><p><strong>在开发环境中一个节点可以承担多种角色</strong></p><p><strong>在生产环境中应该设置单一角色的节点</strong></p><h4 id="7-7-分片-Shard"><a href="#7-7-分片-Shard" class="headerlink" title="7.7 分片 Shard"></a>7.7 分片 Shard</h4><p>分片又分为Primary Shard 和 Replica Shard</p><ul><li>主分片用以解决数据水平扩展的问题，通过主分片可以将数据分不到集群内所有的节点之上<ul><li>一个分片是一个运行的Lucene的实例</li><li>主分片数在索引创建时指定，后续不允许修改，除非Reindex</li></ul></li><li>副本，用来解决数据高可用的问题，分片是主分片的拷贝<ul><li>副本分片数可以动态调整</li><li>增加副本数可以在一定程度上提高服务的可用性</li></ul></li></ul><p><strong>分片机制</strong></p><p>一台三节点的集群</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /blogs<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;number_of_shards&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;number_of_replicas&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%88%86%E7%89%87.png"></p><p> <strong>分片的设定</strong></p><p>对于生产环境中分片的设定，需要提前做好容量规划</p><ul><li>分片数设置过小<ul><li>后续无法增加节点实现水平扩展</li><li>单个分片数据量太大，导致数据重新分配耗时</li></ul></li><li>分片数设置过大，从7.0开始默认主分片设置为1，解决了overshading的问题<ul><li>影响搜索结果相关性打分</li><li>单个节点上过多的分片，会导致资源浪费，影响性能</li></ul></li></ul><h4 id="7-8-集群环境查看命令"><a href="#7-8-集群环境查看命令" class="headerlink" title="7.8 集群环境查看命令"></a>7.8 集群环境查看命令</h4><h5 id="7-8-1-集群状态查询"><a href="#7-8-1-集群状态查询" class="headerlink" title="7.8.1 集群状态查询"></a>7.8.1 集群状态查询</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET _cluster/health<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;cluster_name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;elasticsearch&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;status&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yellow&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;timed_out&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;number_of_nodes&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;number_of_data_nodes&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;active_primary_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">8</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;active_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">8</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;relocating_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;initializing_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;unassigned_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;delayed_unassigned_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;number_of_pending_tasks&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;number_of_in_flight_fetch&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;task_max_waiting_in_queue_millis&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;active_shards_percent_as_number&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">72.72727272727273</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h5 id="7-8-2-nodes状态查询"><a href="#7-8-2-nodes状态查询" class="headerlink" title="7.8.2 nodes状态查询"></a>7.8.2 nodes状态查询</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET _cat/nodes?v<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip             heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name<br>192.168.64.132           17          96   1    0.03    0.04     0.05 dim       *      node-1<br><br></code></pre></td></tr></table></figure><h5 id="7-8-3-分片状态查询"><a href="#7-8-3-分片状态查询" class="headerlink" title="7.8.3 分片状态查询"></a>7.8.3 分片状态查询</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET _cat/shards<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">.kibana_1                    <span class="hljs-number">0</span> p STARTED      <span class="hljs-number">161</span>    <span class="hljs-number">1</span>mb <span class="hljs-number">192.168</span><span class="hljs-number">.64</span><span class="hljs-number">.132</span> node<span class="hljs-number">-1</span><br>book                         <span class="hljs-number">0</span> p STARTED        <span class="hljs-number">5</span> <span class="hljs-number">13.9</span>kb <span class="hljs-number">192.168</span><span class="hljs-number">.64</span><span class="hljs-number">.132</span> node<span class="hljs-number">-1</span><br>book                         <span class="hljs-number">0</span> r UNASSIGNED                             <br>kibana_sample_data_ecommerce <span class="hljs-number">0</span> p STARTED     <span class="hljs-number">4675</span>  <span class="hljs-number">4.9</span>mb <span class="hljs-number">192.168</span><span class="hljs-number">.64</span><span class="hljs-number">.132</span> node<span class="hljs-number">-1</span><br>demo_index                   <span class="hljs-number">0</span> p STARTED        <span class="hljs-number">0</span>   <span class="hljs-number">283</span>b <span class="hljs-number">192.168</span><span class="hljs-number">.64</span><span class="hljs-number">.132</span> node<span class="hljs-number">-1</span><br>demo_index                   <span class="hljs-number">0</span> r UNASSIGNED                             <br>kibana_sample_data_flights   <span class="hljs-number">0</span> p STARTED    <span class="hljs-number">13059</span>  <span class="hljs-number">6.6</span>mb <span class="hljs-number">192.168</span><span class="hljs-number">.64</span><span class="hljs-number">.132</span> node<span class="hljs-number">-1</span><br>kibana_sample_data_logs      <span class="hljs-number">0</span> p STARTED    <span class="hljs-number">14074</span> <span class="hljs-number">11.9</span>mb <span class="hljs-number">192.168</span><span class="hljs-number">.64</span><span class="hljs-number">.132</span> node<span class="hljs-number">-1</span><br>.kibana_task_manager         <span class="hljs-number">0</span> p STARTED        <span class="hljs-number">2</span> <span class="hljs-number">27.2</span>kb <span class="hljs-number">192.168</span><span class="hljs-number">.64</span><span class="hljs-number">.132</span> node<span class="hljs-number">-1</span><br>movies                       <span class="hljs-number">0</span> p STARTED     <span class="hljs-number">9743</span>  <span class="hljs-number">1.4</span>mb <span class="hljs-number">192.168</span><span class="hljs-number">.64</span><span class="hljs-number">.132</span> node<span class="hljs-number">-1</span><br>movies                       <span class="hljs-number">0</span> r UNASSIGNED        <br></code></pre></td></tr></table></figure><h4 id="7-9-Mapping"><a href="#7-9-Mapping" class="headerlink" title="7.9 Mapping"></a>7.9 Mapping</h4><p><strong>mapping是类似于数据库中表结构的定义</strong></p><ul><li>定义了字段名称</li><li>定义了数据类型</li><li>字段，倒排索引相关设置</li></ul><p><strong>Mapping会把JSON文档映射成为Lucene所需要的扁平格式</strong></p><p><strong>一个Mapping属于一个索引的Type</strong></p><ul><li>每个文档都属于一个Type</li><li>一个Type有一个mapping定义</li><li>7.0开始，不需要再mapping定义中指定type信息</li></ul><h5 id="7-9-1-字段的数据类型"><a href="#7-9-1-字段的数据类型" class="headerlink" title="7.9.1 字段的数据类型"></a>7.9.1 字段的数据类型</h5><ul><li>简单类型<ul><li>Text&#x2F;keyword</li><li>Date</li><li>Inteager&#x2F;Floating</li><li>Boolean</li><li>IPv4 &amp; ipv6</li></ul></li><li>复杂类型-对象和嵌套对象<ul><li>对象类型</li><li>嵌套类型</li></ul></li><li>特殊类型<ul><li>geo_point</li><li>geo_shape</li><li>percolator</li></ul></li></ul><h5 id="7-9-2-Dynamic-Mapping"><a href="#7-9-2-Dynamic-Mapping" class="headerlink" title="7.9.2 Dynamic Mapping"></a>7.9.2 Dynamic Mapping</h5><ul><li>再写入文档的时候如果数据不存在，就会自动创建索引</li><li>Dynamic Mapping的机制，使得我们无需手动定义Mapping，Elasticsearch会根据文档信息推算出字段的类型</li><li>但是有时候会推算的不对，例如地理位置信息</li><li>如果类型设置不对时，会导致一些功能无法正常运行，例如Range查询</li></ul><p>类型的自动识别是根据JSON的格式来识别的</p><h5 id="7-9-3-能否修改Mapping的字段类型"><a href="#7-9-3-能否修改Mapping的字段类型" class="headerlink" title="7.9.3 能否修改Mapping的字段类型"></a>7.9.3 能否修改Mapping的字段类型</h5><p>两种情况</p><ul><li>新增字段<ul><li>当Dynamic设置为true的时候，一旦有新增字段的文档写入，Mapping也同时被更新</li><li>当Dynamic设置为false时候，Mapping不会被更新，新增字段的数据无法被索引，但是信息会出现在-source中</li></ul></li><li>对已有字段，一旦数据写入就不允许修改</li><li>如果希望改变字段类型，必须Reindex API重新索引</li></ul><p>原因</p><ul><li>如果修改了字段的类型会导致已经被索引的属性无法被搜素</li><li>如果是增加新字段就不会有这样的影响</li></ul><h5 id="7-9-4-控制-Dynamic-Mappings"><a href="#7-9-4-控制-Dynamic-Mappings" class="headerlink" title="7.9.4 控制 Dynamic Mappings"></a>7.9.4 控制 Dynamic Mappings</h5><table><thead><tr><th></th><th>true</th><th>false</th><th>strict</th></tr></thead><tbody><tr><td>文档可索引</td><td>yes</td><td>yes</td><td>no</td></tr><tr><td>字段可索引</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>Maping可更新</td><td>yes</td><td>no</td><td>no</td></tr></tbody></table><p>当Dynamic1设置成fasle的时候，存在新增的字段的数据写入，该数据可以被索引，但是新增的字段被丢弃</p><p>当设置成strict模式时候，数据写入直接出错</p><p><strong>测试</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT dynamic_mappingtest/_doc/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;newField&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;value&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-comment">// 新建了一个文档</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT dynamic_mappingtest/_mapping<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;dynamic&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-keyword">false</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-comment">// 设置dynamic为false</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT dynamic_mappingtest/_doc/<span class="hljs-number">10</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;value&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-comment">// 在创建一个文档，并根据name进行搜索</span><br>POST dynamic_mappingtest/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-comment">// 搜索结果为空</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;took&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">453</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;timed_out&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;total&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;successful&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;skipped&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;failed&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;hits&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;total&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;value&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;relation&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eq&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;max_score&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-keyword">null</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;hits&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-comment">// 但是数据确是存在的</span><br>GET dynamic_mappingtest/_doc/<span class="hljs-number">10</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dynamic_mappingtest&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;_doc&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;10&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_seq_no&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_primary_term&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;found&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_source&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>如果设置成严格模式strict</p><p>那么新增字段就会被拒绝</p><h5 id="7-9-5-如何显示的定义一个Mapping"><a href="#7-9-5-如何显示的定义一个Mapping" class="headerlink" title="7.9.5 如何显示的定义一个Mapping"></a>7.9.5 如何显示的定义一个Mapping</h5><p>我们在创建索引的时候可以定义mapping</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT createMapping<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>控制当前字段是否可以被索引</strong></p><p>index</p><ul><li>默认为true，如果设置成false，该字段不可被搜索</li></ul><p>index Options</p><ul><li>Es提供了四种不同级别的Index Options配置，可以控制倒排索引记录的内容<ul><li>docs 记录docid</li><li>freqs 记录docid 和 trem frequencies 此频</li><li>position 记录 doc id trem frequencies term position </li><li>offsets 记录 文档id  词频 位置 偏移量</li></ul></li><li>text类型默认记录position 其他默认为dics</li><li>记录内容越多，占用存储空间越大</li></ul><p><strong>如果需要对Null值实现搜索</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">null_value<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;NULL&quot;</span><br></code></pre></td></tr></table></figure><h5 id="7-9-5-多字段类型"><a href="#7-9-5-多字段类型" class="headerlink" title="7.9.5 多字段类型"></a>7.9.5 多字段类型</h5><p>我们在创建索引的时候可以为一个字段增加一个默认的子字段</p><ul><li>多字段特性<ul><li>厂商名称实现精确匹配</li><li>增加一个keyword字段</li></ul></li><li>使用不同的analyzer<ul><li>不同语言</li><li>pinyin字段的搜索</li><li>还支持为搜索和索引指定不同的analyzer</li></ul></li></ul><p><strong>精确值和全文本搜索</strong></p><p>精确值包括数字、日期、具体的一个字符串吧</p><ul><li>对应Elasticsearch中的keywords</li></ul><p>全文本、非结构化的文本数据</p><ul><li>elasticsearch 中的text</li></ul><p>精确值是不允许被倒排索引的</p><h5 id="7-9-6-配置自定义的Analyzer"><a href="#7-9-6-配置自定义的Analyzer" class="headerlink" title="7.9.6 配置自定义的Analyzer"></a>7.9.6 配置自定义的Analyzer</h5><p>当ES自带的分词器无法满足时，我们可以通过组合自定义分词器</p><p><strong>Character Filters</strong></p><ul><li>在分词之前对文本进行处理，例如增加删除及替换字符串，可以配置董哥Character Filters，会影响到分词的position和offset信息</li><li>一些自带的 Character Filters<ul><li>html strip 去除html标签</li><li>mapping 字符串替换</li><li>Pattern replace 正则匹配替换</li></ul></li></ul><p><strong>Tokenizer</strong></p><p>将原始的文本按照一定的规则切分为词</p><p>ES内置的Tokenizers</p><ul><li>whitespace 空格分词</li><li>stanadard 默认分词</li></ul><p><strong>Token Filters</strong></p><ul><li>将Tokenizer输出的单词进行增加修改和删除</li><li>自带的Token Filters<ul><li>Lowercase stop synonym</li></ul></li></ul><h5 id="7-9-7-Index-Template-和-Dynamic-Template"><a href="#7-9-7-Index-Template-和-Dynamic-Template" class="headerlink" title="7.9.7 Index Template 和 Dynamic Template"></a>7.9.7 Index Template 和 Dynamic Template</h5><ul><li>Index Temolates帮助我们设定Mapping 和Seting 并且按照一定的规则自动匹配到新创建的索引之上<ul><li>模板仅仅在一个索引被创建时才会产生作用，修改模板不会影响已经创建的索引</li><li>可以设定多个索引模板，这些设置会被merge在一起</li><li>可以指定order的数值，控制merging（合并）的过程</li></ul></li></ul><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E7%B4%A2%E5%BC%95%E6%A8%A1%E6%9D%BF.png"></p><h3 id="8、文档基本的CRUD-Http"><a href="#8、文档基本的CRUD-Http" class="headerlink" title="8、文档基本的CRUD-Http"></a>8、文档基本的CRUD-Http</h3><h4 id="8-1-Create"><a href="#8-1-Create" class="headerlink" title="8.1 Create"></a>8.1 Create</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT users/_create/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Jack&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Cheng&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;tags&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;sing&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;jump&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>支持根据输入的ID创建ID或者可以使用post自动创建ID</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">POST users/_doc<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Jack&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Cheng&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;tags&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;sing&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;jump&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="8-2-Get"><a href="#8-2-Get" class="headerlink" title="8.2 Get"></a>8.2 Get</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">GET users/_doc/1<br></code></pre></td></tr></table></figure><p>找到文档返回http200</p><ul><li>文档源信息<ul><li>index type</li><li>版本信息：同一个ID的文档及时被删除，Version号也会不断增加</li><li>_source中默认包含了文档的所有原始信息</li></ul></li></ul><p>找不到文档返回404</p><h4 id="8-3-update"><a href="#8-3-update" class="headerlink" title="8.3 update"></a>8.3 update</h4><p>更新分为全量更新和局部更新</p><p><strong>全量更新</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT users/_doc/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;user&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Mike&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>全量更新会把所有字段清空</p><p><strong>更新字段</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT users/_doc/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;user&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Tong&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="8-4-Bulk-API"><a href="#8-4-Bulk-API" class="headerlink" title="8.4 Bulk API"></a>8.4 Bulk API</h4><p>支持在一次API调用中，对不同的索引进行操作</p><p>支持四种类型 <strong>Index、Create、Update、Delete</strong></p><p>可以在URL中指定Index，也可以在请求的Payload中进行</p><p>操作中单条操作失败并不会影响其他操作</p><p>返回结果包括了每一条操作执行的结果</p><p><strong><code>bulk</code>对<code>JSON串</code>的有着严格的要求。每个JSON串<code>不能换行</code>，只能放在同一行，同时，<code>相邻的JSON串之间必须要有换行</code>（Linux下是\n；Window下是\r\n）。bulk的每个操作必须要<code>一对JSON串</code>（delete语法除外）。</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">POST _bulk<br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;user&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;user&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;delete&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;user&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;create&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;user&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;user&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;tangcheng&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">18</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>以上是代表了一个bulk操作</p><h4 id="8-5-Mget-API"><a href="#8-5-Mget-API" class="headerlink" title="8.5 Mget API"></a>8.5 Mget API</h4><p>批量读取</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">GET _mget<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;docs&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;user&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;user&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2&quot;</span><span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="9、倒排索引和分词器"><a href="#9、倒排索引和分词器" class="headerlink" title="9、倒排索引和分词器"></a>9、倒排索引和分词器</h3><h4 id="9-1-什么是倒排索引"><a href="#9-1-什么是倒排索引" class="headerlink" title="9.1 什么是倒排索引"></a>9.1 什么是倒排索引</h4><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.png"></p><p>正排索引就相当于我们书籍的目录</p><p>倒排索引就是利用分词，将词语在哪个文档中进行标注，这就是倒排索引</p><p><strong>倒排索引的核心组成</strong></p><p>倒排索引包含两个部分</p><ul><li>单词词典：记录所有文档的单词，记录单词到倒排列表的关联关系<ul><li>单词词典一般比较大，可以通过b+树或者哈希拉链法实现，以满足高性能的插入和排序</li></ul></li><li>倒排列表记录了单词对应的文档集合，由倒排索引项组成<ul><li>倒排索引项<ul><li>文档ID：记录出现这个单词的文档的id</li><li>词频：记录该单词出现的次数用于相关性评分</li><li>位置：单词在文档中分词的位置，用于语句搜索</li><li>偏移：记录单词开始结束的位置用于高亮显示</li></ul></li></ul></li></ul><p>Elasticsearch的JSON文档中每个字段都有自己的倒排索引</p><p>可以指定对某些字段不做索引</p><ul><li>优点：节省存储空间</li><li>缺点：字段无法被搜素</li></ul><h4 id="9-2-Analyzer分词器"><a href="#9-2-Analyzer分词器" class="headerlink" title="9.2 Analyzer分词器"></a>9.2 Analyzer分词器</h4><p>Analysis 文本分析是把全文本转换一系列单词（term&#x2F;token）的过程也叫做分词</p><p>Analysis 是通过Analyzer实现的，可以使用Elsaticsearch内置的分析器或者按需定制化分析器</p><p>除了在数据写入的时候需要应用分析器对查询语句进行分析</p><p> <strong>Elasticsearch的内置分词器</strong></p><ul><li><strong>Standard Analyzer</strong> 默认分词器，按词切分小写处理</li><li><strong>Simple Analyzer</strong> 按照非字母切分，小写处理</li><li><strong>Stop Analyzer</strong> 小写处理，停用词过滤</li><li><strong>Whitespace Analyzer</strong> 按照空格切分，不转小写</li><li><strong>Keyword Analyzer 不分词</strong>，直接将输入当作输出</li><li><strong>Patter Analyze</strong>r 正砸表达式，默认\W+ 分字符分割</li><li><strong>Language</strong> 提供了30多种常见语言的分词器</li><li><strong>Customer Analyzer</strong> 自定义分词器</li></ul><h5 id="9-1-analyzer-API"><a href="#9-1-analyzer-API" class="headerlink" title="9.1 _analyzer API"></a>9.1 _analyzer API</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /_analyze<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;standard&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;hello my name is cheng&quot;</span><br><span class="hljs-punctuation">&#125;</span><br>POST book/_analyze<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;name&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Bootstrap 开发指南&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>利用analyzer APi可以’</p><ul><li>指定Analyzer进行测试</li><li>指定索引的字段进行测试</li><li>自定义分词器进行测试</li></ul><h5 id="9-2-standard"><a href="#9-2-standard" class="headerlink" title="9.2 standard"></a>9.2 standard</h5><p>默认分词器，按照小写处理</p><h5 id="9-3-Simple"><a href="#9-3-Simple" class="headerlink" title="9.3 Simple"></a>9.3 Simple</h5><p>对非字母进行去除</p><p>小写处理</p><h5 id="9-4-whitespace"><a href="#9-4-whitespace" class="headerlink" title="9.4 whitespace"></a>9.4 whitespace</h5><p>按照空格进行切分</p><h5 id="9-5-stop-Analyzer"><a href="#9-5-stop-Analyzer" class="headerlink" title="9.5 stop Analyzer"></a>9.5 stop Analyzer</h5><p>相比于Simple Analyzer</p><p>多了stop filter</p><p>会把暂停此去除</p><h5 id="9-6-keyword-Anlyzer"><a href="#9-6-keyword-Anlyzer" class="headerlink" title="9.6 keyword Anlyzer"></a>9.6 keyword Anlyzer</h5><p>不做任何分词处理</p><h5 id="9-7-Pattern-Analyzer"><a href="#9-7-Pattern-Analyzer" class="headerlink" title="9.7 Pattern Analyzer"></a>9.7 Pattern Analyzer</h5><p>通过正则表达式进行分词</p><p>默认是非字母</p><h5 id="9-8-中文分词的难点"><a href="#9-8-中文分词的难点" class="headerlink" title="9.8 中文分词的难点"></a>9.8 中文分词的难点</h5><p>中文句子切分成为一个个的词</p><p>英文中单词又自然的空格作为分割</p><h5 id="9-9-ICU-Analyzer"><a href="#9-9-ICU-Analyzer" class="headerlink" title="9.9 ICU Analyzer"></a>9.9 ICU Analyzer</h5><p>提供了更好的unicode支持亚洲语言</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">POST /_analyze<br>&#123;<br>  &quot;analyzer&quot;: &quot;icu_analyzer&quot;,<br>  &quot;text&quot;:&quot;这个苹果不大好吃&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="9-10-IK分词器"><a href="#9-10-IK分词器" class="headerlink" title="9.10 IK分词器"></a>9.10 IK分词器</h5><ul><li>支持自定义词库，支持热更新分词字典</li></ul><h5 id="9-11-THULAC"><a href="#9-11-THULAC" class="headerlink" title="9.11 THULAC"></a>9.11 THULAC</h5><p>清华大学自然语言处理和社会人文计算实验室的一套中文分词器</p><h3 id="10-Search-Api"><a href="#10-Search-Api" class="headerlink" title="10 Search Api"></a>10 Search Api</h3><p>在Elasticsearch搜索API中分为</p><p>URL search</p><ul><li>在url中使用参数</li></ul><p>Request Body Search</p><ul><li>利用json进行更加完备的搜索</li></ul><h4 id="10-1-URL查询"><a href="#10-1-URL查询" class="headerlink" title="10.1 URL查询"></a>10.1 URL查询</h4><ul><li>使用q指定查询字符串</li><li>query string syntax kv键值对</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -xGet<br>&quot;ip:port/index/_search?q=name:tangcheng&quot;<br></code></pre></td></tr></table></figure><h4 id="10-2-Request-Body"><a href="#10-2-Request-Body" class="headerlink" title="10.2 Request Body"></a>10.2 Request Body</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">curl -xGet<br><span class="hljs-string">&quot;ip:port/index/_option&quot;</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">// 返回所有文档</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="10-3-Reponse"><a href="#10-3-Reponse" class="headerlink" title="10.3 Reponse"></a>10.3 Reponse</h4><p>发送一个请求</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /book/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;took&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;timed_out&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;total&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;successful&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;skipped&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;failed&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;hits&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;total&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;value&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;relation&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eq&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;max_score&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1.0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;hits&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>     <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;book&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;_type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;_doc&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;DJjfOIEBTe7gcc0BLJ_h&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;_score&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1.0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;_source&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;script_fields&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;my_double_field&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;script&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;lang&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;expression&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;source&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;doc[&#x27;price&#x27; * mixNum]&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;params&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;mixNum&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>                <span class="hljs-punctuation">&#125;</span><br>              <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><ul><li>took：花费的时间</li><li>total：符合条件的总文档数</li><li>hits：结果集，默认前十个文档</li><li>index 索引名</li><li>id：文档的id</li><li>score：相关度评分</li><li>source：文档的原始信息</li></ul><h4 id="10-4-URL-search详解"><a href="#10-4-URL-search详解" class="headerlink" title="10.4 URL search详解"></a>10.4 URL search详解</h4><p>Url search就是通过URL query实现搜索</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">get /movies/_search?q=2012&amp;df=title&amp;sort=year:desc&amp;from=0&amp;size=10&amp;timeout=1s<br>&#123;<br>&quot;profile&quot;:&quot;true&quot;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>q ：指定查询语句</li><li>df：默认字段，不指定时会对所有字段进行查询</li><li>Sort 排序</li><li>from size 用于分页</li><li>Profile 可以查看查询是如何被执行的</li></ul><p><strong>泛查询</strong></p><p>对_all 所有字段进行查询</p><p><strong>对于查询语语句中是否带引号</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /movies/_search?q=title<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Beautiful Mind&quot;</span><br>GET /movies/_search?q=title<span class="hljs-punctuation">:</span>Beautiful Mind<br></code></pre></td></tr></table></figure><p>以上的两个查询是不一样的</p><p><strong>对于加了引号的来说，执行的Phrase（短语）查询</strong></p><p><strong>对于不加引号的来说，执行的是Team（词项）查询</strong></p><p><strong>布尔操作</strong></p><ul><li>AND&#x2F;OR&#x2F;NOT 或者 &amp;&amp;&#x2F;||&#x2F;！<ul><li>必须大写</li><li>title:(martix NOT reloaded)</li></ul></li><li>分组<ul><li>+表示must</li><li>-表示must_not</li><li>title:(+martrix-reloaded)</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">GET /movies/_search?q=title:(Beautiful AND Mind)<br>&#123;<br>  &quot;profile&quot;: &quot;true&quot;<br>&#125;<br>// 执行的布尔查询，必须含有beautful 和 mind<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">GET /movies/_search?q=title:(Beautiful NOT Mind)<br>&#123;<br>  &quot;profile&quot;: &quot;true&quot;<br>&#125;<br>// title 包含Beautful 不包含 Mind<br></code></pre></td></tr></table></figure><p><strong>范围查询</strong></p><ul><li>区间表示：[]闭区间,{}开区间<ul><li>year：{2019 TO 2018}</li><li>year:[* TO 2018]</li></ul></li><li>算数符号<ul><li>year:&gt;2010</li><li>year:(&gt;2010 &amp;&amp; &lt;&#x3D;2018)</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">GET /movies/_search?q=year:(&gt;2012 &amp;&amp; &lt;2018)<br>&#123;<br>  &quot;profile&quot;: &quot;true&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通配符查询</strong></p><ul><li>通配符查询效率低，占用内存大不建议使用<ul><li>？代表1个字符，*代表0或多个字符<ul><li>title:mi?d</li><li>title:be*</li></ul></li></ul></li><li>正则表达<ul><li>title:[bt]oy</li></ul></li><li>模糊匹配与近似查询<ul><li>title:beautifl~1</li></ul></li></ul><h4 id="10-5-Requset-Body-Search"><a href="#10-5-Requset-Body-Search" class="headerlink" title="10.5 Requset Body Search"></a>10.5 Requset Body Search</h4><p>将查询语句通过HTTPRequest Body 发送给Elasticsearch</p><p>内部有一套 Query DSL语法</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /kibana_sample_data_ecommerce/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;from&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>以上是一个简单的reqbody</p><p><strong>一些demo</strong></p><blockquote><p>取出一些字段</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /kibana_sample_data_ecommerce/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;from&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;currency*&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>排序</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /kibana_sample_data_ecommerce/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;from&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;currency*&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;sort&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;order_date&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;desc&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>脚本字段</strong></p><p>可以使用painless脚本计算出一些新的字段出来</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">GET kibana_sample_data_ecommerce/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;script_fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;新的字段&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;script&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;lang&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;painless&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;doc[&#x27;order_date&#x27;].value + &#x27;memeda&#x27;&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>math query</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">POST movies/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Last Chrismas&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>以上搜索中，是基于单词搜索的不是基于短语搜索的，因此返回的数据中即包含Last 也包含了 Chrismas</p><p>如果要进行精确搜索，我们可以这么干</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">POST movies/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Last Christmas&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;operator&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;and&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>      <br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>Query String Query</strong></p><p>类似于 URL Query</p><p><strong>Simple Query String</strong></p><p>类似于Query String 但是会忽略错误语法，同时只支持部分查询语法，不支持 AND OR NOT</p><h3 id="11、深入搜索"><a href="#11、深入搜索" class="headerlink" title="11、深入搜索"></a>11、深入搜索</h3><h4 id="11-1-基于词项和基于全文的搜索"><a href="#11-1-基于词项和基于全文的搜索" class="headerlink" title="11.1 基于词项和基于全文的搜索"></a>11.1 基于词项和基于全文的搜索</h4><p><strong>基于Term的查询</strong></p><p>Term是表达语义的最小单位，搜索和利用统计语言模型进行自然语言处理都需要处理Term</p><p>Term的特点</p><ul><li>在ES中，对Term查询对输入不做分词，会将输入作为一个整体，在倒排索引中查找精确的词项，并且使用相关度算分公司为每个包含该词项的文档进行相关度算分</li><li>可以通过Constant Score将查询转换成一个Filtering，避免算分，并利用缓存提高性能</li></ul><p><strong>demo</strong></p><p>创建三个数据，查看结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /products/_bulk<br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;productID&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;XHDK-A-1293-#Fj3&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;desc&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;iPhone&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;productID&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;KDKE-B-9947-#kL5&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;desc&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;iPad&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;3&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;productID&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;JODL-X-1927-#pV7&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;desc&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;MBP&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>执行第一个搜索</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /products/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;desc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;iPhone&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>查询结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;took&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;timed_out&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;total&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;successful&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;skipped&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;failed&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;hits&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;total&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;value&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;relation&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eq&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;max_score&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-keyword">null</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;hits&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>为什么查询结果是空的呢，因为trem查询不会对输入结果进行分词处理，值在进行分词的时候，已经被分词器分成了小写</p><p>同样的道理，执行如下的搜索也不会查询到任何结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /products/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;productID&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;XHDK-A-1293-#Fj3&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>我们验证一下ES对结果进行标准的分词会是什么样的结果</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /_analyze<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;standard&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;XHDK-A-1293-#Fj3&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;tokens&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xhdk&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;ALPHANUM&gt;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;ALPHANUM&gt;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1293&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">7</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">11</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;NUM&gt;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;fj3&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">13</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">16</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;ALPHANUM&gt;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>可以看到，他们对term词项进行了分词变成了小写，所以无法查询</p><p><strong>解决方案</strong></p><p>使用keywords字段进行查询</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /products/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;productID.keyword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;XHDK-A-1293-#Fj3&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>就可以正确查询到结果</p><p><strong>全文本的查询流程</strong></p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%85%A8%E6%96%87%E6%9F%A5%E8%AF%A2.png"></p><p>基于全文本查询的特点</p><ul><li>索引和搜索时都会进行分词，查询字符串先传递到一个合适的分词器，然后生成一个供查询的词项列表</li><li>查询会对每个词项逐个进行底层的查询，再将结果进行合并，并且为每个文档生成一个算分</li></ul><p><strong>基于词项的查找和基于全文的查找</strong></p><ul><li>通过字段Mapping控制字段的分词</li><li>通过参数控制查询的percision</li><li>基于词项的查找使用trem</li><li>基于全文的使用match</li></ul><h4 id="11-2-结构化搜索"><a href="#11-2-结构化搜索" class="headerlink" title="11.2 结构化搜索"></a>11.2 结构化搜索</h4><p><strong>结构化搜索是值对结构化数据的搜索</strong></p><ul><li>日期、布尔类型和数字都是结构化的</li><li>文本也可以是结构化的</li></ul><p><strong>demo</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /products/_bulk<br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;productID&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;XHDK-A-1293-#Fj3&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;desc&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;iPhone&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">10</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;avaliable&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-keyword">true</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;productID&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;KDKE-B-9947-#kL5&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;desc&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;iPad&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">20</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;avaliable&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-keyword">true</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;3&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;productID&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;JODL-X-1927-#pV7&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;desc&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;MBP&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">30</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;avaliable&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-keyword">false</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>对布尔值进行结构化搜索</p><p><strong>使用trem</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /products/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;constant_score&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;avaliable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;boost&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1.2</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>term查询是包含而不是相等</strong></p><h4 id="11-3-相关性和相关性算分"><a href="#11-3-相关性和相关性算分" class="headerlink" title="11.3 相关性和相关性算分"></a>11.3 相关性和相关性算分</h4><p>搜索的相关性算分描述了一个文档和查询语句的匹配程度，ES会对每个匹配查询条件结果进行算分</p><p>打分的本质是排序，需要把最符合用户需求的文档排在前面，默认的相关性算分采用TF-IDF，现在采用了BM25</p><p><strong>词频 TF</strong></p><p>度量文档相关度的方法是求和</p><p><strong>IDF</strong></p><p>逆文档频率</p><p><strong>BM25</strong></p><h4 id="11-4-Query-和-Filter"><a href="#11-4-Query-和-Filter" class="headerlink" title="11.4 Query 和 Filter"></a>11.4 Query 和 Filter</h4><p>高级搜索功能：支持多项文本输入，针对多个字段进行搜索</p><ul><li>Query会进行相关性算分</li><li>Filter不需要算分</li></ul><p><strong>条件组合DEMO</strong></p><ul><li>假设要搜索一部电影包含了以下一些条件<ul><li>评论中包含了Guitar，用户打分高于3分，上映日期在1993与2000年之间</li></ul></li></ul><p>这个搜索包含了三个逻辑，针对了不同的字段</p><p>包含Gutar 评分大于3 上映日期在给定的范围</p><p><strong>同时包含这三个逻辑，且有比较好的性能</strong></p><p>bool Query</p><p>一个bool 查询是一个或多个查询子句的组合</p><p>总共包括四种子句，其中两种会影响算分，两种不影响蒜贩</p><table><thead><tr><th>must</th><th>必须匹配 贡献算分</th></tr></thead><tbody><tr><td>should</td><td>选择性匹配 贡献算分</td></tr><tr><td>must_not</td><td>查询子句必须不能匹配</td></tr><tr><td>filter</td><td>必须匹配但是不贡献算分</td></tr></tbody></table><p>布尔查询的例子</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /products/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;bool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;must&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;30&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;productID&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JODL-X-1927-#pV7&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;avaliable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>子查询可以任意顺序出现</li><li>可以嵌套多个查询</li><li>如果Bool查询中，没有must条件，should中必须至少满足一条查询</li></ul><p><strong>如何解决结构化查询多值字段包含而不是相等的问题</strong></p><p>多值问题在ES层面不好解决，我们可以在业务层面解决，新增一个字段，用来计数</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%A4%9A%E5%80%BC%E9%97%AE%E9%A2%98.png"></p><p><strong>查询语句的结构会影响相关度算分</strong></p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E7%9B%B8%E5%85%B3%E5%BA%A6%E7%AE%97%E5%88%86.png"></p><p><strong>我们可以通过设置boost来影响相关度算分</strong></p><p><strong>Boost 算分来进行排名</strong></p><h4 id="11-5-单字符串多字段的查询-Dis-Max-Query"><a href="#11-5-单字符串多字段的查询-Dis-Max-Query" class="headerlink" title="11.5 单字符串多字段的查询 Dis Max Query"></a>11.5 单字符串多字段的查询 Dis Max Query</h4><p>项目中我们经常要用单字符串多字段的查询</p><p>再多字段进行算分排序的时候，是单纯的求和，在出现字段竞争的时候会导致查询结果我们预期的不同</p><p><strong>通过 Tie Breaker参数调整</strong></p><p>获得最佳匹配语句的评分_source</p><p>将其他匹配语句的评分与tie_breaker相乘</p><p>对以上评分求和并规范化</p><p><strong>Multi Match</strong></p><p>单字符串多字段查询一般有三种场景</p><ul><li><p>最佳字段</p><ul><li>当字段之间相互竞争又相互关联，评分来自最佳匹配字段</li></ul></li><li><p>多数字段</p><ul><li>处理英文内容时候的一种常见手段，在主字段抽取词干加入同义词</li></ul></li><li><p>混合字段</p><ul><li>对于实体需要在多个字段中确定信息，单个字段只能匹配多的词</li></ul></li></ul><p><strong>跨字段搜索</strong></p><p>跨字段搜索主要用于位置信息搜索</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">post address/_search<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;multi_match&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Poland street W1v&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;cross_fields&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;operator&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;and&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;street&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;city&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;country&quot;</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>我们只需要将type设置成为cross_fields</p><h4 id="11-6-多语言及中文分词检索"><a href="#11-6-多语言及中文分词检索" class="headerlink" title="11.6 多语言及中文分词检索"></a>11.6 多语言及中文分词检索</h4><p>HanLP - 面向生产环境的自然语言处理包</p><p>IK分词器 - 支持字典热更新</p><p>拼音分词器</p><h3 id="12、Elasticsearch的分布式特性及分布式搜索机制"><a href="#12、Elasticsearch的分布式特性及分布式搜索机制" class="headerlink" title="12、Elasticsearch的分布式特性及分布式搜索机制"></a>12、Elasticsearch的分布式特性及分布式搜索机制</h3><h4 id="12-1-Elaticsearch的分布式特性"><a href="#12-1-Elaticsearch的分布式特性" class="headerlink" title="12.1 Elaticsearch的分布式特性"></a>12.1 Elaticsearch的分布式特性</h4><p>Elasticsearch分布式架构带来的好处</p><ul><li>存储的水平扩容，支持PB级数据</li><li>提高系统的可用性，部分节点停止服务后整个集群的服务不受影响</li></ul><p>Elasticsearch的分布式架构</p><ul><li>不同的集群通过不同的名字来区分，默认的是elasticsearch</li><li>通过配置文件修改</li></ul><p><strong>Coordingating Node</strong></p><p>是处理请求的节点叫做Coordinating Node</p><ul><li>路由请求到正确的节点，例如创建索引的请求需要路由到master节点</li></ul><p>所有的节点默认都是Coordinating Node</p><p>通过将其他类型设置成False,使其成为Dedicated Coordinating Node</p><p><strong>Data Node</strong></p><ul><li>可以保存数据的节点叫做Data Node<ul><li>节点启动后默认就是数据节点，可以设置node.data:false 禁止</li></ul></li><li>Data Node的职责<ul><li>保存分片数据，在数据拓展上起到了至关重要的作用</li></ul></li><li>通过增加数据节点，可以解决水平扩展和解决数据单点问题</li></ul><p><strong>Master Node</strong></p><p>master Node 的职责</p><ul><li>处理创建，删除索引等请求，决定分片被分配到了哪个节点，负责索引的创建于删除</li><li>维护并且更新cluster state</li></ul><p>master Node 的最佳实践</p><ul><li>master节点非常重要</li><li>为一个集群设置多个master节点，每个节点只承担Master的单一角色</li></ul><p>在生产环境中我们会配置多个Master Eligible节点，这些节点可以在必要时参选主流程成为Master节点</p><p>每个节点启动后默认就是一个Master eligible节点</p><p><strong>集群状态</strong></p><ul><li>集群状态信息维护了一个集群中必要的信息<ul><li>所有的节点信息</li><li>所有的索引和其相关的mapping</li><li>分片的路由信息</li></ul></li><li>每个节点都保存了集群的状态信息</li><li>但是只有master节点才能修改集群的状态信息并负责同步给其他节点<ul><li>因为任意节点都能修改信息会导致Cluster state信息不一致</li></ul></li></ul><p><strong>选举过程</strong></p><p>互相ping对方，node id低的会成为被选举的节点</p><p>其他节点加入集群但是不承担Master节点的角色，一旦发现被选中的主节点丢失，就会选举出新的matser</p><p><strong>脑裂问题</strong></p><p>网络问题导致存在两个master问题</p><p>限定选举条件，设置仲裁，只有当master eligible节点数大于quorum时才会进行选举，也就是过半机制</p><p>从7.0开始就无需进行这样的配置了</p><h4 id="12-2-分片和集群的故障转移"><a href="#12-2-分片和集群的故障转移" class="headerlink" title="12.2 分片和集群的故障转移"></a>12.2 分片和集群的故障转移</h4><p><strong>分片是Elasticsearch分布式存储的基石</strong></p><p>分片分为主分片和副本分片</p><p>通过主分片将数据分布在所有的节点上</p><ul><li>主分片将一份索引的数据分散在多个数据节点上，实现存储的水平扩展</li><li>主分片数在索引创建时指定，后续默认不能修改，如要修改，需要重建索引</li></ul><p>副本分片主要是确保数据可用性</p><p>通过引入副本分片提高数据可用性，一旦主分片丢失，副本分片可以Promote成为主分片，副本分片数目可以动态调整，每个节点上都有完备的数据，如果不设置副本分片，一旦节点出现硬件故障，就有可能造成数据丢失</p><p>提升系统的读取性能</p><p>副本分片是由主分片同步，通过支持增加Replica个数，一定程度可以提高读取的吞吐量</p><p><strong>分片数的设定</strong></p><p>主分片数过小，如果一个索引增长很快，集群无法通过增加节点实现对这个索引的数据扩展</p><p>主分片数设置过大导致单个shard容量很小，引发一个节点上有过多的分片，影响性能</p><p>副本分片设置过多，会降低集群整体的写入性能</p><p><strong>例子</strong></p><p>在单节点集群的时候，设置主分片为3 副本分片是1</p><ul><li>副本分片无法分片，集群状态是黄色的</li></ul><p>增加一个数据节点后</p><ul><li>集群状态变为绿色</li><li>集群具备了故障转移的能力</li></ul><p>再次增加一个数据节点</p><ul><li>主分片和副本分片会进行重新的分配</li><li>通过增加节点，提高集群的计算能力</li></ul><p><strong>故障转移</strong></p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.png"></p><ul><li>一个Index，设置了三个主分片，一个副本分片</li><li>node1是master节点，节点以外的出现了故障</li><li>node2成为了master节点</li><li>r0 和 r1 重新分配，集群变绿</li></ul><p><strong>集群健康状态</strong></p><ul><li>green 集群监控</li><li>yellow 集群亚健康，主分片可用部分副本分片不可用</li><li>red 不健康状态，部分主分片不可用</li></ul><p><strong>测试</strong></p><p>集群初始状态拥有三个节点，一个索引有三个主分片一个副本分片</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E6%B5%81%E7%A8%8B1.png"></p><p>关掉一台机器，此时集群节点变为黄色</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%8F%98%E6%88%90%E9%BB%84%E8%89%B2.png"></p><p>稍等会故障转移处理完毕</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E4%BF%AE%E5%A4%8D%E5%AE%8C%E6%AF%95.png"></p><h4 id="12-3-文档分布式存储"><a href="#12-3-文档分布式存储" class="headerlink" title="12.3 文档分布式存储"></a>12.3 文档分布式存储</h4><p>文档会存储在具体的某个主分片和某个副本分片上</p><p>例如文档1会存储在P0分片和R0分片上</p><p><strong>文档到分片的映射算法</strong></p><ul><li>确保文档能够均匀分布在所用分片上，充分利用硬件资源，避免机器空闲</li><li>潜在的算法<ul><li>随机</li><li>维护文档到分片的映射关系，当文档数据量大的时候维护成本高</li><li>实时计算，太勇敢文档自动算出需要去哪个分片获取数据</li></ul></li><li>ES的算法<ul><li>利用hash算法确认文档在哪个分片上</li><li>设置index Seting后，主分片数就不可以随意修改了</li></ul></li></ul><p><strong>更新文档的流程</strong></p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E6%9B%B4%E6%96%B0%E6%96%87%E6%A1%A3%E7%9A%84%E6%B5%81%E7%A8%8B.png"></p><ol><li>客户端发发起一个请求</li><li>进行hash运算</li><li>路由到所在的分片上</li><li>删除</li><li>新建</li><li>返回</li><li>响应</li></ol><h4 id="12-4-分片的生命周期"><a href="#12-4-分片的生命周期" class="headerlink" title="12.4 分片的生命周期"></a>12.4 分片的生命周期</h4><p><strong>分片的内部原理</strong></p><p>分片是ES中的最小工作单元</p><p>为什么ES的搜索是近实时的 1s后被搜到</p><p>ES如何保证在断电时也不丢失数据</p><p>删除文档为什么不会立刻释放空间</p><p><strong>倒排索引的不可变性</strong></p><p>倒排索引一旦生成不可更改</p><p>不可变性带来的好处</p><ul><li>无需考虑并发写的问题，避免了锁机制带来的性能问题</li><li>一旦读入内核的文件系统缓存，便停留在了那里，只要文件系统有足够的空间，大部分请求就会请求直接内存，不会命中磁盘提升了很大的性能</li><li>缓存容易生成和维护，数据可以被压缩</li></ul><p>但是不可变性带来的调整，如果需要让一个文档可以被搜索，需要重建整个索引</p><p><strong>Lucene Index</strong></p><p>在lucnen中，单个倒排索引文件被称为Segment，Seg是自包含的不可变更的，多个Segment汇总在一起成为Lucene的Index，其对应的就是ES中的Shard</p><p>当有新的文档写入的时候就会生成新的Segment，查询的时候会查询所有的Segment，并对结果进行汇总</p><p>删除文档的信息保存在.del文件中</p><p><strong>什么是Refresh</strong></p><p>将Index buffer写入Segment的过程叫做Refresh，Refresh不执行fsync操作</p><p>Refresh频率默认1s发生一次</p><p>如果系统当中有大量数据写入就会产生很多的Segement</p><p>Indexbuffer写满后也会触发refresh</p><p><strong>什么是Transaction Log</strong></p><p>虽然我们执行了Refresh，但是数据还是在文件系统的缓存当中的，所以有了transaction Log机制，每个分片都有一个transaction log</p><ul><li>文档在新加入的时候除了写道index Buffer中一份还要写道transaction里一份，而transaction log默认是5s执行一次或者在一个变更球球完成后刷一个盘</li></ul><p><strong>什么是Flush</strong></p><ul><li>调用Refresh、Index Buffer清空并且Refresh</li><li>调用fsync将缓存中的segments写入磁盘</li><li>清空Transaction Log</li><li>默认30分钟调用一起</li><li>Transaction Log满的时候</li></ul><p>主要就是执行落盘操作</p><p><strong>Merge</strong></p><ul><li>Sgement很多需要被定期合并<ul><li>减少Segments 删除已经删除的文档</li></ul></li><li>ES和Lucene会自动进行Merge操作</li></ul><h4 id="12-5-分布式查询和相关性算分"><a href="#12-5-分布式查询和相关性算分" class="headerlink" title="12.5 分布式查询和相关性算分"></a>12.5 分布式查询和相关性算分</h4><p>Query 阶段</p><ul><li>当用户发出搜索请求到ES节点，节点收到请求后，会以Coordinating（协调）节点的身份主分片中随机选择一半的分片发出查询请求</li><li>被选中分片执行查询和排序，然后每个分片都会返回From+SIze个排序后的文档ID和排序值，给Coordinating节点</li></ul><p>Fetch 阶段</p><ul><li>Coordinating 节点会将query阶段从买个分片获取的排序后的文档ID列表进行重排序选取From到From+size个文档的ID</li><li>然后以multi get的方式到相应的分片获取详细的文档数据</li></ul><p>Query Then Fetch潜在的问题</p><ul><li>性能问题 <ul><li>每个分片上要查询的文档的个数都是 form+size</li><li>最终协调节点要处理大量的数据</li><li>深度分页</li></ul></li><li>相关性算分问题<ul><li>每个分片都基于自己的分片上的数据进行相关度的计算，这会导致打分偏离的情况，特别是数据量很少的时候相关性算分在分片之间相互独立，当文档总数很少的情况下，如果主分片大于1，主分片数越多，相关性算分会越不准</li></ul></li></ul><p><strong>解决算分不准的方法</strong></p><ul><li>数据量不大的时候，可以将主分片数设为1<ul><li>当数据量足够大的时候，只要保证文档均匀分散在各个分片上结果一般不会出现偏差</li></ul></li><li>使用DFS Query Then Fetch<ul><li>不建议使用</li></ul></li></ul><h4 id="12-6-排序及Doc-Values-amp-Fielddata"><a href="#12-6-排序及Doc-Values-amp-Fielddata" class="headerlink" title="12.6 排序及Doc Values &amp;Fielddata"></a>12.6 排序及Doc Values &amp;Fielddata</h4><p>ES默认采用相关性算分对结构进行降序排序</p><p>可以通过设定sorting参数自行设定排序</p><p><strong>排序的过程</strong></p><ul><li>排序是针对字段原始内容进行的，倒排索引无法发挥作用</li><li>需要用到正排索引，通过文档ID和字段快速得到字段的原始内容</li><li>Elasticsearch有两种实现方法<ul><li>Fieldata</li><li>Doc Values 列式存储对Text类型无效</li></ul></li></ul><table><thead><tr><th></th><th>Doc Values</th><th>Field Data</th></tr></thead><tbody><tr><td>何时创建</td><td>和倒排索引一起创建</td><td>搜索时动态创建</td></tr><tr><td>创建位置</td><td>磁盘文件</td><td>JVM Heap</td></tr><tr><td>优点</td><td>避免大量内存占用</td><td>索引速度快不占用额外空间</td></tr><tr><td>缺点</td><td>降低索引速度，占用空间</td><td>文档过多时动态创建开销大，占用过多的Jvm Heap</td></tr><tr><td>默认值</td><td></td><td></td></tr></tbody></table><p><strong>关闭Doc Values</strong></p><ul><li>默认启用 可以通过Mapping设置关闭</li></ul><h4 id="12-7-分页和遍历"><a href="#12-7-分页和遍历" class="headerlink" title="12.7 分页和遍历"></a>12.7 分页和遍历</h4><p><strong>From&#x2F;Size</strong></p><p>默认情况下，查询按照相关度算分排序，返回前十条记录</p><p>ES天生就是分布式的，查询信息，但是数据分别保存在多个分片，多台机器上，ES天生就需要满足排序的需要，按照相关性进行算分</p><ul><li>当一个查询 From &#x3D; 990 size &#x3D; 10</li><li>会在每个分片上线获取1000个分档，最后通过Coordinating节点聚合所有的结果在返回1000条</li><li>页数越深，占用内存越多，为了避免深度分页带来的内存开销，ES有一个设定，默认限定到10000个文档</li></ul><p><strong>如何避免深度分页的问题</strong></p><p>Search After避免深度分页的问题</p><ul><li>避免深度分页性能问题，可以实时获取下一页的文档信息<ul><li>不支持指定页数，只能往下翻</li></ul></li><li>需要第一次搜索时指定sort</li></ul><p><strong>Scroll API</strong></p><ul><li>创建一个快照，有新的数据写入后无法被查到</li><li>每次查询后输入上一次的Scroll ID</li></ul><h4 id="12-8-ES的并发控制"><a href="#12-8-ES的并发控制" class="headerlink" title="12.8 ES的并发控制"></a>12.8 ES的并发控制</h4><ul><li>两个Web程序同时更新某个文档，如果缺乏有效的并发，会导致更改的数据丢失</li><li>悲观并发控制<ul><li>假定有变更冲突的可能，会对资源进行加锁，防止冲突</li></ul></li><li>乐观并发控制<ul><li>假定冲突是不会发生的，不会阻塞正在尝试的操作，如果数据在读写中被修改，更新将会失败</li><li>ES采用乐观并发控制</li></ul></li><li>内部版本控制<ul><li>低版本的es采用了version来控制</li><li>高本本使用了seqno和primary term来控制</li></ul></li></ul><h3 id="13-ES的聚合分析"><a href="#13-ES的聚合分析" class="headerlink" title="13 ES的聚合分析"></a>13 ES的聚合分析</h3><h4 id="13-1-Bucket-amp-Metric聚合分析及嵌套报告"><a href="#13-1-Bucket-amp-Metric聚合分析及嵌套报告" class="headerlink" title="13.1 Bucket &amp; Metric聚合分析及嵌套报告"></a>13.1 Bucket &amp; Metric聚合分析及嵌套报告</h4><p>Metric 一系列统计方法</p><p>Bucket 一些满足条件的文档</p><p><strong>Aggregation 的语法</strong></p><p>Aggregation属于Search的一部分，一般情况下建议将其size指定为0</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;aggregations&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;&lt;aggregation_name&gt;&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;&lt;aggrregation_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            &lt;ageeregation_body&gt;<br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>单值分析</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /monitor/_doc<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;kpiName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;温度&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">29</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json">POST monitor/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;maxValue&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;max&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;minValue&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;min&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;avgValue&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;avg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><p><strong>Bucket</strong></p><p>按照一定的规则将文档分配到不同的桶中，从而达到分类的目的，ES提供了一些常见的Bucket Aggregation</p><ul><li>Terms</li><li>数字类型<ul><li>Range &#x2F;Data Range</li></ul></li><li>支持嵌套，在桶里在做分桶</li></ul><p>如果需要对text字段做聚合分析，字段需要打开fielddata才能进行Terms Aggregation</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">POST monitor/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;search_data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;kpiName.keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>可以用size控制分桶数量</p><p><strong>demo</strong></p><p>不同指标中，数字最大的具体信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /monitor/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;kpiList&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;kpiName.keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;big_value&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;top_hits&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;sort&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;order&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;desc&quot;</span><br>              <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>优化Terms聚合性能</p><p><strong>eager_global_ordinals:true</strong></p><p><strong>Range &amp; Histogram 聚合</strong></p><ul><li>按照数字范围进行分桶</li><li>在Range Aggregation 中可以自定义key</li></ul><p>demo </p><ul><li>按照值分组后内部进行排序</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /monitor/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;value_range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;ranges&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;from&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;to&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0-100&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;kpiList&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;kpiName.keyword&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;top_three&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;top_hits&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>              <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>按照值的间隔分桶</li></ul><p>value 从0 - 100 以2为一个区间进行分割</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /monitor/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;value_list&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;histogram&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;interval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;extended_bounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;min&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;max&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="13-2-Pipline-聚合分析"><a href="#13-2-Pipline-聚合分析" class="headerlink" title="13.2 Pipline 聚合分析"></a>13.2 Pipline 聚合分析</h4><p>Pipline就是对聚合分析在做聚合</p><p>例如找出平均值最大的指标名称</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /monitor/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;kpiList&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;kpiName.keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;avg_value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;avg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;max_kpivalue&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;max_bucket&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;buckets_path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;kpiList&gt;avg_value&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><p><strong>max_bucket:最大值</strong></p><p><strong>min_bucket:最小值</strong></p><p><strong>stats_bucket:多值输出</strong></p><p>同时在内层也可以进行pipline</p><h4 id="13-3-ES的聚合作用范围和排序"><a href="#13-3-ES的聚合作用范围和排序" class="headerlink" title="13.3 ES的聚合作用范围和排序"></a>13.3 ES的聚合作用范围和排序</h4><p>ES聚合分析的默认作用范围是query的查询结果集</p><p>同时ES还支持一下方式改变聚合的作用范围</p><ul><li>Filter</li><li>Post Filter</li><li>Global</li></ul><p>使用Filter进行作用范围限定</p><p>global会逃逸query的作用范围</p><p>分桶默认是按照聚合的总数排序，也可以自定义排序规则</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /monitor/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;kpiList&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;kpiName.keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;order&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;_key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;asc&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;avg_value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;avg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="13-4-ES分析原理及精准度"><a href="#13-4-ES分析原理及精准度" class="headerlink" title="13.4 ES分析原理及精准度"></a>13.4 ES分析原理及精准度</h4><p>分布式系统近似统计算法</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/es%E8%AE%A1%E9%87%8F%E7%AE%97%E6%B3%95.png"></p><p>分布式系统中，实时性数据量精确度无法都满足</p><p>ES会损失一些精准度换取实时性</p><p><strong>MIN的聚合分析执行流程</strong></p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E8%81%9A%E5%90%88%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C.png"></p><p>ES的协同节点在收到请求后会下发到三个主分片上，三个主分片返回自己的最小值，然后通过协同节点进行计算</p><p><strong>Term Aggregation 的返回值</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;aggregations&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;kpiList&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>     <span class="hljs-attr">&quot;doc_count_error_upper_bound&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;sum_other_doc_count&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;buckets&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>       <span class="hljs-punctuation">&#123;</span><br>         <span class="hljs-attr">&quot;key&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;温度&quot;</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;doc_count&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;avg_value&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>           <span class="hljs-attr">&quot;value&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">25.25</span><br>         <span class="hljs-punctuation">&#125;</span><br>       <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-punctuation">&#123;</span><br>         <span class="hljs-attr">&quot;key&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;湿度&quot;</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;doc_count&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;avg_value&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>           <span class="hljs-attr">&quot;value&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">24.5</span><br>         <span class="hljs-punctuation">&#125;</span><br>       <span class="hljs-punctuation">&#125;</span><br>     <span class="hljs-punctuation">]</span><br>   <span class="hljs-punctuation">&#125;</span><br> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在里面有两个参数</p><p><strong>doc_count_error_upper_bound</strong>:代表没有在这次聚合中返回，但是可能潜在的聚合结果</p><p><strong>sum_other_doc_count</strong>:这次聚合中没有统计到的文档数</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%88%86%E6%A1%B6%E8%81%9A%E5%90%88%E4%B8%8D%E6%AD%A3%E7%A1%AE.png"></p><p>现象描述，数据有两个主分片，分片1返回的abc 分片2返回的abd，汇总后为abc，但是实际上正确的结果应该是abd</p><p><strong>如何解决terms不准的问题</strong></p><p>提升shard_size</p><p>Terms聚合分析不准确的原因是因为数据分散在多个分片上，CoordinatingNode无法获取数据全貌</p><p>解决方案，在数据量不大时设置主分片为1，实现准确性</p><p>解决方案2：设置shard_size参数，提高精确度</p><ul><li><p>原理：每次从shard上额外多获取数据，提升准确率</p><p>我们统计的时候可以适当的增加shard_size</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /monitor/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;kpiList&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;kpiName.keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;shard_size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">11</span><span class="hljs-punctuation">,</span> <br>        <span class="hljs-attr">&quot;order&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;_key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;asc&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;avg_value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;avg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
      <tag>搜索引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch-运维</title>
    <link href="/2022/02/07/Elasticsearch-%E8%BF%90%E7%BB%B4/"/>
    <url>/2022/02/07/Elasticsearch-%E8%BF%90%E7%BB%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch-运维"><a href="#Elasticsearch-运维" class="headerlink" title="Elasticsearch 运维"></a>Elasticsearch 运维</h2><h3 id="1、Elasticsearch的数据建模"><a href="#1、Elasticsearch的数据建模" class="headerlink" title="1、Elasticsearch的数据建模"></a>1、Elasticsearch的数据建模</h3><h4 id="1-1-嵌套数据类型"><a href="#1-1-嵌套数据类型" class="headerlink" title="1.1 嵌套数据类型"></a>1.1 嵌套数据类型</h4><p><strong>关系型数据库的范式化设计</strong></p><p><strong>第一范式：消除非主属性对部分函数的依赖</strong></p><p><strong>第二范式：消除非主要属性对键的传递函数依赖</strong></p><p><strong>第三范式：消除主属性对键的传递函数依赖</strong></p><p><strong>BC范式：主属性不依赖主属性</strong></p><p>范式化设计的主要目标式减少不必要的更新</p><p>副作用导致了查询缓慢的问题，同时越范式化，就需要join越多的表</p><p>范式化节省了存储空间，但是存储空间越来越便宜</p><p>范式减少了更新，但是读取操作更麻烦</p><p><strong>反范式化设计</strong></p><p>数据不适用关联关系，而是在文档中保存冗余的数据拷贝</p><ul><li>优点：无需处理Joins操作，数据读取性能好<ul><li>Elasticsearch通过压缩_source字段减少磁盘空间的开销</li></ul></li><li>缺点：不适合在数据频繁修改的场景</li></ul><p><strong>ES中如何处理关联管理</strong></p><p>在表设计阶段考虑反范式化的设计</p><p>ES并不擅长处理关联关系，我们一般采用以下四种方式处理关联</p><ul><li>对象类型</li><li>嵌套对象</li><li>父子关联关系</li><li>应用端关联</li></ul><p>包含对象数组的文档，搜索时会返回我们不需要的数据</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE.png"></p><p>actros的类型是一个对象数组</p><p>为什么？</p><p>ES在进行数据存储时，没有考虑内部对象之间的边界，JSON被处理成了扁平式的键值对的数据结构</p><p>当对多个字段进行查询的时候导致了以外的搜索结果</p><p>可以用Nested Data Type解决这个问题</p><p>Nested Data Type：允许对象数组中的对象被独立索引</p><p>使用nested和properties关键字，所有的actor索引分隔到多个文档</p><p><strong>对于嵌套对象分组聚合</strong></p><h4 id="1-2-文档的父子关系"><a href="#1-2-文档的父子关系" class="headerlink" title="1.2 文档的父子关系"></a>1.2 文档的父子关系</h4><p>对象和Nested对象的局限性</p><ul><li>每次更新需要重新索引整个对象，包括根对象和嵌套对象</li></ul><p>ES提供类类似于关系型数据库中的Join实现，使用Join数据类型实现，可以通过维护Parent&#x2F;Child的关系从而分离两个对象</p><ul><li>父文档和子文档是两个独立的对象</li><li>更新父文档无需重新索引子文档，子文档被添加更新或者删除也不会影响到父文档和其他字文档</li></ul><p><strong>父子关系Mapping设计</strong></p><ul><li>指明JOIN类型</li><li>Parent名称</li><li>Child名称</li><li>声明parent Child关系</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT my_blogs<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;blog_comments_relation&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;join&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;relations&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;blog&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;comment&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;content&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;text&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;keyword&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="1-3-Update-By-Query-amp-Reindex-API"><a href="#1-3-Update-By-Query-amp-Reindex-API" class="headerlink" title="1.3 Update By Query &amp; Reindex API"></a>1.3 Update By Query &amp; Reindex API</h4><p>一般在以下几种情况时，我们需要重建索引</p><ul><li>索引的mapping发生变更，字段类型更改，分词器或字典更新</li><li>索引的Setting发生变更，索引的主分片数发生改变</li><li>集群内，集群间的数据迁移</li></ul><p>ES的内置API</p><ul><li>update By query：在现有的索引上重建</li><li>Reindex：在其他索引上重建</li></ul><p><strong>demo1 为索引增加字字段</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /monitor/_update_by_query<br><br></code></pre></td></tr></table></figure><p><strong>demo2 修改字段类型</strong></p><p>ES不允许修改原有类型，只能创建新的索引使用reindex重新导入</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">post _reindex<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;source&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;blogs&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;dest&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;blogs_2&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="1-4-Ingest-Pipline-amp-Painless-script"><a href="#1-4-Ingest-Pipline-amp-Painless-script" class="headerlink" title="1.4 Ingest Pipline &amp; Painless script"></a>1.4 Ingest Pipline &amp; Painless script</h4><p>Ingest Node 是引入的一种新的节点类型，默认配置下，每一个节点都是IngestNode</p><p>具有预处理数据的能力，可拦截index或者Bulk API请求</p><p>对数据进行转换并且重新返回给index或BulkApi</p><p>例如</p><ul><li>设置默认值</li><li>支持Painless脚本对数据进行复杂的加工</li></ul><h3 id="2、ES数据保护"><a href="#2、ES数据保护" class="headerlink" title="2、ES数据保护"></a>2、ES数据保护</h3><p>ES在默认安装时没有提供安全防护</p><ul><li>server.host被配置为0.0.0.0</li></ul><p>数据安全的基本需求</p><ul><li>身份认证<ul><li>鉴定用户是否合法</li></ul></li><li>用户鉴权<ul><li>指定哪个用户可以访问哪个索引</li></ul></li><li>传输加密</li><li>日志审计</li></ul><p>免费的方案</p><ul><li>nginx反向代理</li><li>免费的Security插件<ul><li>Search Guard</li><li>ReadOnly Rest</li></ul></li><li>X-pack的Basic版</li></ul><h4 id="2-1-Authention-身份认证"><a href="#2-1-Authention-身份认证" class="headerlink" title="2.1 Authention 身份认证"></a>2.1 Authention 身份认证</h4><ul><li>认证体系的几种类型<ul><li>提供用户名和密码</li><li>提供密钥或者票据</li></ul></li><li>Realms：X-pack中的认证服务<ul><li>内置:Realms<ul><li>用户名和密码</li></ul></li></ul></li></ul><p>RBAC：</p><p>定义一个角色，并分配一组权限，权限包括索引级、字段级、集群级</p><p>ES当中的一些权限</p><p>如何打开安全控制</p><p>confg&#x2F;elasticsearch.yml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">http.cors.enabled: true<br>http.cors.allow-origin: &quot;*&quot;<br>http.cors.allow-headers: Authorization<br>xpack.security.enabled: true<br>xpack.security.transport.ssl.enabled: true<br></code></pre></td></tr></table></figure><p>设置用户名和密码</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">.\bin/elasticsearch-setup-passwords interactive<br></code></pre></td></tr></table></figure><p>修改密码</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /_security/user/elastic/_password<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;password&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;123456&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>修改kibana设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">elasticsearch.username: &quot;kibana_system&quot;<br>elasticsearch.password: &quot;123456&quot;<br></code></pre></td></tr></table></figure><h4 id="2-2-ES集群内部安全通信"><a href="#2-2-ES集群内部安全通信" class="headerlink" title="2.2 ES集群内部安全通信"></a>2.2 ES集群内部安全通信</h4><p>ES内部进行9300端口传输</p><p>为节点创建证书</p><ul><li>TLS<ul><li>TLS协议要求Trusted Certificate Authority 签发的x.509证书</li></ul></li><li>证书认证的不同级别<ul><li>Certificate 节点加入需要使用相同的CA签发的证书</li><li>Full Verification 节点加入集群需要相同的CA签发的证书，还要验证Host name或者ip地址</li><li>No Verification 任何节点都可以加入</li></ul></li></ul><p><strong>生成节点证书</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/elasticsearch-certuil ca<br></code></pre></td></tr></table></figure><p>使用ca文件为节点签发证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">elasticsearch-certuil cert --ca elasticsearch-stack-ca.p12<br></code></pre></td></tr></table></figure><p>已经拿到了证书</p><p>在config目录下创建certs目录</p><p>配置节点间通讯</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">xpack.security.transport.ssl.enabled: true<br>xpack.security.transport.ssl.verification_mode: ceritificate<br>xpack.security.transport.ssl.keystore.path: certs/node_112.p12<br>xpack.security.transport.ssl.truststore.path: certs/node_112.p12<br></code></pre></td></tr></table></figure><h4 id="2-3-ES与外部通信"><a href="#2-3-ES与外部通信" class="headerlink" title="2.3 ES与外部通信"></a>2.3 ES与外部通信</h4><p>ES只要指定了上述的内部安全机制后，就会是https的加密请求了</p><h3 id="3、ES集群的安装部署"><a href="#3、ES集群的安装部署" class="headerlink" title="3、ES集群的安装部署"></a>3、ES集群的安装部署</h3><h4 id="3-1-常见集群的部署方式"><a href="#3-1-常见集群的部署方式" class="headerlink" title="3.1 常见集群的部署方式"></a>3.1 常见集群的部署方式</h4><p>一个节点在默认情况下会同时扮演，master eligible data node 和 ingest node</p><p><strong>职责分离的好处</strong></p><ul><li>Master eligible nodes 负责集群状态的管理<ul><li>使用低配置的cpu ram 和磁盘</li></ul></li><li>data node 负责数据存储及处理客户端请求<ul><li>使用高配置的cpu，ram和磁盘</li></ul></li><li>ingest nodes 负责数据处理<ul><li>使用高配cpu 中等配置ram 低配磁盘</li></ul></li></ul><p><strong>基本部署：增加节点，水平扩展</strong></p><p>当磁盘容量无法满足需求时，可以增加数据节点，磁盘读写压力大时，增加数据节点</p><p>当系统中有大量的复杂查询及聚合的时候，增加coordinating节点，增加查询的性能</p><p><strong>异地多活</strong></p><h4 id="3-2-Hot-amp-Warm架构与Shard-Filtering"><a href="#3-2-Hot-amp-Warm架构与Shard-Filtering" class="headerlink" title="3.2 Hot &amp; Warm架构与Shard Filtering"></a>3.2 Hot &amp; Warm架构与Shard Filtering</h4><p>Hot warm Architecture</p><p>数据通常不会有update操作，适用于Time based索引数据，同时数据量比较大的场景</p><p>引入warm节点，低配大容量的机器存放老数据</p><p>如何配置冷热节点</p><p><strong>1、标记节点</strong></p><p>在配置文件中通过node.attr来标记一个节点</p><p><strong>2、将数据配置到warm节点</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT index/_settings<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;index.routing.allocation.require.my_node_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;warm&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p> RACK Awareness</p><p>ES节点可能分布于不同的机架，</p><ul><li>当一个机架断电，可能会丢失几个节点</li><li>如果一个索引的相同主分片和副本分片同时在这个机架上，就有可能导致数据的丢失</li><li>通过Rack Awareness可以尽可能的避免将同一个索引的主副分片同时分配在一个机架的节点上</li></ul><p><strong>标记节点 rack_id</strong></p><h4 id="3-3-分片的设计与管理"><a href="#3-3-分片的设计与管理" class="headerlink" title="3.3 分片的设计与管理"></a>3.3 分片的设计与管理</h4><p>7.0开始新建一个索引时默认一个主分片</p><ul><li>单个分片查询算分聚合不准的问题都可以避免</li><li>但是单个分片集群无法实现水平扩展<ul><li>及时增加新的节点，也无法实现水平扩展</li></ul></li></ul><p>如何设计分片书</p><p>当分片数&gt;节点数时</p><ul><li>一旦集群中有新的数据节点加入时，分片就可以自动分配</li><li>分片在重新分配时系统不会有downtime</li></ul><p>多分片的好处</p><ul><li>查询可以并行</li><li>数据写入可以分散到多个机器</li></ul><p>分分片带来的潜在问题</p><ul><li>每个分片是一个Lucene的索引，会使用机器的资源，过多的分片会导致额外的性能开销</li><li>每次搜索的请求需要从每个分片上获取数据</li><li>分片的Meta信息由Mater节点维护，过多会增加管理的负担，经验值，控制分片总数在10W以内</li></ul><p>从存储的物理角度看</p><ul><li>日志类应用：单个分片不要大于50gb</li><li>搜索类应用：单个分片不要超过20GB</li></ul><p>为什么要控制分片存储大小</p><ul><li>提高update性能</li><li>merge时减少所需的资源</li><li>丢失节点后快速的恢复</li></ul><p><strong>如何确定副本分片数</strong></p><p>副本分片是主分片的拷贝</p><p>提高系统可用性：相应查询请求，防止数据丢失</p><p>需要占用和主分片一样的资源</p><p>对性能的影响</p><p>副本会降低数据的索引速度，有几分副本就会有几倍的CPU资源消耗在索引上</p><p>会减缓对主分片的查询压力，但是会消耗同样的内存资源</p><ul><li>如果机器资源充分，提高副本数，可以提高整体查询qps</li></ul><p><strong>ES的分片策略会尽量保证节点上的分片大致相同</strong></p><ul><li>扩容的新节点没有数据，导致新索引集中在新的节点</li><li>热点数据过于集中会产生性能问题</li></ul><p>ES 可以调整单个节点分片总数</p><h4 id="3-4-集群的容量规划"><a href="#3-4-集群的容量规划" class="headerlink" title="3.4 集群的容量规划"></a>3.4 集群的容量规划</h4><p>一个集群共有多少个节点 一个索引要设置几个分片</p><p>做容量规划时需要考虑的因素</p><ul><li>机器的软硬件配置</li><li>单条文档的尺寸</li><li>文档的总数据量</li><li>索引的总数量</li><li>副本分片书</li><li>文档是如何写入的</li><li>文档的复杂度</li></ul><p>规划案例 基于时间序列的数据</p><p>一些特性</p><ul><li>每条数据都有时间戳：文档基本不会被更新</li><li>用户更多的会查询近期的数据，对旧的数据查询相对较少</li><li>对数据的写入性能要求比较高</li></ul><h3 id="4、-ES集群运维"><a href="#4、-ES集群运维" class="headerlink" title="4、 ES集群运维"></a>4、 ES集群运维</h3><h4 id="4-1-如何解决集群yellow-与-red的问题"><a href="#4-1-如何解决集群yellow-与-red的问题" class="headerlink" title="4.1 如何解决集群yellow 与 red的问题"></a>4.1 如何解决集群yellow 与 red的问题</h4><p>红：至少一个主分片没有分配</p><p>黄：至少一个副本没有分配</p><p>率：全部正常分配</p><p><strong>案例1：集群变红</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /_cluster/health?level=indeices<br></code></pre></td></tr></table></figure><p>查看具体哪个索引出现了问题</p><p>查看原因</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /_cluster/allocation/explain<br></code></pre></td></tr></table></figure><p><strong>分片没有被正常分配的原因</strong></p><p>集群重启或者创建节点</p><p>当一个节点离开集群之间，有索引被删除，这个节点重新回来，会导致dangling的问题</p><h4 id="4-2-如何优化Es写入的性能"><a href="#4-2-如何优化Es写入的性能" class="headerlink" title="4.2 如何优化Es写入的性能"></a>4.2 如何优化Es写入的性能</h4><p>提高写入性能的方法</p><p>写性能优化的目标：增大写吞吐量，越高越好</p><ul><li><p>客户端：多线程，批量写</p><ul><li>通过性能测试，确定最佳文档数量</li><li>多线程，需要观察是否有Http429返回，实现Retry以及线程数量的自动调节</li></ul></li><li><p>服务器端</p><ul><li>单个性能问题，往往是多个因素造成的，需要先分解问题，在单个节点上进行调整并且结合测试，尽可能压榨硬件资源，以达到最高吞吐量<ul><li>使用更好的硬件，观察CPU&#x2F;IO Block</li><li>线程切换&#x2F;堆栈情况</li></ul></li></ul></li><li><p>降低IO操作</p><ul><li>一些相关的ES配置，如Refresh interval</li></ul></li><li><p>减少不必要的分词</p></li><li><p>文档写入保证相同顺序，提高压缩率</p></li><li><p>尽可能做到写入和分片的负载均衡，实现水平扩展</p></li><li><p>调整Bulk线程池和队列</p></li></ul><p>一切优化都要基于高质量的数据建模</p><h4 id="4-3-如何提高写性能"><a href="#4-3-如何提高写性能" class="headerlink" title="4.3 如何提高写性能"></a>4.3 如何提高写性能</h4><p>数据写入的过程</p><ul><li>Refresh<ul><li>先将文档保存在Index buffer中，以refesh_interval为间隔时间，定期清空buffer生成segment，借助文件系统缓存的特性，先将segment放在文件系统缓存中，并开放查询</li></ul></li><li>Translog<ul><li>segment没有写入磁盘，即使发生了宕机重启后数据也可以恢复，默认配置每次请求都会落盘</li></ul></li><li>Flush<ul><li>删除旧的translog文件</li><li>生成segment并写入磁盘，更新commit point并写入磁盘，ES自动完成，可优化点不多</li></ul></li></ul><p>Bulk,线程池和队列大小</p><ul><li>客户端<ul><li>单个bulk请求体的数据量不要太大官方简历5-15m</li><li>写入端的bulk请求超时需要足够长，建议60s以上</li><li>写入段尽量将数据轮询打到不同节点</li></ul></li><li>服务器端</li></ul><h4 id="4-4-如何提高读性能"><a href="#4-4-如何提高读性能" class="headerlink" title="4.4 如何提高读性能"></a>4.4 如何提高读性能</h4><ul><li>尽量数据先行计算，然后保存到Elasticsearch中</li><li>尽量使用FilterContext，利用缓存机制，减少不必要的算分</li><li>结合profile，exPlainAPI分析慢查询的问题，持续优化数据模型</li><li>避免查询脚本</li><li>使用filter机制 性能可以得到很大的提升</li></ul><h4 id="4-5-集群的压力测试"><a href="#4-5-集群的压力测试" class="headerlink" title="4.5 集群的压力测试"></a>4.5 集群的压力测试</h4><p>ES Rally简介</p><ul><li><p>Elastic 官方开源，基于python 3的压力测试工具</p></li><li><p>功能介绍</p><ul><li>自动创建、配置、允许测试并且销毁ES集群</li><li>支持不同的测试数据的比较，也支持将数据导入es集群，进行二次分析</li><li>支持测试时指标数据搜集，方便对测试结果进行深度分析</li></ul></li></ul><h3 id="5、-索引管理"><a href="#5、-索引管理" class="headerlink" title="5、 索引管理"></a>5、 索引管理</h3><h4 id="5-1-Open-x2F-Close-index"><a href="#5-1-Open-x2F-Close-index" class="headerlink" title="5.1 Open&#x2F;Close index"></a>5.1 Open&#x2F;Close index</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">HEAD index // 查看索引是否存在<br>POST /test/_close<br></code></pre></td></tr></table></figure><p>关闭了的索引是无法进行查看的</p><h4 id="5-2-Shrink-Index"><a href="#5-2-Shrink-Index" class="headerlink" title="5.2 Shrink Index"></a>5.2 Shrink Index</h4><p>可以将索引的主分片数收缩到较小的值</p><p>数据量比较小，需要重新设定主分片数</p><h4 id="5-3-Split-Index"><a href="#5-3-Split-Index" class="headerlink" title="5.3 Split Index"></a>5.3 Split Index</h4><p>扩大split的分片数</p><h4 id="5-4-时间序列索引"><a href="#5-4-时间序列索引" class="headerlink" title="5.4 时间序列索引"></a>5.4 时间序列索引</h4><p>按照时间序列划分索引的好处&amp;挑战</p><p>索引生命周期常见的阶段</p><p>HOT -&gt; WARM -&gt; Cold -&gt; Delete</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
      <tag>搜索引擎</tag>
      
      <tag>集群运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO 模型</title>
    <link href="/2022/01/30/IO-%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/01/30/IO-%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="详解IO模型"><a href="#详解IO模型" class="headerlink" title="详解IO模型"></a>详解IO模型</h3><p>IO模型分为</p><ul><li>同步阻塞</li><li>同步非阻塞</li><li>多路复用</li><li>异步阻塞</li><li>异步非阻塞</li></ul><p>当我们调用channle.read或者stream,read的时候，会切换到操作系统的内核来完成真正的数据读取，数据读取分为两个阶段，分别是</p><ul><li>等待数据</li><li>复制数据</li></ul><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%AD%A5%E9%AA%A4.png"></p><p>其实IO模型的底层是如下五个模型</p><p>阻塞IO 非阻塞IO 多路复用 信号驱动 异步IO</p><p>用户空间是程序发起的用户空间，例如我们在程序中调用了Read等等，这个时候需要涉及到切换到操作系统的内核</p><ul><li>用户发起read后，read阻塞，同时内核空间也在阻塞等待数据，此时用户线程也被阻塞</li><li>非阻塞模式下<ul><li>如何调用read后没读取到数据，会一直循环，直到拿到数据</li><li>如果某一次拿到数据了，此时不会立刻返回，完成复制数据的阶段</li><li>非阻塞模式会涉及到大量的用户线程和内核线程的切换</li></ul></li><li>多路复用<ul><li>多路复用的关键在于Select</li><li>select阶段是阻塞的</li><li>read是在read阶段阻塞的</li></ul></li></ul><p><strong>多路复用比阻塞模式的优点</strong></p><p>1、阻塞IO在执行一个事件的时候无法执行另一个事件</p><p>2、多路复用一个select可以检测多个事件</p><ul><li>同步阻塞、同步非阻塞、多路复用、异步非阻塞<ul><li>同步：线程自己获取结果 一个线程负责所有的事情</li><li>异步：线程自己不去获取结果，而是由其他线程送来结果，至少两个线程</li></ul></li></ul><h5 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a>零拷贝技术</h5><p>在传统的IO模型中，例如我需要将一个文件发送到服务器上，那么他经历的过程是如下的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\学习\\代码\\javabingfa\\nettystudy\\data2.txt&quot;</span>);<br><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(file, <span class="hljs-string">&quot;rw&quot;</span>);<br><span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>)file.length()];<br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>rw.read(bytes);<br>socket.getOutputStream().write(bytes);<br></code></pre></td></tr></table></figure><p>那么他在操作系统中的流向是这样的</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E9%9B%B6%E6%8B%B7%E8%B4%9D.png"></p><p>他经过了</p><ul><li>从磁盘读取到内核缓冲区</li><li>内核缓冲区读取到用户缓冲区</li><li>用户缓冲区读取到Socket缓冲区</li><li>Socket缓冲区读取到网卡缓冲区</li></ul><p>Java本身不具备操作IO的能力，首先需要从用户态切换至内核态，将数据读取到内核缓冲区中，然后在切换回用户态，将数据从内核缓冲区读取到用户缓冲区当中这时候cpu会参与操作，DMA不会参与操作，然后在将数据放入Sockket缓冲区中，最后在切换回内核态将数据拷贝到网卡中去</p><p>以上步骤经历了四次数据的拷贝，是一个重量级操作，非常消耗时间和性能，那么怎么优化呢？</p><h5 id="NIO优化"><a href="#NIO优化" class="headerlink" title="NIO优化"></a>NIO优化</h5><p>在NIO中，我们创建bytebuffer的方法是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">allocate</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1</span>);<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><ul><li>allocate创建的buffer是存放在Java的堆内存当中的</li><li>allcateDirece创建的buff是存放在系统内存中的，但是java内存和系统内存都可以访问</li></ul><p>此时的内核缓冲区和用户缓冲区之间的拷贝就可以避免了</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%90%8C%E4%B8%80%E5%BF%AB%E5%86%85%E5%AD%98.png"></p><h5 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h5><p>在Linux2.1中引入了senfile方法，它对应到我们的Java代码中就是FileChannel的transfrom方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\学习\\代码\\javabingfa\\nettystudy\\data2.txt&quot;</span>);<br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">open</span> <span class="hljs-operator">=</span> FileChannel.open(file.toPath());<br>open.transferFrom()<br></code></pre></td></tr></table></figure><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96.png"></p><p>这一步的优化干掉了用户缓冲区，transfrom可以直接将数据从内核缓冲区拷贝到socket缓冲区，这部分由CPU参与，在拷贝到socket缓冲区后，在由DMA将数据发送到网卡</p><h5 id="再进一步优化"><a href="#再进一步优化" class="headerlink" title="再进一步优化"></a>再进一步优化</h5><p>在Linux2.4中升级了方法，还是java调用transfromto之后呢，从用户态切换到内核态，并将数据拷贝到内核缓冲区，然后在由内核缓冲区到网卡，只有少量的数据需要进入到socket缓冲区中，期间经历了一次状态切换，和两次拷贝</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E7%9B%B4%E6%8E%A5%E5%88%B0%E7%BD%91%E5%8D%A1.png"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>什么是DMA：DMA是专门处理数据传输的硬件</p><p>零拷贝不是说一次拷贝都没有，只是没有到JVM层面的拷贝</p><p>零拷贝只适合小文件</p><h5 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h5><p>netty不支持异步IO</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO模型</tag>
      
      <tag>零拷贝</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2022/01/28/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/28/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式是Java常用的设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息，过滤消息，把消息转发给委托类，以及事后处理消息等，代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正的实现服务，而是通过调用委托类的对象的相关方法来提供特定的服务，简单的说就是，我们在访问实际对象的时候，是通过代理对象来访问的，代理模式就是在访问实际对象时引入的一定城的间接性，因为这种间接性，可以附加多种用途</p><h4 id="1、静态代理"><a href="#1、静态代理" class="headerlink" title="1、静态代理"></a>1、静态代理</h4><p>静态代理就是由程序员或者特定工具自动生成的源代码，也就是在编译是就已经将接口，被代理类，代理类等确定下来了，在程序运行之前，class文件就已经生成了</p><p>在静态代理中，我们对目标对象的每个方法增强都是手动完成的，，非常不灵活，比如接口一旦需要新增方法，目标对象和代理对象都要进行修改，且麻烦，实际应用场景非常少</p><h5 id="1-1-静态代理的简单实现"><a href="#1-1-静态代理的简单实现" class="headerlink" title="1.1 静态代理的简单实现"></a>1.1 静态代理的简单实现</h5><p>静态代理模式需要有三个要素</p><ul><li>确定创建接口的具体行为</li><li>被代理对象实现接口完成具体的业务逻辑</li><li>代理类实现接口，完成委托类的预处理消息，过滤消息，把消息转发给委托类，以及事后处理消息等等</li></ul><p><strong>代理类最重要的就是有一个公共接口，一个具体类，一个代理类，代理类持有具体类的实例，代为执行具体的类的实例方法</strong></p><p>例如我需要定义一个发送短信的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sendmessage</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String mesaage)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个被代理类去实现发送短信的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendmessageImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Sendmessage</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String mesaage)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;发送短信&quot;</span> + mesaage);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个代理类去帮助被代理的类执行任务，代理类中拥有实例的被代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendmessageProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Sendmessage</span> &#123;<br>    <span class="hljs-keyword">private</span> SendmessageImpl sendmessage;<br>    SendmessageProxy(SendmessageImpl sendmessage)&#123;<br>        <span class="hljs-built_in">this</span>.sendmessage = sendmessage;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String mesaage)</span> &#123;<br>        sendmessage.sendMessage(mesaage);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">userTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">SendmessageProxy</span> <span class="hljs-variable">sendmessageProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendmessageProxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SendmessageImpl</span>());<br>        sendmessageProxy.sendMessage(<span class="hljs-string">&quot;123&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果我们想要在发送短信之前执行一些操作，那么就可以很容易的添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendmessageProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Sendmessage</span> &#123;<br>    <span class="hljs-keyword">private</span> SendmessageImpl sendmessage;<br>    SendmessageProxy(SendmessageImpl sendmessage)&#123;<br>        <span class="hljs-built_in">this</span>.sendmessage = sendmessage;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String mesaage)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;发送短息之前&quot;</span>);<br>        sendmessage.sendMessage(mesaage);<br>        System.out.println(<span class="hljs-string">&quot;发送短息之后&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、动态代理"><a href="#2、动态代理" class="headerlink" title="2、动态代理"></a>2、动态代理</h4><p>代理类在程序运行时创建的代理方式是动态代理,在上面的例子中，代理类是我们自己定义好的，在程序运行之前就已经编译完成，但是动态代理的代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的指示，动态生成的，相比于静态代理，动态大力的优势在于可以很方便的对代理类的函数进行统一的处理而不用修改每个代理类中的方法</p><p>相比于静态代理来说，动态代理更加的灵活，我们不需要针对每个目标类都单独创建一个代理类，并且不需要我们必须实现接口，我们可以直接代理实现类</p><p><strong>从JVM的角度来说，动态代理是运行时动态生成类字节码并加载到JVM当中的</strong></p><p>Spring AOP 和RPC框架都依赖了动态代理技术</p><p>就Java来说，动态代理的实现方式有很多种，比如JDK动态代理、CGLIB动态代理等等</p><h5 id="2-1-JDK动态代理机制"><a href="#2-1-JDK动态代理机制" class="headerlink" title="2.1 JDK动态代理机制"></a>2.1 JDK动态代理机制</h5><p>**在Java动态代理的机制中InvocationHandler接口和Proxy类是核心 **</p><p>Proxy类中使用频率最高的方法是 newProxyInstance(),这个方法主要用来生成一个代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span><br><span class="hljs-params">                                          Class&lt;?&gt;[] interfaces,</span><br><span class="hljs-params">                                          InvocationHandler h)</span><br></code></pre></td></tr></table></figure><ol><li>loader是类加载器，用来加载代理对象</li><li>interfaces事故被代理类实现的一些接口</li><li>h是实现了InvacationHandler接口的对象</li></ol><p>如果要实现动态代理，还必须实现InvocationHandler来自定义处理逻辑，当我们动态代理对象调用一个方法的时候，这个方法的调用就会被转发到实现InvocattionHandler接口类的invoke方法来调用</p><p><strong>如果要实现动态代理，还必须实现InvocationHandler来自定义处理逻辑，当我们的动态代理对象调用一个方法的时候，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法中来调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span><br>        <span class="hljs-keyword">throws</span> Throwable;<br>&#125;<br></code></pre></td></tr></table></figure><p>invoke方法有下面三个参数</p><ol><li>proxy: 动态生成的代理类</li><li>methond：与代理类对象调用的方法相对应</li><li>args：当前methond方法的参数</li></ol><p>也就是说，当我们通过Proxy类的newProxyInstance()创建的代理对象在嗲用方法的时候实际会调用到实现InvocationHandler接口类的invoke方法，可以在invoke方法中自定义处理逻辑</p><p><strong>JDK动态代理的使用步骤</strong></p><p>定义一个接口及实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sendmessage</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String mesaage)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendmessageImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Sendmessage</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String mesaage)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;发送短信&quot;</span> + mesaage);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义一个handler 并实现InvocationHandler 自定义invoke方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> SendmessageImpl sendmessage;<br>    SendProxy(SendmessageImpl sendmessage)&#123;<br>        <span class="hljs-built_in">this</span>.sendmessage = sendmessage;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;要执行的操作1&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(sendmessage, args);<br>        System.out.println(<span class="hljs-string">&quot;要执行的操作2&quot;</span>);<br>        <span class="hljs-keyword">return</span> invoke;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Proxy.newProxyInstance调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SendmessageImpl</span> <span class="hljs-variable">sendmessage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendmessageImpl</span>(); <span class="hljs-comment">// 被代理的类</span><br>        <span class="hljs-type">Sendmessage</span> <span class="hljs-variable">sendmessage1</span> <span class="hljs-operator">=</span> (Sendmessage)Proxy.newProxyInstance(sendmessage.getClass().getClassLoader(), sendmessage.getClass().getInterfaces(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">SendProxy</span>(sendmessage));<br>        sendmessage1.sendMessage(<span class="hljs-string">&quot;123&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">要执行的操作<span class="hljs-number">1</span><br>发送短信<span class="hljs-number">123</span><br>要执行的操作<span class="hljs-number">2</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="2-2-CGLIB动态代理机制"><a href="#2-2-CGLIB动态代理机制" class="headerlink" title="2.2 CGLIB动态代理机制"></a>2.2 CGLIB动态代理机制</h5><p>JDK动态代理有一个致命的问题就是他只能代理实现了类的接口，为了解决这个问题我们可以使用CGLIB动态代理机制来避免</p><p><strong>在CGLIB动态代理机制中，MethodInterputor接口和Enhancer是核心</strong></p><p>需要自定义MethodInterputor并且重写interput方法，interput方法用于拦截增强被代理类的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterceptor</span><br><span class="hljs-keyword">extends</span> <span class="hljs-title class_">Callback</span>&#123;<br>    <span class="hljs-comment">// 拦截被代理类中的方法</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object obj, java.lang.reflect.Method method, Object[] args,</span><br><span class="hljs-params">                               MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>obj: 被代理的对象 需要增强的对象</li><li>method：被拦截的方法</li><li>args：方法入参</li><li>methoProxy：用于调用原始方法</li></ol><p>可以通过Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是MethodInterceptor中的interput方法</p><p><strong>使用步骤</strong></p><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>定义一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sendmessage</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;messge:&quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义一个MethodInterceptor并且重写interput方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;发短信之前&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(o, objects);<br>        System.out.println(<span class="hljs-string">&quot;发短信之后&quot;</span>);<br>        <span class="hljs-keyword">return</span> o1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Enhancer类的create创建代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">// 设置类加载器</span><br>        enhancer.setClassLoader(Sendmessage.class.getClassLoader());<br>        <span class="hljs-comment">// 设置被代理类</span><br>        enhancer.setSuperclass(Sendmessage.class);<br>        <span class="hljs-comment">// 设置方法拦截器</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMethodInterceptor</span>());<br>        <span class="hljs-comment">// 创建代理类</span><br>        <span class="hljs-type">Sendmessage</span> <span class="hljs-variable">sendmessage</span> <span class="hljs-operator">=</span> (Sendmessage) enhancer.create();<br>        sendmessage.sendMessage(<span class="hljs-string">&quot;13&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>里面有三个重要的设置</p><ol><li>setClassLoader:设置类加载器</li><li>setSuperclass：设置被代理类</li><li>setCallback：设置方法拦截器</li></ol><h5 id="2-3-JDK动态代理和CGLIB动态代理对比"><a href="#2-3-JDK动态代理和CGLIB动态代理对比" class="headerlink" title="2.3 JDK动态代理和CGLIB动态代理对比"></a>2.3 JDK动态代理和CGLIB动态代理对比</h5><ol><li>JDK动态代理只能代理实现了接口的类，CGLIB可以代理未实现接口的任何类</li><li>就效率来说大部分情况是JDK的动态代理性能更加的优秀，随着JDK版本的升级，这个优势更明显</li></ol><h4 id="3、静态代理和动态代理的区别"><a href="#3、静态代理和动态代理的区别" class="headerlink" title="3、静态代理和动态代理的区别"></a>3、静态代理和动态代理的区别</h4><ol><li>灵活性来说动态代理更加的灵活，不用必须实现接口，可以直接代理类，并且不需要针对每个目标创建一个代理类，另外静态代理中接口一旦新增方法，目标对象和代理对象都要i需改，这是很麻烦的</li><li>JVM层面来说，静态代理在编译期就将接口实现类代理类这些都变成了实际的class文件，而动态代理是在运行时动态生成类字节码并加载到JVM当中的</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>动态代理</tag>
      
      <tag>静态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream流的使用</title>
    <link href="/2022/01/11/JDK1-8-Stream%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/11/JDK1-8-Stream%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h4><h5 id="1、Stream流的简介"><a href="#1、Stream流的简介" class="headerlink" title="1、Stream流的简介"></a>1、Stream流的简介</h5><blockquote><p>Stream将要处理的元素集合看成一种流，在流的过程中，借助Stream API对流中的元素进行操作，比如筛选，排序，聚合等等</p></blockquote><p>Stream可以由数组或者集合创建，对流的操作分为两种</p><ul><li>中间操作：每次返回一个新的流，可以有多个</li><li>终端操作，每隔流只能进行一次终端操作，终端操作后的流无法再次使用，终端操作会返回一个新的流</li><li>Stream的特性<ul><li>不存储数据，而是按照特定的规则对数据进行计算处理</li><li>Stream不会改变数据源，通常情况下会产生一个新的集合或者一个新的值</li><li>Strem具有延迟执行的特性，只有调用终端操作的时候，中间操作才会执行</li></ul></li></ul><h5 id="2、创建Stream流"><a href="#2、创建Stream流" class="headerlink" title="2、创建Stream流"></a>2、创建Stream流</h5><ul><li><p>通过数组创建流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">// 创建一个顺序流</span><br>Stream&lt;Integer&gt; stream = integers.stream();<br><span class="hljs-comment">// 创建一个并行流</span><br>Stream&lt;Integer&gt; integerStream = integers.parallelStream();<br></code></pre></td></tr></table></figure></li><li><p>通过Arrays.Stream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">IntStream</span> <span class="hljs-variable">stream1</span> <span class="hljs-operator">=</span> Arrays.stream(array);<br></code></pre></td></tr></table></figure></li><li><p>通过Strem的静态方法可以创建流 of()、iterate()、generate()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>Stream&lt;<span class="hljs-type">int</span>[]&gt; array1 = Stream.of(array);<br></code></pre></td></tr></table></figure></li></ul><h5 id="3、顺序流与并行流"><a href="#3、顺序流与并行流" class="headerlink" title="3、顺序流与并行流"></a>3、顺序流与并行流</h5><ul><li>stream 是顺序流</li><li>parallelStream 是并行流</li></ul><p>顺序流是由主线程按照顺序对流进行操作，并行流是内部以多线程并行的方式对流进行操作</p><p><strong>除了直接创建并行流之外，可以调用parallel()方法进行转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stream.parallel();<br></code></pre></td></tr></table></figure><h5 id="4、Stream的使用"><a href="#4、Stream的使用" class="headerlink" title="4、Stream的使用"></a>4、Stream的使用</h5><ul><li>员工类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;  <span class="hljs-comment">// 姓名</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> salary; <span class="hljs-comment">// 薪资</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age; <span class="hljs-comment">// 年龄</span><br>    <span class="hljs-keyword">private</span> String sex; <span class="hljs-comment">//性别</span><br>    <span class="hljs-keyword">private</span> String area;  <span class="hljs-comment">// 地区</span><br>&#125;<br>        List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Person&gt;();<br>        personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">8900</span>, <span class="hljs-number">22</span>,<span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">7000</span>, <span class="hljs-number">33</span>,<span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;Washington&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">7800</span>, <span class="hljs-number">44</span>,<span class="hljs-string">&quot;female&quot;</span>, <span class="hljs-string">&quot;Washington&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Anni&quot;</span>, <span class="hljs-number">8200</span>, <span class="hljs-number">55</span>,<span class="hljs-string">&quot;female&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Owen&quot;</span>, <span class="hljs-number">9500</span>, <span class="hljs-number">66</span>,<span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alisa&quot;</span>, <span class="hljs-number">7900</span>, <span class="hljs-number">77</span>,<span class="hljs-string">&quot;female&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>));<br></code></pre></td></tr></table></figure><h5 id="5、中间操作"><a href="#5、中间操作" class="headerlink" title="5、中间操作"></a>5、中间操作</h5><h6 id="5-1-filter"><a href="#5-1-filter" class="headerlink" title="5.1 filter"></a>5.1 filter</h6><p>可以对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中</p><p>例如：过滤出年龄大于30的人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">personList.stream().filter(person -&gt; person.getAge()&gt;=<span class="hljs-number">30</span>).forEach(person -&gt; System.out.println(person.toString()));<br><br></code></pre></td></tr></table></figure><h6 id="5-2-map"><a href="#5-2-map" class="headerlink" title="5.2 map"></a>5.2 map</h6><p>对流中的元素进行计算或者类型转换</p><p>例如：打印所有人的姓名 -匿名内部类写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">personList.stream().map(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Person, String&gt;() &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(Person person)</span> &#123;<br>        <span class="hljs-keyword">return</span> person.getName();<br>    &#125;<br>&#125;).forEach(System.out::println);<br><br></code></pre></td></tr></table></figure><p>lambda表达式写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">        personList.stream().map(person -&gt; person.getName()).forEach(System.out::println);<br>        personList.stream().map(person -&gt; person.getName()).map(name -&gt; name.length()).forEach(System.out::println);<br><span class="hljs-comment">// 输出每个人姓名的长度</span><br></code></pre></td></tr></table></figure><h6 id="5-3-distinct-去除重复的元素"><a href="#5-3-distinct-去除重复的元素" class="headerlink" title="5.3 distinct 去除重复的元素"></a>5.3 distinct 去除重复的元素</h6><p>&#x2F;&#x2F; 如果对比的是一个对象我们需要自己重写equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">personList.stream().distinct().forEach(System.out::println);<br></code></pre></td></tr></table></figure><h6 id="5-4-distinct-去除重复的元素"><a href="#5-4-distinct-去除重复的元素" class="headerlink" title="5.4 distinct 去除重复的元素"></a>5.4 distinct 去除重复的元素</h6><p>&#x2F;&#x2F; 如果对比的是一个对象我们需要自己重写equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">        personList.stream().distinct().forEach(System.out::println);<br>        personList.stream().map(person -&gt; person.getName()).distinct().forEach(System.out::println);<br><span class="hljs-comment">// 结合map对名字去重</span><br></code></pre></td></tr></table></figure><h6 id="5-5-sorted"><a href="#5-5-sorted" class="headerlink" title="5.5 sorted"></a>5.5 sorted</h6><p>对流中元素进行排序</p><ul><li>对于自定义类重写compare方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Person&gt;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Person person)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age - person.age;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>调用空参数sorted方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">personList.stream().distinct().sorted().forEach(System.out::println);<br></code></pre></td></tr></table></figure><ul><li>调用参方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">personList.stream().distinct().sorted((o1, o2) -&gt; o1.getAge() - o2.getAge()).forEach(System.out::println);<br><br></code></pre></td></tr></table></figure><h6 id="5-6-limit"><a href="#5-6-limit" class="headerlink" title="5.6 limit"></a>5.6 limit</h6><p>设置流的最大长度，超出部分抛弃</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">personList.stream().limit(<span class="hljs-number">3</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h6 id="5-7-skip"><a href="#5-7-skip" class="headerlink" title="5.7 skip"></a>5.7 skip</h6><p>跳过n个元素</p><p>找出年龄除了年龄最小的三个人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">personList.stream().distinct().sorted((person1,person2) -&gt;  person1.getAge() - person2.getAge()).skip(<span class="hljs-number">3</span>).forEach(System.out::println);<br><br></code></pre></td></tr></table></figure><h6 id="5-7-faltMap"><a href="#5-7-faltMap" class="headerlink" title="5.7 faltMap"></a>5.7 faltMap</h6><p>可以把一个对象转为多个对象流，针对于List<Object>这种数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">        personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alisa&quot;</span>, <span class="hljs-number">7900</span>, <span class="hljs-number">77</span>,<span class="hljs-string">&quot;female&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>,Arrays.asList(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)));<br><span class="hljs-comment">// 给person新增一个title为一个数组的标签</span><br>        personList.stream().distinct().flatMap(person -&gt; person.getTitleList().stream()).forEach(System.out::println);<br><br></code></pre></td></tr></table></figure><h5 id="6、终结操作"><a href="#6、终结操作" class="headerlink" title="6、终结操作"></a>6、终结操作</h5><h6 id="6-1-forEach"><a href="#6-1-forEach" class="headerlink" title="6.1 forEach"></a>6.1 forEach</h6><p>对流中的数据进行便利,放入新数组</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// 输出作家的名字然后放入新的数组<br>ArrayList&lt;String&gt; strings = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>personList.stream().<span class="hljs-keyword">distinct</span>().<span class="hljs-keyword">forEach</span>(person -&gt; &#123;<br>    strings.<span class="hljs-keyword">add</span>(person.getName());<br>&#125;);<br>strings.stream().<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);<br></code></pre></td></tr></table></figure><h6 id="6-2-count"><a href="#6-2-count" class="headerlink" title="6.2 count"></a>6.2 count</h6><p>计数，获取流中元素的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> personList.stream().distinct().count();<br>System.out.println(count);<br></code></pre></td></tr></table></figure><h6 id="6-3-max-amp-min"><a href="#6-3-max-amp-min" class="headerlink" title="6.3 max&amp;min"></a>6.3 max&amp;min</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; max = personList.stream().distinct().flatMap(person -&gt; person.getTitleList().stream()).distinct().max((o1, o2) -&gt; o1.length() - o2.length());<br>System.out.println(max);<br></code></pre></td></tr></table></figure><ul><li>返回值有点奇怪，稍后处理</li></ul><h6 id="6-4-collect"><a href="#6-4-collect" class="headerlink" title="6.4 collect"></a>6.4 collect</h6><p>流转为集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">        List&lt;Person&gt; collect = personList.stream().distinct().collect(Collectors.toList());<br>        collect.stream().forEach(System.out::println);<br><br><span class="hljs-comment">// 年龄转为age数组</span><br>        List&lt;Integer&gt; collect = personList.stream().distinct().map(person -&gt; person.getAge()).collect(Collectors.toList());<br>        collect.stream().forEach(System.out::println);<br>        Map&lt;String, Integer&gt; collect = personList.stream().distinct().collect(Collectors.toMap(person -&gt; person.getName(), person -&gt; person.getAge()));<br>        collect.keySet().stream().forEach(el -&gt; System.out.println(collect.get(el)));<br></code></pre></td></tr></table></figure><h6 id="6-5-anyMatch"><a href="#6-5-anyMatch" class="headerlink" title="6.5 anyMatch"></a>6.5 anyMatch</h6><p>是否有一个满足</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> personList.stream().anyMatch(person -&gt; person.getAge() &gt;= <span class="hljs-number">3</span>);<br>System.out.println(b);<br></code></pre></td></tr></table></figure><h6 id="6-6-anyMatch"><a href="#6-6-anyMatch" class="headerlink" title="6.6 anyMatch"></a>6.6 anyMatch</h6><p>是否都满足</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> personList.stream().allMatch(person -&gt; person.getAge() &gt;= <span class="hljs-number">3</span>);<br>System.out.println(b);<br></code></pre></td></tr></table></figure><h6 id="6-7-findAny"><a href="#6-7-findAny" class="headerlink" title="6.7 findAny"></a>6.7 findAny</h6><p>获取流的任意一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;Person&gt; any = personList.stream().findAny();<br>System.out.println(any);<br></code></pre></td></tr></table></figure><h6 id="6-8-findFirst"><a href="#6-8-findFirst" class="headerlink" title="6.8 findFirst"></a>6.8 findFirst</h6><p>获取第一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;Person&gt; any = personList.stream().findFirst();<br>System.out.println(any);<br></code></pre></td></tr></table></figure><p>Optional类，相当于JDK帮我们把值封装到了类中</p><h5 id="7、reduce操作-缩紧操作"><a href="#7、reduce操作-缩紧操作" class="headerlink" title="7、reduce操作(缩紧操作)"></a>7、reduce操作(缩紧操作)</h5><p>把流中的操作按照指定计算的方式返回</p><ul><li>年龄求和</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Stream流</tag>
      
      <tag>JDK1.8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程实战-线程池</title>
    <link href="/2022/01/04/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <url>/2022/01/04/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Java并发工具-线程池"><a href="#Java并发工具-线程池" class="headerlink" title="Java并发工具-线程池"></a>Java并发工具-线程池</h3><h5 id="1、自定义线程池"><a href="#1、自定义线程池" class="headerlink" title="1、自定义线程池"></a>1、自定义线程池</h5><ul><li>定义一个阻塞队列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQuene</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">producter</span> <span class="hljs-operator">=</span> lock.newCondition(); <span class="hljs-comment">// 生产 阻塞</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> lock.newCondition(); <span class="hljs-comment">// 消费 阻塞</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> caption;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockingQuene</span><span class="hljs-params">(<span class="hljs-type">int</span> caption)</span> &#123;<br>        <span class="hljs-built_in">this</span>.caption = caption;<br>    &#125;<br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; quene = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(); <span class="hljs-comment">// 定义任务队列</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeOut, TimeUnit unit)</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nacos</span> <span class="hljs-operator">=</span> unit.toNanos(timeOut);<br>            <span class="hljs-keyword">while</span> (quene.isEmpty())&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (nacos &lt;= <span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    nacos = consumer.awaitNanos(nacos);<br>                    System.out.println(nacos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> quene.removeFirst();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (quene.isEmpty())&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//System.out.println(&quot;队列是空的等待&quot;);</span><br>                    consumer.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//System.out.println(&quot;队列有值了进来干活&quot;);</span><br>            producter.signalAll();<br>            <span class="hljs-keyword">return</span> quene.removeFirst();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pull</span><span class="hljs-params">(T element)</span>&#123;<br>        <span class="hljs-comment">//System.out.println(&quot;加入了任务队列&quot;);</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (quene.size() == caption)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    producter.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            quene.addLast(element);<br>            consumer.signalAll();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> quene.size();<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>阻塞队列中用来存放即将消费的runable对象</p><ul><li>定义线程池和worker对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-keyword">private</span> BlockingQuene&lt;Runnable&gt; taskQuene; <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(); <span class="hljs-comment">// 线程队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cornSize; <span class="hljs-comment">//核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeOut; <span class="hljs-comment">// 超时时间</span><br>    <span class="hljs-keyword">private</span> TimeUnit timeUnit;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>        <span class="hljs-keyword">private</span> Runnable task;<br>        Worker(Runnable runnable)&#123;<br>            task = runnable;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = taskQuene.poll(timeOut,timeUnit)) != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    task.run();<br>                &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> cornSize, <span class="hljs-type">long</span> timeOut, TimeUnit timeUnit,<span class="hljs-type">int</span> blockCaption)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cornSize = cornSize;<br>        <span class="hljs-built_in">this</span>.timeOut = timeOut;<br>        <span class="hljs-built_in">this</span>.timeUnit = timeUnit;<br>        <span class="hljs-built_in">this</span>.taskQuene = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingQuene</span>&lt;&gt;(blockCaption);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exec</span><span class="hljs-params">(Runnable task)</span>&#123;<br>        <span class="hljs-comment">// 检查工作薪酬是不是满了</span><br>        <span class="hljs-keyword">synchronized</span> (workers)&#123;<br>            <span class="hljs-keyword">if</span> (workers.size() &gt;= cornSize)&#123;<br>                <span class="hljs-comment">//线程数满了 进入队列</span><br>               <span class="hljs-comment">// System.out.println(&quot;worker满了进入队列&quot;);</span><br>                taskQuene.pull(task);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 线程数没满</span><br>                <span class="hljs-comment">//System.out.println(&quot;新增了一个worker对象&quot;);</span><br>                <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>                worker.start();<br>                workers.add(worker);<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果阻塞队列满了会怎么样？</li></ul><blockquote><p>如果阻塞队列也满了会导致他卡在主线程，因此我们需要一个拒绝策略</p><ul><li>死等</li><li>带超时时间的</li><li>放弃任务的执行</li><li>抛出异常</li><li>让调用者自己执行任务</li></ul></blockquote><ul><li>自定义拒绝策略</li></ul><p>定义抽象接口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RegistPolity</span>&lt;T&gt;&#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">reject</span><span class="hljs-params">(BlockingQuene&lt;T&gt; quene,T task)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>添加到构造方法中，把逻辑植入拒绝判断里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPool</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPool</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS, <span class="hljs-number">3</span>,((quene, task) -&gt; &#123;<br>           quene.pull(task);<br>       &#125;));<br></code></pre></td></tr></table></figure><h5 id="2、ThreadPoolExecutor"><a href="#2、ThreadPoolExecutor" class="headerlink" title="2、ThreadPoolExecutor"></a>2、ThreadPoolExecutor</h5><ul><li>线程池的状态</li></ul><p>ThreadPoolExcutor使用一个整数位来表示线程数量和线程状态，高3为表示线程状态，低29位表示线程数量为什么这么做呢?这样就可以保证每次更新线程状态和线程数量的时候只需要进行一次CAS操作</p><p>线程池的五种状态</p><ul><li>RUNNING 正常启动状态</li><li>SHUTDOWN 温和关闭，执行完成阻塞队列中的任务</li><li>STOP 关闭，直接抛弃任务</li><li>TIDUYING 任务执行完毕，活跃线程为0即将关闭的状态</li><li>TERMINATED 终结状态</li></ul><p><strong>构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExectur</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-type">int</span> cornPoolSize // 核心线程数</span><br><span class="hljs-params">    <span class="hljs-type">int</span> maxiumPoolSize // 最大线程数</span><br><span class="hljs-params">    <span class="hljs-type">long</span> keepAlibeTime // 救急线程时间</span><br><span class="hljs-params">    TimeUnit timeunit// 时间单位</span><br><span class="hljs-params">    BlockQuene&lt;Runable&gt; workQuene // 阻塞队列</span><br><span class="hljs-params">    ThreadFactory threadFactiry // 线程工厂</span><br><span class="hljs-params">    RejectedExectutionHandler handelr // 拒绝策略</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure><ul><li>int cornPoolSize  核心线程数</li><li>int maxiumPoolSize 最大线程数</li><li>long keepAlibeTime 救急线程存活时间</li><li>TimeUnit timeunit 时间单位</li><li>BlockQuene<Runable> workQuene 阻塞队列</li><li>ThreadFactory threadFactiry 线程工厂</li><li>RejectedExectutionHandler handelr 拒绝策略</li></ul><p>当阻塞队列也满了的时候，会创建一个救急线程来救急，救急线程干完活后，到了救济线程时间后就会销毁</p><p><strong>线程池运行流程</strong></p><p>1、线程池开始的时候并没有线程，当任务交给线程池的时候，线程开始运行</p><p>2、当线程池的cornsiz满了的时候会进入到阻塞队列</p><p>3、如果选择了有界队列，那么当阻塞队列满了之后会创建最大线程数-核心线程数的救急线程来执行任务</p><p>4、如果救急线程仍然无法处理请求，那么这个时候就要执行拒绝策略</p><p>5、ThreaPoolExectur给我们提供了四种拒绝策略</p><ul><li>AbortPolicy 抛出RejectExcutionException</li><li>CallerRunPlicy 让调用者自己运行</li><li>DiscardPolicy 放弃任务</li><li>DiscardOldestPolicy 放弃队列中最早的任务本任务取而代之</li><li>Dubbo的实现，抛出日志</li><li>Netty实现 创建新的线程池</li><li>Activemq实现超时等待</li><li>PinPoint 使用了拒绝策略链</li></ul><p>6、超过核心线程会用keepAliveTime来控制</p><h5 id="3、Executors"><a href="#3、Executors" class="headerlink" title="3、Executors"></a>3、Executors</h5><h5 id="4、newFixedThreadPool"><a href="#4、newFixedThreadPool" class="headerlink" title="4、newFixedThreadPool"></a>4、newFixedThreadPool</h5><p>固定大小的线程池，适合线程数固定，执行任务长</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                     <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                     <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>创建固定大小的线程池参数只有一个核心线程数目，没有救急线程，同时阻塞队列使用的LinkBlockQuene</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>       executorService.execute(() -&gt; &#123;<br>           System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>       &#125;);<br>       executorService.execute(() -&gt; &#123;<br>           System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>       &#125;);<br>       executorService.execute(() -&gt; &#123;<br>           System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>       &#125;);<br>       executorService.execute(() -&gt; &#123;<br>           System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>       &#125;);<br></code></pre></td></tr></table></figure><ul><li>执行完成任务后不会结束程序</li><li>默认的工厂方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">DefaultThreadFactory() &#123;<br>           <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>           group = (s != <span class="hljs-literal">null</span>) ? s.getThreadGroup() :<br>                                 Thread.currentThread().getThreadGroup();<br>           namePrefix = <span class="hljs-string">&quot;pool-&quot;</span> +<br>                         poolNumber.getAndIncrement() +<br>                        <span class="hljs-string">&quot;-thread-&quot;</span>;<br>       &#125;<br></code></pre></td></tr></table></figure><h5 id="5、newCatchThreadPool"><a href="#5、newCatchThreadPool" class="headerlink" title="5、newCatchThreadPool"></a>5、newCatchThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>无参，没有核心线程，全都是救急线程意味着<ul><li>救急线程可以无限创建</li><li>每个线程存活60s</li></ul></li><li>阻塞队列是SynchronousQueue同步队列<ul><li>阻塞队列类似于一手交钱一手交货，比如有人取才可以有人放</li></ul></li><li>适用于任务数量多，执行时间短的任务</li></ul><h5 id="6、newSingleThreadExecutor"><a href="#6、newSingleThreadExecutor" class="headerlink" title="6、newSingleThreadExecutor"></a>6、newSingleThreadExecutor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>            (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>线程池中只有一个线程，固定数为1，会放入无界队列排队，任务执行完毕后唯一的线程也不会被释放</li></ul><p>为什么不自己创建一个线程呢</p><ul><li>自己创建线程执行后失败了就不会往下继续执行了，此时就i没有别的线程能够执行接下来的任务了，但是如果使用了单线程的线程池可以帮助我们创建一个新的线程来执行任务</li><li>和固定大小的线程池有什么区别呢<ul><li>固定大小的线程池返回值是线程池对象</li><li>单例的返回值是使用装饰器模式返回的线程池中的基本方法，限制返回对象暴漏的方法</li></ul></li></ul><h5 id="7、线程池API-提交任务"><a href="#7、线程池API-提交任务" class="headerlink" title="7、线程池API-提交任务"></a>7、线程池API-提交任务</h5><ul><li>execute</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">executorService.execute();<br></code></pre></td></tr></table></figure><p>执行一个任务，输入参数是Runable接口</p><ul><li>submit</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">12</span>);<br>       Future&lt;Integer&gt; future = executorService.submit(() -&gt; &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>       &#125;);<br>       <span class="hljs-keyword">try</span> &#123;<br>           System.out.println(future.get());<br>       &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>           e.printStackTrace();<br>       &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br></code></pre></td></tr></table></figure><ul><li>invokeAll 执行一组线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>        List&lt;Future&lt;Object&gt;&gt; futures = executorService.invokeAll(Arrays.asList(<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-number">1</span>);<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>                &#125;,<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-number">2</span>);<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>                &#125;,<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-number">3</span>);<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>                &#125;<br>        ));<br>        <span class="hljs-keyword">for</span> (Future f:futures<br>             ) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> f.get();<br>            System.out.println(o);<br>        &#125;<br></code></pre></td></tr></table></figure><ul><li>invokeAny 执行一组线程<ul><li>找到一个最先执行完的任务</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>        List&lt;Future&lt;Object&gt;&gt; futures = executorService.invokeAll(Arrays.asList(<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-number">1</span>);<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>                &#125;,<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-number">2</span>);<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>                &#125;,<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-number">3</span>);<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>                &#125;<br>        ));<br>        <span class="hljs-keyword">for</span> (Future f:futures<br>             ) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> f.get();<br>            System.out.println(o);<br>        &#125;<br></code></pre></td></tr></table></figure><ul><li>shutdown 将线程池状态变为shutdown 会执行完成任务<ul><li>shutdown不会阻塞线程</li><li>shudown不会接收新任务，但是已经执行的任务会执行完毕</li></ul></li><li>shutdownNow<ul><li>不会接收新任务</li><li>会将队列中的任务返回</li><li>用interput的方式中断正在执行的任务</li></ul></li><li>其他API<ul><li>isShutdown（） 查看状态</li><li>isTerminated</li><li>awaitTermination（long  timeout,Timeunit timeUnit）</li></ul></li></ul><h5 id="8、异步模式-工作线程"><a href="#8、异步模式-工作线程" class="headerlink" title="8、异步模式-工作线程"></a>8、异步模式-工作线程</h5><p>不同任务类型使用不同类型的线程池</p><h5 id="9、设置多少个线程"><a href="#9、设置多少个线程" class="headerlink" title="9、设置多少个线程"></a>9、设置多少个线程</h5><ul><li>CPU密集型运算<ul><li>线程设置为CPU核数 + 1</li></ul></li><li>IO密集型运算<ul><li>CPU不总是繁忙状态的例如执行业务计算的时候需要CPU，但是当执行远程方法，rpc调用时候包括操纵数据库的时候，就闲下来了</li><li>经验公式如下</li><li>线程数 &#x3D; 核数 * 期望利用率 *总时间&#x2F;cpu计算时间</li></ul></li></ul><h5 id="10、Timer类的缺点"><a href="#10、Timer类的缺点" class="headerlink" title="10、Timer类的缺点"></a>10、Timer类的缺点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<br>        <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;;<br>        timer.schedule(task,<span class="hljs-number">1000</span>);<br>        timer.schedule(task2,<span class="hljs-number">1000</span>);<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>Timer类会导致一个线程出现了问题，后续的线程都无法执行</p><h5 id="11、可调度任务的线程池-newScheduledThreadPool"><a href="#11、可调度任务的线程池-newScheduledThreadPool" class="headerlink" title="11、可调度任务的线程池 newScheduledThreadPool"></a>11、可调度任务的线程池 newScheduledThreadPool</h5><p>newScheduledThreadPool</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduledExecutorService</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>       scheduledExecutorService.schedule(() -&gt; &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>               System.out.println(<span class="hljs-number">1</span>);<br>           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;,<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>       scheduledExecutorService.schedule(() -&gt; &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>               System.out.println(<span class="hljs-number">1</span>);<br>           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;,<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><ul><li><p>一个任务没有正确的处理异常会不会影响第二个任务？</p><ul><li>两个任务都可以正常运行，但是无法捕获到线程池当中的异常</li></ul></li><li><p>定时执行任务</p><ul><li>每隔一秒执行一次  scheduleAtFixedRate scheduleWithFixedDelay</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduledExecutorService</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>        scheduledExecutorService.scheduleAtFixedRate(<br>                () -&gt; &#123;<br>                    System.out.println(<span class="hljs-number">1</span>);<br>                &#125;,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,TimeUnit.SECONDS<br>        );<br></code></pre></td></tr></table></figure><ul><li>如果每个任务执行时间较长，会影响到现有的线程</li><li></li></ul></li><li><p><strong>scheduleAtFixedRate和scheduleWithFixedDelay的区别</strong></p><ul><li>scheduleAtFixedRate是过了一个period后上一个线程执行完毕后立刻执行</li><li>scheduleWithFixedDelay是上一个线程结束后过了一个delay在执行</li></ul></li></ul><h5 id="12、正确处理线程池中的异常"><a href="#12、正确处理线程池中的异常" class="headerlink" title="12、正确处理线程池中的异常"></a>12、正确处理线程池中的异常</h5><ul><li>任务自身捕获异常</li><li>使用future对象</li></ul><h5 id="13、线程池的应用-定时任务"><a href="#13、线程池的应用-定时任务" class="headerlink" title="13、线程池的应用 定时任务"></a>13、线程池的应用 定时任务</h5><h5 id="14、Tomcat线程池"><a href="#14、Tomcat线程池" class="headerlink" title="14、Tomcat线程池"></a>14、Tomcat线程池</h5><h5 id="15、高级线程池ForkJoin线程池"><a href="#15、高级线程池ForkJoin线程池" class="headerlink" title="15、高级线程池ForkJoin线程池"></a>15、高级线程池ForkJoin线程池</h5>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发编程</tag>
      
      <tag>学习笔记</tag>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程实战-不可变</title>
    <link href="/2022/01/04/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/01/04/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Java并发编程实战-不可变"><a href="#Java并发编程实战-不可变" class="headerlink" title="Java并发编程实战-不可变"></a>Java并发编程实战-不可变</h3><p>可变对象在多线程下会出现错误或意想不到的异常</p><h5 id="1、享元模式"><a href="#1、享元模式" class="headerlink" title="1、享元模式"></a>1、享元模式</h5>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发编程</tag>
      
      <tag>学习笔记</tag>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
      <tag>不可变类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程实战-无锁实现</title>
    <link href="/2022/01/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <url>/2022/01/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Java并发编程实战-无锁"><a href="#Java并发编程实战-无锁" class="headerlink" title="Java并发编程实战-无锁"></a>Java并发编程实战-无锁</h3><p>在之前学的中，我们所有的保证线程安全的方式都是使用了加锁机制来实现，这样做的效率是非常低的，对于普通的取款类来说</p><ul><li>线程不安全的取款类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getYue</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">return</span> money;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">quqian</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">if</span> (money == <span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<span class="hljs-keyword">else</span> &#123;<br>           money --;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>使用sycharonize来保证线程安全</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getYue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">quqian</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-keyword">if</span> (money == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                money --;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>这两种解决办法就是悲观锁的解决方式，悲观锁意味着对所有的操作都上锁</p><p>这时候引入乐观锁CAS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">10000</span>);<br>    <span class="hljs-keyword">public</span> AtomicInteger <span class="hljs-title function_">getYue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quqian</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> money.get();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">10</span>;<br>                <span class="hljs-keyword">if</span> (money.compareAndSet(i,next))&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>        &#125;<br><br><br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="1、compareAndSet-CAS"><a href="#1、compareAndSet-CAS" class="headerlink" title="1、compareAndSet CAS"></a>1、compareAndSet CAS</h5><p>CAS就是先比较，在对比，核心思想是先记录从内存中读取到的值u，然后在进行修改</p><h5 id="2、CAS与volatile"><a href="#2、CAS与volatile" class="headerlink" title="2、CAS与volatile"></a>2、CAS与volatile</h5><p>cas必须借助volatile来保证可见性的前提下才能保证其每次对比的适合都能拿到最新值</p><h5 id="3、为什么无锁思想效率高"><a href="#3、为什么无锁思想效率高" class="headerlink" title="3、为什么无锁思想效率高"></a>3、为什么无锁思想效率高</h5><p>因为我们没加锁的时候，线程在高速的运行，我们加了锁之后，需要进行上下文切换唤醒等操作，线程上下文切换的成本很高，但是如果我们的cpu只有一个核心那么其实对于多线程来说也是没有意义的，依然会进行上下文切换</p><h5 id="4、CAS的特点"><a href="#4、CAS的特点" class="headerlink" title="4、CAS的特点"></a>4、CAS的特点</h5><ul><li>线程数较少，且有多个CPU支持的情况下</li><li>体现了乐观锁的思想，不怕别人来修改</li></ul><h5 id="5、原子整数"><a href="#5、原子整数" class="headerlink" title="5、原子整数"></a>5、原子整数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">100</span>);<br><span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">atomicBoolean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-type">AtomicLong</span> <span class="hljs-variable">atomicLong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">100l</span>);<br></code></pre></td></tr></table></figure><h5 id="6、相关API"><a href="#6、相关API" class="headerlink" title="6、相关API"></a>6、相关API</h5><p><strong>incrementAndGet();</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">类似于自增<br>    i++<br></code></pre></td></tr></table></figure><p><strong>getAndIncrement();</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">类似于自增<br>    i++<br></code></pre></td></tr></table></figure><p>如何进行更复杂的方法</p><p><strong>updateAndGet(IntUnaryOperator  S)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IntUnaryOperator s <span class="hljs-comment">//是一个抽象类只有一个参数</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">atomicInteger.updateAndGet((value) -&gt; &#123;<br>            value = value * <span class="hljs-number">100</span>;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">atomicInteger.updateAndGet(x -&gt; x +<span class="hljs-number">100</span>); <br>atomicInteger.getAndUpdate(x -&gt; <span class="hljs-number">100</span> *x);<br></code></pre></td></tr></table></figure><h5 id="7、原子引用类型"><a href="#7、原子引用类型" class="headerlink" title="7、原子引用类型"></a>7、原子引用类型</h5><ul><li>包装类AtomicReference</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicReference&lt;Integer&gt; threadAtomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p><strong>相关API参考基本类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicReference&lt;Integer&gt; threadAtomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br>        threadAtomicReference.set(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> threadAtomicReference.updateAndGet(integer1 -&gt; integer1 + <span class="hljs-number">3</span>);<br>        System.out.println(integer);<br></code></pre></td></tr></table></figure><h5 id="8、ABA问题"><a href="#8、ABA问题" class="headerlink" title="8、ABA问题"></a>8、ABA问题</h5><p>在CAS中会遇到ABA问题</p><p>CAS中实现的方式是进行值的对比</p><p>线程1：A-&gt;B B-&gt;A</p><p>线程2：A-C</p><p>线程1执行了A到B、B到A的过程，线程2此时读取的是A，但是他不知道中途被改变过，也修改成功了</p><p>因此这就是ABA问题，要解决这种问题就需要引入版本号机制</p><h5 id="9、AtomicStampedReference"><a href="#9、AtomicStampedReference" class="headerlink" title="9、AtomicStampedReference"></a>9、AtomicStampedReference</h5><p>AtomicStampedReference就是用来解决这个问题的，在这里面引入了版本号机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicStampedReference&lt;Double&gt; doubleAtomicStampedReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;Double&gt;(<span class="hljs-number">2.3</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> doubleAtomicStampedReference.getStamp();<br>        System.out.println(<span class="hljs-string">&quot;版本号&quot;</span> + stamp);<br>        doubleAtomicStampedReference.compareAndSet(doubleAtomicStampedReference.getReference(),<span class="hljs-number">3.3</span>,stamp,stamp + <span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-string">&quot;新的版本号&quot;</span> + doubleAtomicStampedReference.getStamp());<br></code></pre></td></tr></table></figure><p><strong>相关API参考基本类型的API</strong></p><h5 id="10、AtomicMarkableReference"><a href="#10、AtomicMarkableReference" class="headerlink" title="10、AtomicMarkableReference"></a>10、AtomicMarkableReference</h5><p>AtomicStampedReference中我们需要关注版本号进行判断，如果我们的需求中只需要关心是否被修改，不需要关心版本号怎么做呢，这个时候我们就可以使用较为轻量级的AtomicMarkableReference来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicMarkableReference&lt;Integer&gt; inteager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>&lt;&gt;(<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br>System.out.println(<span class="hljs-string">&quot;是否被修改了&quot;</span> + inteager.isMarked());<br>inteager.compareAndSet(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">true</span>);<br>System.out.println(<span class="hljs-string">&quot;是否被修改了&quot;</span>+inteager.isMarked());<br></code></pre></td></tr></table></figure><p>AtomicMarkableReference只关系是否修改，不关心版本号</p><h5 id="11、原子数组"><a href="#11、原子数组" class="headerlink" title="11、原子数组"></a>11、原子数组</h5><ul><li>AtomicIntegerArray：原子更新整型数组里的元素</li><li>AtomicLongArray：原子更新长整型数组里的元素。</li><li>AtomicReferenceArray：原子更新引用类型数组里的元素。</li></ul><h5 id="12、字段更新器"><a href="#12、字段更新器" class="headerlink" title="12、字段更新器"></a>12、字段更新器</h5><ul><li><p>AtomicReferenceFieldUpdater &#x2F;&#x2F; 域 字段</p></li><li><p>AtomicIntegerFieldUpdater</p></li><li><p>AtomicLongFieldUpdater</p></li><li><p>使用样例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">yinyongleixing</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">student</span>();<br>        AtomicReferenceFieldUpdater&lt;student, String&gt; name =<br>                AtomicReferenceFieldUpdater.newUpdater(student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> name.compareAndSet(student, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;更新结果&quot;</span> + result);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span>&#123;<br>    <span class="hljs-keyword">volatile</span> String  name;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="13、原子累加器"><a href="#13、原子累加器" class="headerlink" title="13、原子累加器"></a>13、原子累加器</h5><ul><li>LongAdder()</li></ul><p><strong>原理：</strong></p><ul><li><p>CAS锁</p><blockquote><p>只有执行从0设置为1的时候才可以加锁成功</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>           <span class="hljs-keyword">if</span> (flag.compareAndSet(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))&#123;<br>               System.out.println(<span class="hljs-string">&quot;加锁成功&quot;</span>);<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>&#123;<br>       flag.set(<span class="hljs-number">0</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>LongAdder原理</li></ul><p>LongAddr有三种重要的域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//累加单元数组 懒惰初始化</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br><span class="hljs-comment">//基础之，如果没有竞争，则用cas累加</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> base;<br><span class="hljs-comment">// 在cells创建或者扩容时设置为1 表示加锁</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@sun</span>.misc.Contended <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span> &#123;<br>       <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<br>       Cell(<span class="hljs-type">long</span> x) &#123; value = x; &#125;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cas</span><span class="hljs-params">(<span class="hljs-type">long</span> cmp, <span class="hljs-type">long</span> val)</span> &#123;<br>           <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-built_in">this</span>, valueOffset, cmp, val);<br>       &#125;<br></code></pre></td></tr></table></figure><p>@sun.misc.Contended 注解的作用</p><p><strong>CPU内存结构</strong></p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/cpu%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"></p><ul><li>为什么要有这么多级的缓存<ul><li>读寄存器只需要一个时间周期</li><li>读取一级缓存需要3-4个</li><li>读取二级缓存10-20</li><li>读取三级缓存40-50</li><li>读取内存120-240</li></ul></li></ul><p>因为CPU和内存速度差距巨大，因此需要提前把内存中的数据提前读到CPU缓存当中去</p><p>缓存是以缓存行为单位，缓存行的大小一般是64byte 8个long</p><p>缓存行带来的问题：一个数据在多个核心之间存在副本</p><p><strong>CPU要保证数据的一致性，如果一个CPU修改了数据，那么整个缓存行都会失效</strong></p><p>那么问题就出现了，cell0和cell1的大小是24个字节，然而一个缓存行的大小是64个字节，那么会导致一个多个cell会连续存储在多个cpu的缓存行当中，如果一个缓存行被修改了，那么其余的都会失效</p><p>因此sun.misc.Contended的作用是在每一个cell前后个加128个字节的pading，这样就会不会造成缓存行失效</p><p><strong>在解释一下什么是伪共享</strong></p><p>伪共享的原理就是我们的CPU由于速度的差异，会将数据从内存中读取到cpu的缓存当中去，缓存的单位是缓存行，大小一般是64个字节，我们的cell对象一个对象是24个字节，包含16个字节的对象头加八个字节的body，那么一定会导致多个cell被读取到多个核心的缓存行当中，那么如果一个cpu修改了缓存行的数据，其他的都会失效，这就叫做缓存行伪共享，看起来是共享了，实际上并没有，最终还是要去缓存当中读取数据</p><h5 id="14、LongAdder源码剖析"><a href="#14、LongAdder源码剖析" class="headerlink" title="14、LongAdder源码剖析"></a>14、LongAdder源码剖析</h5><h5 id="15、unsafe对象"><a href="#15、unsafe对象" class="headerlink" title="15、unsafe对象"></a>15、unsafe对象</h5>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发编程</tag>
      
      <tag>学习笔记</tag>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
      <tag>无锁实现</tag>
      
      <tag>CAS</tag>
      
      <tag>原子累加器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程实战-共享模型</title>
    <link href="/2021/12/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <url>/2021/12/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Java并发编程实战-共享模型"><a href="#Java并发编程实战-共享模型" class="headerlink" title="Java并发编程实战-共享模型"></a>Java并发编程实战-共享模型</h3><h5 id="1、Java的内存模型"><a href="#1、Java的内存模型" class="headerlink" title="1、Java的内存模型"></a>1、Java的内存模型</h5><p>java的内存模型又叫做JMM，它定义了主存，工作内存抽象概念，底层对应着cpu的寄存器，缓存，硬件内存，cpu指令优化等等</p><p>JMM体现在以下几个方面</p><ul><li>原子性-保证指令不会受到上下文切换的影响</li><li>可见性-保证指令不会受到cpu缓存的影响</li><li>有序性-保证指令不会受到cpu并行优化的影响</li></ul><h5 id="2、可见性问题"><a href="#2、可见性问题" class="headerlink" title="2、可见性问题"></a>2、可见性问题</h5><p>执行以下的代码有一个现象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (flag)&#123;<br><br>            &#125;<br>        &#125;).start();<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>        flag = <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>程序却停不下来，这是为什么呢？</p><p>这就是Java的内存模型造成的</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/jmm%E4%B8%BB%E5%AD%98.png"></p><p>java的内存模型分为主存和工作内存，主存就是一些共享的信息，工作内存中是自己独有的信息</p><p>Java中的JIL编译器在发现我们频繁访问主内存中的数据的时候，就会复制一份数据到工作内存当中去</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png"></p><p>我们修改了值之后呢，也只是主内存知道了这件事情，但是工作内存却不知道</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%86%85%E5%AD%98%E4%BF%AE%E6%94%B9%E5%90%8E.png"></p><h5 id="3、Volatile关键字"><a href="#3、Volatile关键字" class="headerlink" title="3、Volatile关键字"></a>3、Volatile关键字</h5><p>Volatitle(易变的)的作用是修饰静态成员变量和成员变量，可以避免线程从工作内存中读取数据，每次都要从主存中读取数据</p><p>Volatile只能保证可见性，不能保证原子性</p><p>适合用于一个线程写一个线程读的情况</p><p><strong>为什么调用了打印语句，也可以保证可见性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">newLine</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                ensureOpen();<br>                textOut.newLine();<br>                textOut.flushBuffer();<br>                charOut.flushBuffer();<br>                <span class="hljs-keyword">if</span> (autoFlush)<br>                    out.flush();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (InterruptedIOException x) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException x) &#123;<br>            trouble = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>源码中加了锁</p><h5 id="4、两阶段终止模式优化，通过wolatile关键字"><a href="#4、两阶段终止模式优化，通过wolatile关键字" class="headerlink" title="4、两阶段终止模式优化，通过wolatile关键字"></a>4、两阶段终止模式优化，通过wolatile关键字</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Thread thread;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitor</span><span class="hljs-params">()</span>&#123;<br>       thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>           <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>               <span class="hljs-keyword">if</span> (flag)&#123;<br>                   System.out.println(<span class="hljs-string">&quot;执行监控&quot;</span>);<br>                   <span class="hljs-keyword">try</span> &#123;<br>                       TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                   &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                       e.printStackTrace();<br>                   &#125;<br>               &#125;<span class="hljs-keyword">else</span> &#123;<br>                   System.out.println(<span class="hljs-string">&quot;推出料理后事&quot;</span>);<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br>       &#125;);<br>       thread.start();<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>&#123;<br>       flag = <span class="hljs-literal">false</span>;<br>       System.out.println(flag);<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="5、犹豫模式-Balking模式"><a href="#5、犹豫模式-Balking模式" class="headerlink" title="5、犹豫模式 Balking模式"></a>5、犹豫模式 Balking模式</h5><p>指的是在做一件事情之前发现别的线程已经做了，那么自己就不做了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-keyword">if</span> (execFlag)&#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            execFlag = <span class="hljs-literal">true</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><h5 id="6、Balking模式的应用"><a href="#6、Balking模式的应用" class="headerlink" title="6、Balking模式的应用"></a>6、Balking模式的应用</h5><p>可以用在监控线程中</p><p>可以用来创建线程安全的单例模式中</p><h5 id="7、有序性"><a href="#7、有序性" class="headerlink" title="7、有序性"></a>7、有序性</h5><p>Jvm会在不影响正确性的前提下，调整语句执行顺序，例如以下的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">i = <span class="hljs-number">1</span>;<br>j = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>在cpu中我们无法明确确定执行的顺序，cpu会进行指令重排</p><p>指令重排序的前提是不能影响结果</p><h5 id="8、如何禁止指令重排序"><a href="#8、如何禁止指令重排序" class="headerlink" title="8、如何禁止指令重排序"></a>8、如何禁止指令重排序</h5><p>Volatile关键字</p><h5 id="9、Volatile原理"><a href="#9、Volatile原理" class="headerlink" title="9、Volatile原理"></a>9、Volatile原理</h5><p>系统对加了Volatile关键字的变量，在读之前会添加读屏障，在写之前会添加写屏障</p><h5 id="10、双重检验锁的单例模式"><a href="#10、双重检验锁的单例模式" class="headerlink" title="10、双重检验锁的单例模式"></a>10、双重检验锁的单例模式</h5><p>正常的懒汉式单例模式的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">private</span> Singleton <span class="hljs-title function_">instance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>)&#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了缩小sychronize的锁范围，我们可以只对初始化的过程进行加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> Singleton <span class="hljs-title function_">instance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>)&#123;<br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>                <span class="hljs-keyword">return</span> singleton;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>但是其实在多线程中，在最外层的判断中就会出现问题，第一次判断是线程不安全的，是在同步代码块外的，无法保证原子有序可见性了</p><p>解决思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> Singleton <span class="hljs-title function_">instance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>)&#123;<br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>                <span class="hljs-keyword">return</span> singleton;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br><br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发编程</tag>
      
      <tag>学习笔记</tag>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
      <tag>Volitile</tag>
      
      <tag>共享模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程实战-常见模式</title>
    <link href="/2021/12/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <url>/2021/12/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Java并发编程实战-常见模式"><a href="#Java并发编程实战-常见模式" class="headerlink" title="Java并发编程实战-常见模式"></a>Java并发编程实战-常见模式</h3><p>需求：先打印2在打印1</p><h5 id="1、wait-notify实现顺寻模式"><a href="#1、wait-notify实现顺寻模式" class="headerlink" title="1、wait notify实现顺寻模式"></a>1、wait notify实现顺寻模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">solutionOne</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 两个线程 先打印2 在打印1 wait Notify实现</span><br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (o)&#123;<br>                <span class="hljs-keyword">while</span> (!flag)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        o.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.println(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (o)&#123;<br>                System.out.println(<span class="hljs-number">2</span>);<br>                o.notifyAll();<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;);<br>        thread2.start();<br>        thread1.start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、part-unpark实现顺序模式"><a href="#2、part-unpark实现顺序模式" class="headerlink" title="2、part unpark实现顺序模式"></a>2、part unpark实现顺序模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">soulutionTwo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            LockSupport.park();<br>            System.out.println(<span class="hljs-number">1</span>);<br>        &#125;);<br>        Thread thread2= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-number">2</span>);<br>            LockSupport.unpark(thread);<br>        &#125;);<br>        thread.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、waitNotify实现交替输出"><a href="#3、waitNotify实现交替输出" class="headerlink" title="3、waitNotify实现交替输出"></a>3、waitNotify实现交替输出</h5><p>解决思路，设置计数器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> flag;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str,<span class="hljs-type">int</span> flag,<span class="hljs-type">int</span> nextFlag)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>           <span class="hljs-keyword">while</span> (flag != <span class="hljs-built_in">this</span>.flag)&#123;<br>               <span class="hljs-built_in">this</span>.wait();<br>           &#125;<br>           System.out.println(str);<br>           <span class="hljs-built_in">this</span>.flag = nextFlag;<br>           <span class="hljs-built_in">this</span>.notifyAll();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">waitingclass</span> <span class="hljs-variable">waitingclass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">waitingclass</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    waitingclass.print(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    waitingclass.print(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    waitingclass.print(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        thread1.start();<br>        thread2.start();<br>        thread3.start();<br></code></pre></td></tr></table></figure><h5 id="4、await和signalAll配合"><a href="#4、await和signalAll配合" class="headerlink" title="4、await和signalAll配合"></a>4、await和signalAll配合</h5><p>将不同的输出放到不同的Condition中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> flag;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrintclassByReentraLoock</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNum)</span> &#123;<br>       <span class="hljs-built_in">this</span>.loopNum = loopNum;<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNum;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition thisCondition,Condition nextCondion)</span>&#123;<br>       <span class="hljs-built_in">this</span>.lock();<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNum; i++) &#123;<br>               thisCondition.await();<br>               System.out.println(str);<br>               nextCondion.signalAll();<br>           &#125;<br>       &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>           e.printStackTrace();<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           <span class="hljs-built_in">this</span>.unlock();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>主线程唤醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PrintclassByReentraLoock</span> <span class="hljs-variable">printclassByReentraLoock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintclassByReentraLoock</span>(<span class="hljs-number">3</span>);<br>       <span class="hljs-type">Condition</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> printclassByReentraLoock.newCondition();<br>       <span class="hljs-type">Condition</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> printclassByReentraLoock.newCondition();<br>       <span class="hljs-type">Condition</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> printclassByReentraLoock.newCondition();<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>           printclassByReentraLoock.print(<span class="hljs-string">&quot;a&quot;</span>,a,b);<br>       &#125;);<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>           printclassByReentraLoock.print(<span class="hljs-string">&quot;b&quot;</span>,b,c);<br>       &#125;);<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>           printclassByReentraLoock.print(<span class="hljs-string">&quot;c&quot;</span>,c,a);<br>       &#125;);<br>       t3.start();<br>       t2.start();<br>       t1.start();<br>       TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>       printclassByReentraLoock.lock();<br>       <span class="hljs-keyword">try</span> &#123;<br>           System.out.println(<span class="hljs-string">&quot;开始&quot;</span>);<br>           a.signalAll();<br>       &#125;<span class="hljs-keyword">finally</span> &#123;<br>           printclassByReentraLoock.unlock();<br>       &#125;<br></code></pre></td></tr></table></figure><h5 id="5、park和unpark"><a href="#5、park和unpark" class="headerlink" title="5、park和unpark"></a>5、park和unpark</h5><p>实现思路，编排线程执行顺序</p><p>print类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Printclass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Printclass</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNum)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loopNum = loopNum;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str,Thread nextThred)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNum; i++) &#123;<br>            LockSupport.park();<br>            System.out.println(str);<br>            LockSupport.unpark(nextThred);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Thread t1;<br>    <span class="hljs-keyword">static</span> Thread t2;<br>    <span class="hljs-keyword">static</span> Thread t3;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Printclass</span> <span class="hljs-variable">printclass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Printclass</span>(<span class="hljs-number">3</span>);<br>        t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            printclass.print(<span class="hljs-string">&quot;a&quot;</span>,t2);<br>        &#125;);<br>        t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            printclass.print(<span class="hljs-string">&quot;b&quot;</span>,t3);<br>        &#125;);<br>        t3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            printclass.print(<span class="hljs-string">&quot;c&quot;</span>,t1);<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br>        LockSupport.unpark(t1);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发编程</tag>
      
      <tag>学习笔记</tag>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
      <tag>ReentrantLock</tag>
      
      <tag>常见设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程实战-多锁程序</title>
    <link href="/2021/12/27/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <url>/2021/12/27/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Java并发编程实战-多锁程序"><a href="#Java并发编程实战-多锁程序" class="headerlink" title="Java并发编程实战-多锁程序"></a>Java并发编程实战-多锁程序</h3><h5 id="1、现象描述"><a href="#1、现象描述" class="headerlink" title="1、现象描述"></a>1、现象描述</h5><p>当我们需要在一个类中完成多件事情的时候，我们如果对这个类上锁，会导致程序并发性很低很低，所以我们可以引入多把锁，每个锁干不同的事情增加并发度</p><p><strong>存在的问题</strong></p><ul><li>多个线程竞争锁容易发生死锁</li></ul><h5 id="2、活跃性-死锁"><a href="#2、活跃性-死锁" class="headerlink" title="2、活跃性-死锁"></a>2、活跃性-死锁</h5><ul><li><p>线程1需要获得A 然后获得B</p></li><li><p>线程2需要获得B 然后获得A</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lockA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lockB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lockA)&#123;<br>                System.out.println(<span class="hljs-string">&quot;t1 拿到了 A&quot;</span>);&#123;<br>                    System.out.println(<span class="hljs-string">&quot;t1 准备拿b&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (lockB)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;t1 拿到了b&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lockB)&#123;<br>                System.out.println(<span class="hljs-string">&quot;t2 拿到了 B&quot;</span>);&#123;<br>                    System.out.println(<span class="hljs-string">&quot;t2 准备拿A&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (lockA)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;t2 拿到了A&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="3、定位死锁"><a href="#3、定位死锁" class="headerlink" title="3、定位死锁"></a>3、定位死锁</h5><ul><li><p>检测死锁可以用jconsole或者jps命令行工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">PS D:\学习\代码\javabingfa&gt; jps<br>11952 RemoteMavenServer36<br>16144 test02<br>15892 Jps<br>20628 Launcher<br>7812 <br></code></pre></td></tr></table></figure><p>通过jps可以查看线程，通过jstack进入test02线程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">Found one Java-level deadlock:<br>=============================<br>&quot;Thread-1&quot;:<br>  waiting to lock monitor 0x000000001d2e3ed8 (object 0x000000076e39f138, a java.lang.Object),<br>        at Day03.test02$$Lambda$2/1078694789.run(Unknown Source)<br>        at java.lang.Thread.run(Thread.java:748)<br>&quot;Thread-0&quot;:<br>        at Day03.test02.lambda$test$0(test02.java:20)<br>        - waiting to lock &lt;0x000000076e39f148&gt; (a java.lang.Object)<br>        - locked &lt;0x000000076e39f138&gt; (a java.lang.Object)<br>        at Day03.test02$$Lambda$1/990368553.run(Unknown Source)<br>        at java.lang.Thread.run(Thread.java:748)<br></code></pre></td></tr></table></figure><p>在底部会列出当前哪个线程死锁了</p></li><li><p>通过jconsole可以检测死锁</p></li></ul><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B.png"></p><h5 id="4、哲学家就餐问题"><a href="#4、哲学家就餐问题" class="headerlink" title="4、哲学家就餐问题"></a>4、哲学家就餐问题</h5><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98.png"></p><ul><li>哲学家就餐问题，每个哲学家要进行思考和吃饭，每次吃饭需要一双双子</li><li>代码实现</li><li>定义筷子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopsticks</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chopsticks</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Chopsticks&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义哲学家类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Chopsticks left;<br>    <span class="hljs-keyword">private</span> Chopsticks right;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Philosopher</span><span class="hljs-params">(Chopsticks left,Chopsticks right)</span>&#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;吃饭&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;吃完了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (left)&#123;<br>                <span class="hljs-keyword">synchronized</span> (right)&#123;<br>                    eat();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Chopsticks</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopsticks</span>(<span class="hljs-string">&quot;c1&quot;</span>);<br>        <span class="hljs-type">Chopsticks</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopsticks</span>(<span class="hljs-string">&quot;c2&quot;</span>);<br>        <span class="hljs-type">Chopsticks</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopsticks</span>(<span class="hljs-string">&quot;c3&quot;</span>);<br>        <span class="hljs-type">Chopsticks</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopsticks</span>(<span class="hljs-string">&quot;c4&quot;</span>);<br>        <span class="hljs-type">Chopsticks</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopsticks</span>(<span class="hljs-string">&quot;c5&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">philosopher1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c1, c2);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">philosopher2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c2, c3);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">philosopher3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c3, c4);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">philosopher4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c4, c5);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">philosopher5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c5, c1);<br>        philosopher1.setName(<span class="hljs-string">&quot;philosopher1&quot;</span>);<br>        philosopher2.setName(<span class="hljs-string">&quot;philosopher2&quot;</span>);<br>        philosopher3.setName(<span class="hljs-string">&quot;philosopher3&quot;</span>);<br>        philosopher4.setName(<span class="hljs-string">&quot;philosopher4&quot;</span>);<br>        philosopher5.setName(<span class="hljs-string">&quot;philosopher5&quot;</span>);<br>        philosopher1.start();<br>        philosopher2.start();<br>        philosopher3.start();<br>        philosopher4.start();<br>        philosopher5.start();<br></code></pre></td></tr></table></figure><ul><li>现象</li></ul><p>五个进程都出现了死锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">Java stack information for the threads listed above:<br>===================================================<br>&quot;philosopher5&quot;:<br>        at Day03.deadLocktest.Philosopher.run(Philosopher.java:27)<br>        - waiting to lock &lt;0x000000076e3a1368&gt; (a Day03.deadLocktest.Chopsticks)<br>        - locked &lt;0x000000076e3a1468&gt; (a Day03.deadLocktest.Chopsticks)<br>&quot;philosopher1&quot;:<br>        at Day03.deadLocktest.Philosopher.run(Philosopher.java:27)<br>        - waiting to lock &lt;0x000000076e3a13a8&gt; (a Day03.deadLocktest.Chopsticks)<br>        - locked &lt;0x000000076e3a1368&gt; (a Day03.deadLocktest.Chopsticks)<br>&quot;philosopher2&quot;:<br>        at Day03.deadLocktest.Philosopher.run(Philosopher.java:27)<br>        - waiting to lock &lt;0x000000076e3a13e8&gt; (a Day03.deadLocktest.Chopsticks)<br>        - locked &lt;0x000000076e3a13a8&gt; (a Day03.deadLocktest.Chopsticks)<br>&quot;philosopher3&quot;:<br>        at Day03.deadLocktest.Philosopher.run(Philosopher.java:27)<br>        - waiting to lock &lt;0x000000076e3a1428&gt; (a Day03.deadLocktest.Chopsticks)<br>        - locked &lt;0x000000076e3a13e8&gt; (a Day03.deadLocktest.Chopsticks)<br>&quot;philosopher4&quot;:<br>        at Day03.deadLocktest.Philosopher.run(Philosopher.java:27)<br>        - waiting to lock &lt;0x000000076e3a1468&gt; (a Day03.deadLocktest.Chopsticks)<br>        - locked &lt;0x000000076e3a1428&gt; (a Day03.deadLocktest.Chopsticks)<br><br>Found 1 deadlock.<br></code></pre></td></tr></table></figure><h5 id="5、活跃性-活锁"><a href="#5、活跃性-活锁" class="headerlink" title="5、活跃性-活锁"></a>5、活跃性-活锁</h5><p>指的是互相改变对方的结束条件</p><p>解放方式-随机修改睡眠时间</p><h5 id="6、活跃性-饥饿"><a href="#6、活跃性-饥饿" class="headerlink" title="6、活跃性-饥饿"></a>6、活跃性-饥饿</h5><p>没有发生死锁，有的线程永远拿不到锁</p><h5 id="7、ReentrantLock"><a href="#7、ReentrantLock" class="headerlink" title="7、ReentrantLock"></a>7、ReentrantLock</h5><p>reentrantlock具备以下的特点</p><ul><li>可中断</li><li>可设置超时时间</li><li>可设置为公平锁</li><li>支持多个条件变量</li></ul><p>与sychronized一样，都支持可重入</p><p><strong>可重入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            reentrantLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;第一遍锁&quot;</span>);<br>                reentrantLock.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;第二遍锁&quot;</span>);<br>                &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    reentrantLock.unlock();<br>                &#125;<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                reentrantLock.unlock();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;).start();<br></code></pre></td></tr></table></figure><p><strong>可打断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               reentrantLock.lockInterruptibly();<br>           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>               System.out.println(<span class="hljs-string">&quot;没有获取到锁被打断了&quot;</span>);<br>               e.printStackTrace();<br>           &#125; <span class="hljs-keyword">finally</span> &#123;<br>               reentrantLock.unlock();<br>           &#125;<br>           System.out.println(<span class="hljs-string">&quot;获取到了锁&quot;</span>);<br>       &#125;);<br>       reentrantLock.lock();<br>       System.out.println(<span class="hljs-string">&quot;主线程获取到了锁&quot;</span>);<br>       TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>       thread.start();<br>       <span class="hljs-comment">//reentrantLock.unlock();//解锁</span><br>       thread.interrupt();<br></code></pre></td></tr></table></figure><p>使用lockInterrpitibly()设置为可打断</p><p><strong>锁超时</strong></p><p>主动提供避免死等的手段,trylock 立刻返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程启动&quot;</span>);<br>            <span class="hljs-keyword">if</span> (!reentrantLock.tryLock())&#123;<br>                System.out.println(<span class="hljs-string">&quot;没有获取到锁立刻返回&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;获取到了锁&quot;</span>);<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    reentrantLock.unlock();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        reentrantLock.lock();<br>        System.out.println(<span class="hljs-string">&quot;主线程获取到了锁&quot;</span>);<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>        thread.start();<br>        <span class="hljs-comment">//reentrantLock.unlock();//解锁</span><br></code></pre></td></tr></table></figure><p>携带超时参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>           System.out.println(<span class="hljs-string">&quot;线程启动&quot;</span>);<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-keyword">if</span> (!reentrantLock.tryLock(<span class="hljs-number">5</span>,TimeUnit.SECONDS))&#123;<br>                   System.out.println(<span class="hljs-string">&quot;没有获取到锁立刻返回&quot;</span>);<br>                   <span class="hljs-keyword">return</span>;<br>               &#125;<span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-keyword">try</span> &#123;<br>                       System.out.println(<span class="hljs-string">&quot;获取到了锁&quot;</span>);<br>                   &#125;<span class="hljs-keyword">finally</span> &#123;<br>                       reentrantLock.unlock();<br>                   &#125;<br>               &#125;<br>           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;);<br>       reentrantLock.lock();<br>       System.out.println(<span class="hljs-string">&quot;主线程获取到了锁&quot;</span>);<br>       TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>       thread.start();<br>       TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>       reentrantLock.unlock();<span class="hljs-comment">//解锁</span><br></code></pre></td></tr></table></figure><h5 id="8、使用锁超时来解决哲学家问题"><a href="#8、使用锁超时来解决哲学家问题" class="headerlink" title="8、使用锁超时来解决哲学家问题"></a>8、使用锁超时来解决哲学家问题</h5><p>哲学家问题出现问题的代码主要是下面的部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (left)&#123;<br>                <span class="hljs-keyword">synchronized</span> (right)&#123;<br>                    eat();<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>如何拿不到right，那么A也无法释放，这样就造成了死锁，只要给这部分新增超时机制</p><ul><li>筷子类继承ReentrantLock</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span><br></code></pre></td></tr></table></figure><ul><li>修改run方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>           <span class="hljs-keyword">if</span> (left.tryLock())&#123;<br>               System.out.println(<span class="hljs-string">&quot;获取到了左筷子&quot;</span>);<br>               <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-keyword">if</span> (right.tryLock(<span class="hljs-number">2</span>,TimeUnit.SECONDS))&#123;<br>                           <span class="hljs-keyword">try</span> &#123;<br>                               System.out.println(<span class="hljs-string">&quot;获取到了右手的筷子&quot;</span>);<br>                           &#125;<span class="hljs-keyword">finally</span> &#123;<br>                               right.unlock();<br>                           &#125;<br>                   &#125;<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace();<br>               &#125; <span class="hljs-keyword">finally</span> &#123;<br>                   left.unlock();<br>               &#125;<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><h5 id="9、锁的公平性"><a href="#9、锁的公平性" class="headerlink" title="9、锁的公平性"></a>9、锁的公平性</h5><p>ReentrantLock默认也是不公平锁可以在创建时设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>不建议使用公平锁，会降低并发</p><h5 id="10、ReentrayLock的条件变量"><a href="#10、ReentrayLock的条件变量" class="headerlink" title="10、ReentrayLock的条件变量"></a>10、ReentrayLock的条件变量</h5><p>条件变量指的是满足一定条件后继续执行，在sychronized中的wait和waitset用法就是这个意思，但是在returnlock中强大的点在于，可以创建多个waitset叫做conditionObject</p><p>类中定义了两个事情，食物的等待室和香烟的等待室，每个不同类型的线程进入自己的队列中去</p><ul><li>使用lock.newCondition();创建set</li><li>使用.signal()唤醒</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">foodCondition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">smorkCondition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">food</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">curigut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (!food)&#123;<br>                System.out.println(<span class="hljs-string">&quot;没有食物&quot;</span>);<br>                foodCondition.await();<span class="hljs-comment">// 进入food队列</span><br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;拿到了食物&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">smork</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (!curigut)&#123;<br>                System.out.println(<span class="hljs-string">&quot;没有香烟等待一会&quot;</span>);<br>                smorkCondition.await();<span class="hljs-comment">// 进入food队列</span><br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;拿到了香烟继续干活&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">giveCurigut</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            curigut = <span class="hljs-literal">true</span>;<br>            smorkCondition.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">giveFood</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            food = <span class="hljs-literal">true</span>;<br>            foodCondition.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">workthread</span> <span class="hljs-variable">workthread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">workthread</span>();<br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>          workthread.eat();<br>      &#125;);<br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>          workthread.smork();<br>      &#125;);<br>      thread1.start();<br>      thread2.start();<br>      TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>      System.out.println(<span class="hljs-string">&quot;送东西啦&quot;</span>);<br>      workthread.giveCurigut();<br>      workthread.giveFood();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发编程</tag>
      
      <tag>学习笔记</tag>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
      <tag>ReentrantLock</tag>
      
      <tag>可重入锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程实战-其他的线程API</title>
    <link href="/2021/12/26/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <url>/2021/12/26/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Java并发编程实战-其他的线程API"><a href="#Java并发编程实战-其他的线程API" class="headerlink" title="Java并发编程实战-其他的线程API"></a>Java并发编程实战-其他的线程API</h3><h5 id="1、park-amp-Uppark"><a href="#1、park-amp-Uppark" class="headerlink" title="1、park&amp;Uppark"></a>1、park&amp;Uppark</h5><p>他们是LockSupport类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">LockSupport.park(); <span class="hljs-comment">// 暂停当前线程</span><br>LockSupport.unpark(暂停线程对象) <span class="hljs-comment">// </span><br></code></pre></td></tr></table></figure><p>先park在unpark</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>           System.out.println(<span class="hljs-string">&quot;开启线程&quot;</span>);<br>           <span class="hljs-keyword">try</span> &#123;<br>               System.out.println(<span class="hljs-string">&quot;准备进入睡眠&quot;</span>);<br>               TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>               LockSupport.park();<br>               System.out.println(<span class="hljs-string">&quot;睡眠结束&quot;</span>);<br>           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;);<br>       thread1.start();<br>       TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>       TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>       System.out.println(<span class="hljs-string">&quot;唤醒线程&quot;</span>);<br>       LockSupport.unpark(thread1);<br></code></pre></td></tr></table></figure><h5 id="2、park与Object的wait和notify的区别"><a href="#2、park与Object的wait和notify的区别" class="headerlink" title="2、park与Object的wait和notify的区别"></a>2、park与Object的wait和notify的区别</h5><ul><li>Object的相关方法必须获取到锁。是和monitor进行关联的</li><li>park和unpark是以线程为单位精确唤醒，而且notify只能随机唤醒一个</li><li>park和unpark可以提前uppark，如果执行了park会继续向下执行</li></ul><h5 id="3、park和unpark原理"><a href="#3、park和unpark原理" class="headerlink" title="3、park和unpark原理"></a>3、park和unpark原理</h5><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/park%E5%8E%9F%E7%90%86.png"></p><ul><li>每一个线程都有一个Park对象与其进行关联</li><li>park对象中有三个信息，mutex、cond、和control</li><li>当我们调用park时，会检查control是不是0，如果是0，进入cond中去</li><li>当我们调用unpark时，会将control设置为1，尝试唤醒cond，如果此时发现control是1，则唤醒线程并将control设置为0</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发编程</tag>
      
      <tag>学习笔记</tag>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
      <tag>park&amp;unpark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程实战-生产者消费者</title>
    <link href="/2021/12/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <url>/2021/12/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Java并发编程实战-生产者消费者"><a href="#Java并发编程实战-生产者消费者" class="headerlink" title="Java并发编程实战-生产者消费者"></a>Java并发编程实战-生产者消费者</h3><h5 id="1、简述"><a href="#1、简述" class="headerlink" title="1、简述"></a>1、简述</h5><p>在之前的保护性暂停模式中，消费者和生产者是一对一对的关系，那么很多时候我们需要一对多改怎么办呢，这个时候我们就要维护一个消息队列</p><h5 id="2、消息"><a href="#2、消息" class="headerlink" title="2、消息"></a>2、消息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">message</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> Object object;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setObject</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-built_in">this</span>.object = object;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;message&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, object=&quot;</span> + object +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、创建消息队列"><a href="#3、创建消息队列" class="headerlink" title="3、创建消息队列"></a>3、创建消息队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">messageQuene</span> &#123;<br>    <span class="hljs-comment">// 定义一个队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;message&gt; quene = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;message&gt;();<br>    <span class="hljs-comment">// 定义容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">caption</span> <span class="hljs-operator">=</span> quene.size();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">messageQuene</span><span class="hljs-params">(<span class="hljs-type">int</span> caption)</span> &#123;<br>        <span class="hljs-built_in">this</span>.caption = caption;<br>    &#125;<br>    <span class="hljs-keyword">public</span> message <span class="hljs-title function_">take</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (quene)&#123;<br>            <span class="hljs-keyword">while</span> (quene.isEmpty())&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    quene.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>            &#125;<br>            <span class="hljs-type">message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> quene.get(<span class="hljs-number">0</span>);<br>            quene.remove(<span class="hljs-number">0</span>);<br>            quene.notifyAll();<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(message message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;发送数据&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (quene)&#123;<br>            <span class="hljs-keyword">while</span> (quene.size() &gt;= caption)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程满了&quot;</span>);<br>                    quene.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            quene.add(message);<br>            quene.notifyAll();<br>        &#125;<br><br>    &#125;<br><br></code></pre></td></tr></table></figure><h5 id="4、测试"><a href="#4、测试" class="headerlink" title="4、测试"></a>4、测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">messageQuene</span> <span class="hljs-variable">messageQuene</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">messageQuene</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-comment">//System.out.println(Thread.currentThread().getName() + &quot;正在获取数据&quot;);</span><br>                <span class="hljs-type">message</span> <span class="hljs-variable">take</span> <span class="hljs-operator">=</span> messageQuene.take();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>               System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;获取的数据是&quot;</span> + take.toString());<br>            &#125;,<span class="hljs-string">&quot;线程&quot;</span> + i).start();<br>        &#125;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">12</span>; i++) &#123;<br>            <span class="hljs-type">message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">message</span>();<br>            message.setId(i);<br>            message.setObject(<span class="hljs-string">&quot;hellow&quot;</span> + i);<br>            messageQuene.put(message);<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发编程</tag>
      
      <tag>学习笔记</tag>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
      <tag>生产者消费者模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程实战-保护性暂停</title>
    <link href="/2021/12/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2021/12/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Java并发编程实战-保护性暂停"><a href="#Java并发编程实战-保护性暂停" class="headerlink" title="Java并发编程实战-保护性暂停"></a>Java并发编程实战-保护性暂停</h3><h5 id="1、wait和notify"><a href="#1、wait和notify" class="headerlink" title="1、wait和notify"></a>1、wait和notify</h5><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/wait%E5%92%8Cnotify.png"></p><p>在之前的学习中说到过，当线程获取到锁之后嫩owner会设置为当前线程，其他的线程进入到entryList中阻塞等待，但是如果线程一执行过程中没有满足条件，那么此时可以调用线程1的wait方法，将其放入到waitset中进行等待</p><ul><li>owner线程发现条件不满足运行时候，调用wait方法会放入到waitset中</li><li>block和wait都不会占用cpu的时间片</li><li>entrylist中的线程是block状态，当owner线程释放锁的时候就会被唤醒</li><li>waitset中的线程是wait状态，只有owner线程调用该notify唤醒的时候才会启动</li><li>waitset中的线程唤醒之后会进入enterlist一起竞争锁</li></ul><h5 id="2、相关API"><a href="#2、相关API" class="headerlink" title="2、相关API"></a>2、相关API</h5><ul><li>wait<ul><li>owner线程调用wait方法，线程进入到waitset中</li></ul></li><li>notify<ul><li>owner线程随机唤醒一个线程</li></ul></li><li>notifyAll<ul><li>owner线程唤醒所有线程</li></ul></li><li>wait(long n)<ul><li>有时间的等待，如果没有人唤醒就结束等待</li></ul></li></ul><p>注意的是，以上的所有方法是线程之间协作的手段，都必须是owner线程才可以调用的方法</p><p><strong>notify和notifyall的区别</strong>：notify是挑一个唤醒，notifyall是唤醒所有的线程</p><h5 id="3、sleep和wait的区别"><a href="#3、sleep和wait的区别" class="headerlink" title="3、sleep和wait的区别"></a>3、sleep和wait的区别</h5><ul><li>sleep是线程的静态方法，wait是object的方法</li><li>wait需要先获得对象锁，必须先要获得锁</li><li>sleep不会释放锁，wait会释放锁</li></ul><h5 id="4、保护性暂停-Guarded-Suspension"><a href="#4、保护性暂停-Guarded-Suspension" class="headerlink" title="4、保护性暂停 Guarded Suspension"></a>4、保护性暂停 Guarded Suspension</h5><p>保护性暂停用在一个线程等待另一个线程运行的结果</p><ul><li>使用要点<ul><li>如果一个结果需要从一个线程到另一个线程，那么让他们关联同一个GuardedObject</li><li>如果有结果不断从一个线程到另一个线程，请使用消息队列</li><li>join和feature的实现就是用的这个</li><li>因为要等待同步，所以这个是同步模式</li></ul></li></ul><h5 id="5、代码实现-简单模式"><a href="#5、代码实现-简单模式" class="headerlink" title="5、代码实现 简单模式"></a>5、代码实现 简单模式</h5><ul><li>get方法循环等待</li><li>set方法设置完毕后调用notifyall唤醒线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Guraede</span> <span class="hljs-variable">guraede</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Guraede</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>            System.out.println(<span class="hljs-string">&quot;创建了一个对象 10秒后赋值&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            guraede.setObject(o);<br>            System.out.println(<span class="hljs-string">&quot;执行了赋值&quot;</span>);<br>        &#125;);<br>        thread.start();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> guraede.getObject();<br>            <span class="hljs-keyword">if</span> (object != <span class="hljs-literal">null</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;获取到了对象&quot;</span> + object.hashCode());<br>            &#125;<br><br>        &#125;);<br>        thread1.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Guraede</span>&#123;<br>    <span class="hljs-keyword">private</span> Object object;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了获取线程&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-keyword">while</span> (object == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;循环等待&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                    <span class="hljs-comment">//循环等待</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;拿到值了&quot;</span>);<br>            <span class="hljs-keyword">return</span> object;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setObject</span><span class="hljs-params">(Object object)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-built_in">this</span>.object = object;<br>            <span class="hljs-built_in">this</span>.notifyAll();<br>            System.out.println(<span class="hljs-string">&quot;唤醒等待线程&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="6、保护性暂停超时等待"><a href="#6、保护性暂停超时等待" class="headerlink" title="6、保护性暂停超时等待"></a>6、保护性暂停超时等待</h5><ul><li>在代码中记录了时间差</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Guraede</span> <span class="hljs-variable">guraede</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Guraede</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>            System.out.println(<span class="hljs-string">&quot;创建了一个对象 10秒后赋值&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            guraede.setObject(o);<br>            System.out.println(<span class="hljs-string">&quot;执行了赋值&quot;</span>);<br>        &#125;);<br>        thread.start();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> guraede.getObject(<span class="hljs-number">3</span>);<br>            <span class="hljs-keyword">if</span> (object != <span class="hljs-literal">null</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;获取到了对象&quot;</span> + object.hashCode());<br>            &#125;<br>        &#125;);<br>        thread1.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Guraede</span>&#123;<br>    <span class="hljs-keyword">private</span> Object object;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">(<span class="hljs-type">long</span> time)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了获取线程&quot;</span>);<br>        <span class="hljs-comment">// 记录开始时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">begingTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">speedTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-keyword">while</span> (object == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;循环等待&quot;</span>);<br>                    <span class="hljs-keyword">if</span> (speedTime &gt;= time)&#123;<br>                        System.out.println(<span class="hljs-string">&quot;时间太久了我不等了&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">this</span>.wait(time - speedTime);<br>                    <span class="hljs-comment">//循环等待</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                speedTime = System.currentTimeMillis() - begingTime;<br>                System.out.println(<span class="hljs-string">&quot;经历的时间&quot;</span>);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;拿到值了&quot;</span>);<br>            <span class="hljs-keyword">return</span> object;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setObject</span><span class="hljs-params">(Object object)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-built_in">this</span>.object = object;<br>            <span class="hljs-built_in">this</span>.notifyAll();<br>            System.out.println(<span class="hljs-string">&quot;唤醒等待线程&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="7、join的原理"><a href="#7、join的原理" class="headerlink" title="7、join的原理"></a>7、join的原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                wait(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> millis - now;<br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                wait(delay);<br>                now = System.currentTimeMillis() - base;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>Join底层就是采用了保护性暂停的原理</li></ul><h5 id="8、邮递员问题，多个生产者和消费者之间共享一个gurade对象比较困难-保护性暂停的一一对应"><a href="#8、邮递员问题，多个生产者和消费者之间共享一个gurade对象比较困难-保护性暂停的一一对应" class="headerlink" title="8、邮递员问题，多个生产者和消费者之间共享一个gurade对象比较困难,保护性暂停的一一对应"></a>8、邮递员问题，多个生产者和消费者之间共享一个gurade对象比较困难,保护性暂停的一一对应</h5><ul><li>创建一个保护类<strong>GuardedObject</strong>，用来传递消息监听消息获得情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;<br>    <span class="hljs-comment">// 保护对象类 保护对象类就负责判断对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> Object object;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> time)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">beginTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">passTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (object == <span class="hljs-literal">null</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;开始等待&quot;</span>);<br>                <span class="hljs-keyword">if</span> (passTime &gt;= time)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (passTime == <span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-built_in">this</span>.wait(time);<br>                    &#125;<span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">this</span>.wait(passTime - time);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                passTime = System.currentTimeMillis() - beginTime;<br>            &#125;<br>            <span class="hljs-keyword">return</span> object;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(Object object)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-built_in">this</span>.object = object;<br>            <span class="hljs-built_in">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建一个管理类，用来管理这些保护的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Managerment</span> &#123;<br>    <span class="hljs-comment">// 管理类用来管理所有的保护对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer,GuardedObject&gt; managerment = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 定义一个获取ID的方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getid</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> id++;<br>    &#125;<br>    <span class="hljs-comment">// 定义一个获取GuardeObject的方法</span><br>    <span class="hljs-keyword">public</span> GuardedObject <span class="hljs-title function_">getGuardeObject</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> getid();<br>        managerment.put(id,guardedObject);<br>        <span class="hljs-keyword">return</span> guardedObject;<br>    &#125;<br>    <span class="hljs-comment">// 获取所有的ID</span><br>    <span class="hljs-keyword">public</span> Set&lt;Integer&gt; <span class="hljs-title function_">getkeyList</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> managerment.keySet();<br>    &#125;<br>    <span class="hljs-comment">// 根据id获取Guarded</span><br>    <span class="hljs-keyword">public</span> GuardedObject <span class="hljs-title function_">getguardetByID</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>        <span class="hljs-keyword">return</span> managerment.get(id);<br>    &#125;<br>    <span class="hljs-comment">// 根据Valud获取id</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getIdByObj</span><span class="hljs-params">(GuardedObject guardedObject)</span>&#123;<br>        Set&lt;Integer&gt; integers = managerment.keySet();<br>        <span class="hljs-keyword">for</span> (Integer i:integers<br>             ) &#123;<br>            <span class="hljs-keyword">if</span> (managerment.get(i) == guardedObject)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建一个生产者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">producter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span>  <span class="hljs-type">int</span> mailId;<br>    <span class="hljs-keyword">private</span>  Object message;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">producter</span><span class="hljs-params">(<span class="hljs-type">int</span> mailId,Object message)</span>&#123;<br>        <span class="hljs-built_in">this</span>.mailId = mailId;<br>        <span class="hljs-built_in">this</span>.message = message;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Managerment</span> <span class="hljs-variable">managerment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Managerment</span>();<br>        System.out.println(<span class="hljs-built_in">this</span>.mailId + <span class="hljs-string">&quot;送信了&quot;</span>);<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> managerment.getguardetByID(<span class="hljs-built_in">this</span>.mailId);<br>        guardedObject.set(<span class="hljs-built_in">this</span>.message);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>创建一个消费者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-comment">// 定义一个生产者线程</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Managerment</span> <span class="hljs-variable">managerment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Managerment</span>();<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardeObject</span> <span class="hljs-operator">=</span> managerment.getGuardeObject();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idByObj</span> <span class="hljs-operator">=</span> managerment.getIdByObj(guardeObject);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> guardeObject.get(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">if</span> (message != <span class="hljs-literal">null</span>)&#123;<br>            System.out.println(idByObj + <span class="hljs-string">&quot;手到了数据&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(idByObj + <span class="hljs-string">&quot;没送到我不要了&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>主测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt;=<span class="hljs-number">3</span>;i++)&#123;<br>            <span class="hljs-comment">// 先启动二十个消费者</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">consumer</span>().start();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;邮递员开始送信&quot;</span>);<br>        <span class="hljs-type">Managerment</span> <span class="hljs-variable">managerment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Managerment</span>();<br>        Set&lt;Integer&gt; integers = managerment.getkeyList();<br>        <span class="hljs-keyword">for</span> (Integer i:integers<br>             ) &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">producter</span>(i,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()).start();<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的案例描述了一个典型的一个生产者对应一个消费者的管理模式，能够保证多个生产者和多个消费者一一对应的关系，保证其每一格对应在拿到消息后在执行接下来的工作了</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发编程</tag>
      
      <tag>学习笔记</tag>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
      <tag>保护暂停模式</tag>
      
      <tag>多线程设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程实战-锁的原理</title>
    <link href="/2021/12/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2021/12/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Java并发编程实战-锁的原理"><a href="#Java并发编程实战-锁的原理" class="headerlink" title="Java并发编程实战-锁的原理"></a>Java并发编程实战-锁的原理</h3><p>在并发编程中，问题出现在多个线程访问共享变量的时候</p><p>在一段代码的执行块内，如果存在对共享变量的操作，如果当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件，换句话说，就是正确的结果无法预知，为了避免临界区的静态条件发生，有多种办法可以达到目的</p><ul><li>阻塞式 Sychronized Lock</li><li>非阻塞式 原子变量</li></ul><h5 id="1、Sychronized对象锁"><a href="#1、Sychronized对象锁" class="headerlink" title="1、Sychronized对象锁"></a>1、Sychronized对象锁</h5><p>sychronized是对象锁，采用互斥的方式，在同一时刻至多有一个对象能够执行对象锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>            <span class="hljs-comment">// 临界区</span><br>        &#125;<br></code></pre></td></tr></table></figure><p>sycharonized锁住了临界区的代码</p><p><strong>著名问题：Sychronize加在方法上和加在类上分别锁住了什么</strong></p><p>如果synchronized加在一个类的普通方法上，那么相当于synchronized(this)。</p><p>如果synchronized加载一个类的静态方法上，那么相当于synchronized(Class对象)。</p><p><strong>成员变量和静态变量是否线程安全</strong></p><ul><li>如果没有共享，就线程安全</li><li>如果共享了就要看他们的状态是否可以被修改</li></ul><p><strong>局部变量是否线程安全</strong></p><ul><li>局部变量是线程安全的</li><li>局部变量引用的对象未必线程安全<ul><li>如果对象没有逃离局部变量的作用域那么他是安全的，如果逃离了作用域那么就是不安全的了，例如return</li></ul></li></ul><p><strong>常见的线程安全类：String Interager Stringbuffer Random Hashtable JUC包下的类</strong></p><h5 id="2、Sychronized底层原理及Monitor的概念"><a href="#2、Sychronized底层原理及Monitor的概念" class="headerlink" title="2、Sychronized底层原理及Monitor的概念"></a>2、Sychronized底层原理及Monitor的概念</h5><p>在32位的虚拟机中，对象头占64位，8个字节</p><ul><li>普通对象</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby">|<span class="hljs-params">--------------------------------------------------------------</span>|<br>|<span class="hljs-params">                     Object Header (64 bits)                  </span>|<br>|<span class="hljs-params">------------------------------------</span>|-------------------------|<span class="hljs-params"></span><br><span class="hljs-params"></span>|        Mark Word (<span class="hljs-number">32</span> bits)         |<span class="hljs-params">    Klass Word (32 bits) </span>|<br>|<span class="hljs-params">------------------------------------</span>|-------------------------|<span class="hljs-params"></span><br></code></pre></td></tr></table></figure><ul><li>数组对象</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby">|<span class="hljs-params">---------------------------------------------------------------------------------</span>|<br>|<span class="hljs-params">                                 Object Header (96 bits)                         </span>|<br>|<span class="hljs-params">--------------------------------</span>|-----------------------|<span class="hljs-params">------------------------</span>|<br>|<span class="hljs-params">        Mark Word(32bits)       </span>|    Klass Word(32bits) |<span class="hljs-params">  array length(32bits)  </span>|<br>|<span class="hljs-params">--------------------------------</span>|-----------------------|<span class="hljs-params">------------------------</span>|<br></code></pre></td></tr></table></figure><p><strong>Klassword代表指向的对象的地址</strong></p><p><strong>markword用来存储对象运行时需要的信息</strong></p><p>每个Java对象都会去关联一个Monitor对象，如果使用sychronized给对象上锁之后，该对象的markword就会被设为Monitor对象的指针</p><ul><li>线程执行被sychronized所著的代码的时候，会尝试的将markword与monitor对象进行关联</li></ul><h5 id="3、Markword的结构"><a href="#3、Markword的结构" class="headerlink" title="3、Markword的结构"></a>3、Markword的结构</h5><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby">|<span class="hljs-params">--------------------------------------------------------</span>|--------------------|<span class="hljs-params"></span><br><span class="hljs-params"></span>|                  Mark Word (<span class="hljs-number">32</span> bits)                   |<span class="hljs-params">       State        </span>|<br>|<span class="hljs-params">--------------------------------------------------------</span>|--------------------|<span class="hljs-params"></span><br><span class="hljs-params"></span>| <span class="hljs-symbol">identity_hashcode:</span><span class="hljs-number">25</span> |<span class="hljs-params"> age:4 </span>| <span class="hljs-symbol">biased_lock:</span><span class="hljs-number">0</span> |<span class="hljs-params"> lock:01 </span>|       Normal       |<span class="hljs-params"></span><br><span class="hljs-params"></span>|--------------------------------------------------------|<span class="hljs-params">--------------------</span>|<br>|<span class="hljs-params">  thread:23 </span>| <span class="hljs-symbol">epoch:</span><span class="hljs-number">2</span> |<span class="hljs-params"> age:4 </span>| <span class="hljs-symbol">biased_lock:</span><span class="hljs-number">1</span> |<span class="hljs-params"> lock:01 </span>|       Biased       |<span class="hljs-params"></span><br><span class="hljs-params"></span>|--------------------------------------------------------|<span class="hljs-params">--------------------</span>|<br>|<span class="hljs-params">               ptr_to_lock_record:30          </span>| <span class="hljs-symbol">lock:</span><span class="hljs-number">00</span> |<span class="hljs-params"> Lightweight Locked </span>|<br>|<span class="hljs-params">--------------------------------------------------------</span>|--------------------|<span class="hljs-params"></span><br><span class="hljs-params"></span>|               <span class="hljs-symbol">ptr_to_heavyweight_monitor:</span><span class="hljs-number">30</span>  |<span class="hljs-params"> lock:10 </span>| Heavyweight Locked |<span class="hljs-params"></span><br><span class="hljs-params"></span>|--------------------------------------------------------|<span class="hljs-params">--------------------</span>|<br>|<span class="hljs-params">                                              </span>| <span class="hljs-symbol">lock:</span><span class="hljs-number">11</span>  |<span class="hljs-params">    Marked <span class="hljs-keyword">for</span> GC   </span>|<br>|<span class="hljs-params">--------------------------------------------------------</span>|--------------------|<span class="hljs-params"></span><br></code></pre></td></tr></table></figure><p>markword主要用来存储对象运行时的一些数据，例如hashcode，分带年龄等</p><p>各部分的含义如下</p><ul><li><strong>identity_hashcode</strong>：代表hashcode</li><li><strong>age</strong>：代表分代区年龄</li><li><strong>biased_lock</strong>：代表是否为偏向锁，为1时代表启用偏向锁，为0时代表没有启用偏向锁</li><li><strong>thread</strong>：代表现成的ID，当启用偏向锁时，需要记录偏向线程的ID</li><li><strong>epoch</strong>：偏向时间戳</li><li><strong>ptr_to_lock_record</strong>：指向栈中锁记录的指针</li><li><strong>ptr_to_heavyweight_monitor</strong>：只想Monitor记录的指针</li></ul><table><thead><tr><th align="left">biased_lock</th><th align="left">lock</th><th align="left">状态</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">01</td><td align="left">无锁</td></tr><tr><td align="left">1</td><td align="left">01</td><td align="left">偏向锁</td></tr><tr><td align="left">0</td><td align="left">00</td><td align="left">轻量级锁</td></tr><tr><td align="left">0</td><td align="left">10</td><td align="left">重量级锁</td></tr><tr><td align="left">0</td><td align="left">11</td><td align="left">GC标记</td></tr></tbody></table><h5 id="4、Monitor的原理"><a href="#4、Monitor的原理" class="headerlink" title="4、Monitor的原理"></a>4、Monitor的原理</h5><p>monitor：监视器 管程</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/monitor%E5%8E%9F%E7%90%86.png"></p><ul><li>初始状态的时候monitor的owner是空的</li><li>当线程1执行临界区的代码时，与obj关联的mointor对象的owner设置为t2进程的ID，此时，obj对象头中的信息变为</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">|<span class="hljs-params">               ptr_to_heavyweight_monitor:30  </span>| <span class="hljs-symbol">lock:</span><span class="hljs-number">2</span> |<span class="hljs-params"> Heavyweight Locked </span>|<br></code></pre></td></tr></table></figure><p>对象头中存放的是关联的monitor的地址，Lock变为10</p><ul><li><p>当线程2来的时候，首先看对象管理的monitor中的obwner是否为空，如果有主任了，那么就进入Enterlist当中阻塞进行等待</p></li><li><p>当线程1结束后，owner会叫醒处于enterlist当中的线程，然后他们开始进行锁竞争，获取锁</p></li><li><p>waitset是之前获得过锁，但是不满足执行状态的，会被放入waitset集合中去</p></li></ul><h5 id="5、轻量级锁"><a href="#5、轻量级锁" class="headerlink" title="5、轻量级锁"></a>5、轻量级锁</h5><p>如果我们每次都是用重量级锁，那么上下文切换的成本太高了，这时候可以引入轻量级锁</p><ul><li>使用场景：如果一个对象虽然有多线程进行访问，但多线程的访问是错开的，没有竞争，可以使用轻量级锁来进行优化</li><li>轻量级锁对于使用者是透明的，依然是cychronized语法</li></ul><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81.png"></p><ul><li>首先线程所著的对象中存放了对象头和对象体的信息，当我们线程执行时候，会创建一个栈帧，栈帧中会添加一条锁记录Lockrecord，锁记录中存放的信息有Lockrecord存放的是对象的markword的信息，Object reference存放的是引用的对象的信息</li></ul><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E5%8A%A0%E4%B8%8A%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png"></p><ul><li>首先，会创建一条锁记录，锁记录的lockrecord会与对象中的markword交换信息，代表给他加上轻量级锁，将锁的最后变为00，其对象头变成了锁记录的地址，来表示加的是轻量级锁，如果锁替换成功，那么将会是如下情况</li></ul><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E6%9B%BF%E6%8D%A2%E6%88%90%E5%8A%9F.png"></p><ul><li>如果ca失败了会有两种情况<ul><li>第一种就是已经有其他的锁修改了对象的markword，让其变成了00，这表明出现了竞争，进入了锁膨胀的过程</li><li>第二种是自己进行了suchronized锁重入，那么就会在加一条锁，那么会创建一条新的锁记录</li></ul></li></ul><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E9%87%8D%E5%85%A5.png"></p><ul><li><p>如何发生了锁重入，那么替换的时候就会制空</p></li><li><p>解锁</p><ul><li>当线程2执行完毕时，锁记录，如果有为空的情况出现，则锁记录-1</li><li>当锁记录不为null了就进行还原的操作<ul><li>如果解锁过程成功则解锁成功</li><li>如果解锁失败，则代表已经进入了重量级锁，进入重量级锁的解锁流程</li></ul></li></ul></li></ul><h5 id="6、锁膨胀"><a href="#6、锁膨胀" class="headerlink" title="6、锁膨胀"></a>6、锁膨胀</h5><p>在轻量级锁中，如果出现了竞争，那么会升级成为重量级锁，这个过程叫做锁膨胀</p><ul><li>当线程1走正常的轻量级锁加锁流程的时候成功获取了锁执行正常的任务代码</li><li>此时线程2开始竞争锁，发现加锁失败，进入锁膨胀的过程<ul><li>为object申请重量级锁，即让object的markword指向重量级锁的地址</li><li>自己进入entryList中</li></ul></li></ul><h5 id="7、自旋"><a href="#7、自旋" class="headerlink" title="7、自旋"></a>7、自旋</h5><p>在重量级锁竞争的时候，如果没有竞争到锁，先不进入阻塞，而是循环几次，如果期间获取到了锁就不进入阻塞队列</p><p>Java7之后就不能控制是否开启自旋的功能</p><h5 id="8、偏向锁"><a href="#8、偏向锁" class="headerlink" title="8、偏向锁"></a>8、偏向锁</h5><p>轻量级锁在没有竞争的时候，每次都要进行cas操作，java在java6引入了偏向锁的概念</p><p>只有第一个cad将线程ID设置到了对象的markword头之后，只要不发生竞争，对象就是线程专用的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby">|<span class="hljs-params">--------------------------------------------------------</span>|--------------------|<span class="hljs-params"></span><br><span class="hljs-params"></span>|                  Mark Word (<span class="hljs-number">32</span> bits)                   |<span class="hljs-params">       State        </span>|<br>|<span class="hljs-params">--------------------------------------------------------</span>|--------------------|<span class="hljs-params"></span><br><span class="hljs-params"></span>| <span class="hljs-symbol">identity_hashcode:</span><span class="hljs-number">25</span> |<span class="hljs-params"> age:4 </span>| <span class="hljs-symbol">biased_lock:</span><span class="hljs-number">0</span> |<span class="hljs-params"> lock:01 </span>|       Normal       |<span class="hljs-params"></span><br><span class="hljs-params"></span>|--------------------------------------------------------|<span class="hljs-params">--------------------</span>|<br>|<span class="hljs-params">  thread:23 </span>| <span class="hljs-symbol">epoch:</span><span class="hljs-number">2</span> |<span class="hljs-params"> age:4 </span>| <span class="hljs-symbol">biased_lock:</span><span class="hljs-number">1</span> |<span class="hljs-params"> lock:01 </span>|       Biased       |<span class="hljs-params"></span><br><span class="hljs-params"></span>|--------------------------------------------------------|<span class="hljs-params">--------------------</span>|<br>|<span class="hljs-params">               ptr_to_lock_record:30          </span>| <span class="hljs-symbol">lock:</span><span class="hljs-number">00</span> |<span class="hljs-params"> Lightweight Locked </span>|<br>|<span class="hljs-params">--------------------------------------------------------</span>|--------------------|<span class="hljs-params"></span><br><span class="hljs-params"></span>|               <span class="hljs-symbol">ptr_to_heavyweight_monitor:</span><span class="hljs-number">30</span>  |<span class="hljs-params"> lock:10 </span>| Heavyweight Locked |<span class="hljs-params"></span><br><span class="hljs-params"></span>|--------------------------------------------------------|<span class="hljs-params">--------------------</span>|<br>|<span class="hljs-params">                                              </span>| <span class="hljs-symbol">lock:</span><span class="hljs-number">11</span>  |<span class="hljs-params">    Marked <span class="hljs-keyword">for</span> GC   </span>|<br>|<span class="hljs-params">--------------------------------------------------------</span>|--------------------|<span class="hljs-params"></span><br></code></pre></td></tr></table></figure><p>偏向状态</p><ul><li>当一个对象创建的时候是一个正常，后三位是001</li><li>偏向锁是延迟的，避免延迟可以设置JVM参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">//关闭延迟开启偏向锁<br>-XX:BiasedLockingStartupDelay=0<br>//禁止偏向锁<br>-XX:-UseBiasedLocking <br>//启用偏向锁<br>-XX:+UseBiasedLocking <br></code></pre></td></tr></table></figure><ul><li>.hsahcode方法可以撤销偏向锁</li><li>其他线程使用了对象就会撤销偏向锁，变成轻量级锁</li></ul><p>撤销偏向</p><ul><li>其他线程使用对象</li><li>调用wait&#x2F;notify也会锁升级</li></ul><h5 id="9、撤销重偏向"><a href="#9、撤销重偏向" class="headerlink" title="9、撤销重偏向"></a>9、撤销重偏向</h5><ul><li>如果连续多次冲偏向后，jvm会自动取消冲偏向</li></ul><h5 id="10、批量撤销"><a href="#10、批量撤销" class="headerlink" title="10、批量撤销"></a>10、批量撤销</h5><ul><li>阈值超过40次后会锁会变成不可偏向的状态</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发编程</tag>
      
      <tag>学习笔记</tag>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
      <tag>sychronized</tag>
      
      <tag>锁的原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程实战-线程状态</title>
    <link href="/2021/12/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2021/12/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Java并发编程实战-线程状态"><a href="#Java并发编程实战-线程状态" class="headerlink" title="Java并发编程实战-线程状态"></a>Java并发编程实战-线程状态</h3><h4 id="1、守护线程和主线程"><a href="#1、守护线程和主线程" class="headerlink" title="1、守护线程和主线程"></a>1、守护线程和主线程</h4><p>默认默认情况下，Java主线程需要等待所有的线程都运行结束才会结束，有一种线程叫做守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没有执行完，也会被强制结束</p><p>主线程会等待所有的线程运行结束才会停止运行</p><p>在Java中有两类线程，即用户线程和守护线程</p><p>任何一个守护线程都是整个JVM中所有非守护线程的保姆</p><p>只要当前JVM实例中存在任何一个非守护线程没有结束，守护线程就全部工作，只有当最后一个非守护线程结束工作时，守护线程才会结束工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;守护线程执行工作中&quot;</span>);<span class="hljs-comment">//模拟工作</span><br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">30</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        thread.setDaemon(<span class="hljs-literal">true</span>);<br>        thread.start();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>                System.out.println(<span class="hljs-string">&quot;我结束了&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><br>            &#125;<br>        &#125;);<br>        System.out.println(<span class="hljs-number">123</span>);<br>        thread1.start();<br></code></pre></td></tr></table></figure><p>代码现象：thread线程休眠30s，线程2休眠10秒，线程1设置为守护线程，当线程2十秒结束后，线程1直接结束</p><h5 id="2、线程的五种状态"><a href="#2、线程的五种状态" class="headerlink" title="2、线程的五种状态"></a>2、线程的五种状态</h5><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81.png"></p><h5 id="3、线程的六种状态"><a href="#3、线程的六种状态" class="headerlink" title="3、线程的六种状态"></a>3、线程的六种状态</h5><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81.png"></p><p>在Java层面，线程共有六种状态，分别是New、Runable、Terminated三个状态，这三个状态按照顺序执行从上到下，不可逆转</p><p>在Runaable中有三个状态，分别是Block阻塞，wait无限等待和timewaiting有限等待</p><p>从Runable到Timewaiting状态是由于调用了sleep方法或者wait方法睡眠了有限的时间后并且获取到了锁就进入runable状态，否则进入block状态</p><p>从Runable到waiting状态是由于调用了wait或者sleep方法，若被唤起且获得了锁后可以回到Runable否则进去Blocak</p><p>从Runable到Block很简单，就是获取了锁就可以恢复了</p><h5 id="4、详细的讲述一下线程的六种状态以及他们之间的转换"><a href="#4、详细的讲述一下线程的六种状态以及他们之间的转换" class="headerlink" title="4、详细的讲述一下线程的六种状态以及他们之间的转换"></a>4、详细的讲述一下线程的六种状态以及他们之间的转换</h5><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png"></p><p><strong>情况1：new - runable</strong></p><p>当创建线程后，分配到了cpu时间片就会进入到runable状态</p><p><strong>情况2：runable和waiting状态</strong></p><p>当我们的线程获取到了Sychronized锁之后呢，如果调用了wait方法，就会进入到witinf中</p><p>如果调用了notify方法或者interput或者notifyall方法</p><ul><li>如果竞争到了锁，就会进入到runable</li><li>如果没有竞争到锁，就进入blocked</li></ul><p><strong>情况3</strong></p><p>当我们调用了join方法的时候就会让线程从runable转为waiting</p><p>当线程结束运行之后或者调用了interput方法后就会回到runable状态</p><p><strong>情况4</strong></p><p>线程调用了park方法会进入到waiting状态，uppark取消状态</p><p><strong>情况5</strong></p><p>线程获得了锁后调用wait（long n）方法进入到timewaiting</p><p>时间到了或者调用了interput后从timewaiting开始竞争锁</p><p>竞争到了锁进入runalble</p><p>否则block</p><p><strong>情况6</strong></p><p>调用了join方法</p><p><strong>情况7</strong></p><p>调用了sleep方法</p><p><strong>情况8</strong></p><p>调用了park（long time）</p><p><strong>情况9</strong></p><p>获取到了锁</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发编程</tag>
      
      <tag>学习笔记</tag>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
      <tag>线程状态基本知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程实战-线程的API</title>
    <link href="/2021/12/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/12/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Java并发编程实战-线程的API"><a href="#Java并发编程实战-线程的API" class="headerlink" title="Java并发编程实战-线程的API"></a>Java并发编程实战-线程的API</h3><h5 id="1、star-和-run"><a href="#1、star-和-run" class="headerlink" title="1、star 和 run"></a>1、star 和 run</h5><ul><li>star是开启一个线程的run功能</li><li>run只是执行一个线程的方法，如果直接开启run的话还是单线程运行的</li></ul><h5 id="2、sleep和yield"><a href="#2、sleep和yield" class="headerlink" title="2、sleep和yield"></a>2、sleep和yield</h5><ul><li>sleep方法是让线程休眠，线程从Runable进入Timewating状态</li><li>yield方法是让出当前线程，会让线程从Runing进入Runable状态</li></ul><p>调用其他现成的inerput方法会叫醒正在睡眠的线程</p><p><strong>设置线程优先级</strong>：setPriority</p><p><strong>sleep的应用：防止cpu占用100%</strong></p><h5 id="3、join"><a href="#3、join" class="headerlink" title="3、join"></a>3、join</h5><ul><li>等待线程运行结束</li><li>需要等待解雇后继续运行的就是同步，不需要等待结果后续运行的就是异步</li><li>join(n)设置最大等待时间，单位毫秒</li></ul><h5 id="4、interrput详解"><a href="#4、interrput详解" class="headerlink" title="4、interrput详解"></a>4、interrput详解</h5><ul><li><p>打断sleep、wait、join的线程</p></li><li><p>interrput可以打断处于阻塞状态的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">thread.isInterruput()<br></code></pre></td></tr></table></figure><p><strong>正常的线程被打断时候，会返回true，正在睡眠的线程被打断时会返回false</strong></p></li><li><p>interrput可以优雅的终止线程</p></li></ul><h6 id="多线程设计模式-两阶段终止模式"><a href="#多线程设计模式-两阶段终止模式" class="headerlink" title="多线程设计模式-两阶段终止模式"></a>多线程设计模式-两阶段终止模式</h6><p>两阶段终止模式，如何优雅的在T1线程中终止T2线程</p><p>如果直接使用stop会导致没有释放锁，如果锁住了共享资源，那么再也没有机会去释放锁，其他线程永远无法获取锁</p><p>循环的成立条件是程序没有被打断，如果被打断了，那么打断标记会被设置为true，但是如果在睡眠状态中被打断，不会变为真，但是会抛出异常，我们只需要重新设置打断标记，那么下一次就可以进行料理后事了</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2.png"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 两阶段终止模式，在一个线程t1中如何优雅的打断T2</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted())&#123;<br>                    System.out.println(<span class="hljs-string">&quot;执行处理后事的代码&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>                        System.out.println(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;在睡眠的时候被打断了&quot;</span>);<br>                        Thread.currentThread().interrupt();<span class="hljs-comment">// 手动打断</span><br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br>        t1.interrupt(); <span class="hljs-comment">// 打断线程</span><br></code></pre></td></tr></table></figure><h5 id="5、park"><a href="#5、park" class="headerlink" title="5、park"></a>5、park</h5><ul><li>park类似于程序的断点，程序会卡住</li><li>调用interput方法后，程序会继续运行，但是在此方法后，park会失效</li><li>这是一个不推荐的方法，会破坏同步代码块，造成死锁</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发编程</tag>
      
      <tag>学习笔记</tag>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
      <tag>线程的API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程-线程的基础知识</title>
    <link href="/2021/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Java并发编程-线程的基础知识"><a href="#Java并发编程-线程的基础知识" class="headerlink" title="Java并发编程-线程的基础知识"></a>Java并发编程-线程的基础知识</h3><h5 id="1、进程和线程"><a href="#1、进程和线程" class="headerlink" title="1、进程和线程"></a>1、进程和线程</h5><ul><li><p>什么是进程</p><p>进程是由指令和数据构成的，但是这些命令要执行必须下发到CPU当中去，为数据加载到内存当中去，在指令运行的国中中还需要动用磁盘网络设备，进程就是用来加载指令、管理内存、管理IO的</p><p>当一个程序被运行时，从磁盘加载程序的代码到内存中的时候，就开启了一个进程</p><p>进程可以视为程序的一个实例，大部分程序可以同时运行多个实例进程</p></li><li><p>什么是线程</p><p>一个进程之间可以有多个线程，线程就是一个指令流</p></li><li><p>二者对比</p><p>进程之间是相互独立的，而线程是存在进程内的，是进程的一个子集</p><p>进程之间拥有共享的资源，例如内存空间，供内部线程共享</p><p>进程之间的通信非常复杂</p><p>线程之间的通信比较简单</p></li></ul><h5 id="2、并行和并发的区别"><a href="#2、并行和并发的区别" class="headerlink" title="2、并行和并发的区别"></a>2、并行和并发的区别</h5><ul><li><p>并行</p><p>并行是同一时间做多个事情的能力</p></li><li><p>并发</p><p>并发同一时间应多多件事情的能力</p></li></ul><h5 id="3、Java创建线程的方式"><a href="#3、Java创建线程的方式" class="headerlink" title="3、Java创建线程的方式"></a>3、Java创建线程的方式</h5><ul><li>使用Thread类，继承Thread类重新Run方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test01</span> &#123;<br>    <span class="hljs-comment">// 创建线程的方式</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">threadClass</span>().start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">threadClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用Runable接口，利用Thread类实现线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了一个线程的代码&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>thread.start();<br></code></pre></td></tr></table></figure><p>匿名内部类可以使用Lambad表达式优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;这是一个线程&quot;</span>);<br>&#125;, <span class="hljs-string">&quot;threaName&quot;</span>);<br>thread1.start();<br></code></pre></td></tr></table></figure><ul><li>FutureTask配合Thread类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">FutureTask&lt;Integer&gt; integerFutureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(integerFutureTask);<br>integerFutureTask.get();<br></code></pre></td></tr></table></figure><h5 id="4、查看线程的方法"><a href="#4、查看线程的方法" class="headerlink" title="4、查看线程的方法"></a>4、查看线程的方法</h5><ul><li>Windows<ul><li>任务管理器</li><li>TaskList</li><li>taskkill</li></ul></li><li>Linux<ul><li>ps -ef</li><li>kill</li></ul></li></ul><h5 id="5、线程运行的原理"><a href="#5、线程运行的原理" class="headerlink" title="5、线程运行的原理"></a>5、线程运行的原理</h5><p>暂时没总结 还没搞懂</p><h5 id="6、线程上下文切换"><a href="#6、线程上下文切换" class="headerlink" title="6、线程上下文切换"></a>6、线程上下文切换</h5><p>线程上下文切换是因为一些原因导致CPU不在执行当前的线程，转而执行另一个线程的代码，线程上下文切换的原因有很多，包括</p><ul><li>线程的CPU时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了sleep、yield、wait、join、park、syschronizd、lock等方法</li></ul><p>当context switch发生时候，需要由操作系统保存当前线程的执行状态，并且恢复另一个线程的状态，Java中对应的就是程序计数器，它的作用是保存下一条JVM指令的执行地址，是线程私有的</p><p>要保存的信息有</p><ul><li>程序计数器</li><li>虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li></ul><p>上下文切换会消耗程序性能，<strong>线程数超过CPU核心的线程数</strong></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发编程</tag>
      
      <tag>学习笔记</tag>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka 学习笔记</title>
    <link href="/2021/12/15/Kafka-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/12/15/Kafka-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Kafka-学习"><a href="#Kafka-学习" class="headerlink" title="Kafka 学习"></a>Kafka 学习</h2><h3 id="1、Kafka-概述和定义"><a href="#1、Kafka-概述和定义" class="headerlink" title="1、Kafka 概述和定义"></a>1、Kafka 概述和定义</h3><p><strong>Kafka是一个分布式的基于发布&#x2F;订阅模式的消息队列，主要应用于大数据实时处理领域</strong></p><p><strong>发布&#x2F;订阅</strong>：消息的发布者不会将消息直接发送给特定的订阅者，而是将发布的消息分为不同的类别，订阅者只接收感兴趣的消息</p><p>kafka被数千家公司用于高性能数据管道、流分析、数据集成领域</p><h4 id="1-1-消息队列"><a href="#1-1-消息队列" class="headerlink" title="1.1 消息队列"></a>1.1 消息队列</h4><p>目前企业中比较常见的消息队列产品主要有 Kafka、ActiveMq、RabbitMq、RocketMq等</p><p>在大数据领域主要采用Kafka作为消息队列，在JavaEE开发中主要采用ActiveMQ，RabbieMq，RocketMq</p><p><strong>消息队列的应用场景</strong></p><p>缓存&#x2F;消峰、异步、解耦</p><p><strong>消息队列的两种模式</strong></p><ul><li><p>点对点模式</p><ul><li>消费者主动拉取数据，消息收到后清除消息</li></ul></li><li><p>发布&#x2F;订阅模式</p><ul><li>可以有多个topic主题</li><li>消费者消费数据之后，不删除数据</li><li>每个消费者相互独立，都可以消费到数据</li></ul></li></ul><h4 id="1-2-Kafka的基础架构"><a href="#1-2-Kafka的基础架构" class="headerlink" title="1.2 Kafka的基础架构"></a>1.2 Kafka的基础架构</h4><ul><li>为了方便拓展，并提高吞吐量，一个Topic分为多个partition<ul><li>broker 代表服务器名称</li></ul></li><li>配合分区的设计，提出消费者组的概念，组内的每个消费者并行消费<ul><li>一个分区的数据只能有一个消费者来消费</li></ul></li><li>为了提高可用性，为每个partition增加若干个副本<ul><li>副本分为leader和follower</li><li>消费者只针对leader副本进行消费</li></ul></li><li>Kafka中的一部分数据存储在了 Zookeeper中<ul><li>记录了集群中服务器的运行状态</li><li>记录了每一个分区leader相关信息</li></ul></li></ul><h3 id="2、Kafka安装部署"><a href="#2、Kafka安装部署" class="headerlink" title="2、Kafka安装部署"></a>2、Kafka安装部署</h3><h4 id="2-1-集群规划"><a href="#2-1-集群规划" class="headerlink" title="2.1 集群规划"></a>2.1 集群规划</h4><p>Kafka的安装和部署以三台机器为例</p><table><thead><tr><th>192.168.64.132</th><th>192.168.64.133</th><th>192.168.64.134</th></tr></thead><tbody><tr><td>Zookeeper</td><td>Zookeeper</td><td>Zookeeper</td></tr><tr><td>Kafka</td><td>Kafka</td><td>Kafka</td></tr></tbody></table><h4 id="2-2-安装-Zookeeper"><a href="#2-2-安装-Zookeeper" class="headerlink" title="2.2 安装 Zookeeper"></a>2.2 安装 Zookeeper</h4><p><strong>下载</strong></p><p><a href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/releases.html</a></p><p><strong>配置Zookeeper的环境变量</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/profile<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 添加配置</span></span><br>export ZOOKEEPER_HOME=/tangcheng/apache-zookeeper-3.8.0-bin<br>export PATH=$PATH:$ZOOKEEPER_HOME/bin:$ZOOKEEPER_HOME/conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 刷新配置文件</span></span><br>source /etc/profile<br></code></pre></td></tr></table></figure><p><strong>集群部署</strong></p><p>进入conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd conf<br>cp zoo_sample.cfg zoo.cfg<br>vim zoo.cfg<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 创建 data目录</span></span><br>mkdir data<br>vi myid 1<br></code></pre></td></tr></table></figure><p>修改配置信息</p><p>主要需要修改的配置有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">dataDir=/tangcheng/apache-zookeeper-3.8.0-bin/data<br>clientPort=2181<br>server.1=192.168.64.132:2888:3888<br>server.2=192.168.64.133:2888:3888<br>server.3=192.168.64.134:2888:3888<br></code></pre></td></tr></table></figure><p>拷贝到别的机器上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shel">scp -r /tangcheng/apache-zookeeper-3.8.0-bin root@192.168.64.133:/tangcheng/apache-zookeeper-3.8.0-bin<br>scp -r /tangcheng/apache-zookeeper-3.8.0-bin root@192.168.64.134:/tangcheng/apache-zookeeper-3.8.0-bin<br></code></pre></td></tr></table></figure><h4 id="2-3-安装kafka"><a href="#2-3-安装kafka" class="headerlink" title="2.3 安装kafka"></a>2.3 安装kafka</h4><p><strong>下载</strong></p><p><a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/3.2.0/kafka_2.12-3.2.0.tgz">https://www.apache.org/dyn/closer.cgi?path=/kafka/3.2.0/kafka_2.12-3.2.0.tgz</a></p><p><strong>配置</strong></p><p>主要需要修改的文件是&#x2F;conf&#x2F;server.properties</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># kafka 在集群上的唯一标志</span></span><br>broker.id=0<br>log.dirs=/tangcheng/kafka_2.12-3.2.0/logs<br>zookeeper.connect=192.168.64.132:2181,192.168.64.133:2181,192.168.64.134:2181/kafka<br></code></pre></td></tr></table></figure><p>拷贝到别的机器上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r /tangcheng/kafka_2.12-3.2.0 root@192.168.64.133:/tangcheng/kafka_2.12-3.2.0<br>scp -r /tangcheng/kafka_2.12-3.2.0 root@192.168.64.134:/tangcheng/kafka_2.12-3.2.0<br></code></pre></td></tr></table></figure><p>设置hostname</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">hostnamectl set-hostname server3<br>192.168.64.132  server1<br>192.168.64.133  server2<br>192.168.64.134  server3<br><br></code></pre></td></tr></table></figure><h4 id="2-4-安装kafka-Eagle"><a href="#2-4-安装kafka-Eagle" class="headerlink" title="2.4 安装kafka Eagle"></a>2.4 安装kafka Eagle</h4><p><strong>下载</strong></p><p><a href="http://download.kafka-eagle.org/">http://download.kafka-eagle.org/</a></p><p><strong>配置</strong></p><p>编辑环境变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">export JAVA_HOME=/tangcheng/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_144</span><br>export JRE_HOME=$&#123;JAVA_HOME&#125;/jre<br>export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib:$CLASSPATH<br>export JAVA_PATH=$&#123;JAVA_HOME&#125;bin:$&#123;JRE_HOME&#125;/bin<br>export PATH=$PATH:$&#123;JAVA_PATH&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/profile<br><br>export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.332.b09-1.el7_9.x86_64<br><br>export KE_HOME=/tangcheng/kafka-eagle-bin-2.1.0/efak-web-2.1.0<br>export PATH=$PATH:$KE_HOME/bin:$JAVA_HOME/bin<br></code></pre></td></tr></table></figure><p>进入conf目录修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cluster1.zk.list=192.168.64.132:2181,192.168.64.133:2181,192.168.64.134:2181<br></code></pre></td></tr></table></figure><p>其他的配置自行修改</p><h3 id="3、基础操作"><a href="#3、基础操作" class="headerlink" title="3、基础操作"></a>3、基础操作</h3><h4 id="3-1-Topic-命令"><a href="#3-1-Topic-命令" class="headerlink" title="3.1 Topic 命令"></a>3.1 Topic 命令</h4><p>topic 命令涉及到的脚本</p><p><strong>kafka-topic.sh</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>–bootstrap-server</td><td>连接的kafka broker主机名称和端口号</td></tr><tr><td>–topic</td><td>操作的topic名称</td></tr><tr><td>–create</td><td>创建主题</td></tr><tr><td>–delete</td><td>删除主题</td></tr><tr><td>–alter</td><td>修改主题</td></tr><tr><td>–list</td><td>查看所有主题</td></tr><tr><td>–describe</td><td>查看主题详细描述</td></tr><tr><td>–partitions</td><td>设置分区数</td></tr><tr><td>–replication</td><td>设置分区副本</td></tr><tr><td>–config</td><td>更新系统默认配置</td></tr></tbody></table><h5 id="3-1-1-查看topic列表"><a href="#3-1-1-查看topic列表" class="headerlink" title="3.1.1 查看topic列表"></a>3.1.1 查看topic列表</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-topics.sh --bootstrap-server 192.168.64.132:9092 --list<br></code></pre></td></tr></table></figure><h5 id="3-1-2-创建topic"><a href="#3-1-2-创建topic" class="headerlink" title="3.1.2 创建topic"></a>3.1.2 创建topic</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-topics.sh --bootstrap-server 192.168.64.132:9092 --topic first --create --partitions 1 --replication-factor 3<br></code></pre></td></tr></table></figure><h5 id="3-1-3-查看topic详细信息"><a href="#3-1-3-查看topic详细信息" class="headerlink" title="3.1.3 查看topic详细信息"></a>3.1.3 查看topic详细信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-topics.sh --bootstrap-server 192.168.64.132:9092 --topic first --describe<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Topic: first    TopicId: Br6K7xvDTWGgi1kTGgmnSw PartitionCount: 1       ReplicationFactor: 3    Configs: segment.bytes=1073741824<br>        Topic: first    Partition: 0    Leader: 0       Replicas: 0,2,1 Isr: 0<br><br></code></pre></td></tr></table></figure><h5 id="3-1-4-修改topic"><a href="#3-1-4-修改topic" class="headerlink" title="3.1.4 修改topic"></a>3.1.4 修改topic</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-topics.sh --bootstrap-server 192.168.64.132:9092 --topic first --create --partitions 1 --replication-factor 3<br></code></pre></td></tr></table></figure><h4 id="3-2-Producter"><a href="#3-2-Producter" class="headerlink" title="3.2 Producter"></a>3.2 Producter</h4><p>生产者命令对应的脚本</p><p><strong>kafka-console-producter.sh</strong></p><h5 id="3-2-1-发送消息"><a href="#3-2-1-发送消息" class="headerlink" title="3.2.1 发送消息"></a>3.2.1 发送消息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-console-producer.sh --bootstrap-server 192.168.64.132:9092 --topic first<br></code></pre></td></tr></table></figure><h4 id="3-2-Consumer-消费者"><a href="#3-2-Consumer-消费者" class="headerlink" title="3.2 Consumer 消费者"></a>3.2 Consumer 消费者</h4><p>消费者对应脚本</p><p><strong>kafka-console-consumer.sh</strong></p><h5 id="3-2-1-接收消息"><a href="#3-2-1-接收消息" class="headerlink" title="3.2.1 接收消息"></a>3.2.1 接收消息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-console-consumer.sh --bootstrap-server server2:9092 --topic first<br></code></pre></td></tr></table></figure><p>现象是，新的消费组接收不到历史消息，这如何处理</p><p><strong>接收历史消息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-console-consumer.sh --bootstrap-server server2:9092 --topic first --from-beginning<br></code></pre></td></tr></table></figure><h3 id="4、生产者"><a href="#4、生产者" class="headerlink" title="4、生产者"></a>4、生产者</h3><h4 id="4-1-生产者的原理"><a href="#4-1-生产者的原理" class="headerlink" title="4.1 生产者的原理"></a>4.1 生产者的原理</h4><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/kafka%E7%94%9F%E4%BA%A7%E8%80%85.png"></p><p><strong>流程</strong></p><ul><li>外部数据进入到kafka生产者<ul><li>生产者main线程调用 send 方法发送到拦截器</li><li>拦截器可以对数据进行一些处理后</li><li>使用自带的序列化器</li><li>使用分区器</li></ul></li><li>RecordAccumulator 32m<ul><li>例如有三个分区<ul><li>图中一个分区会创建一个队列（内存）批次</li></ul></li><li>每个批次的大小是16k<ul><li>sender线程<ul><li>batch.size（16k） 只有数据积累到batch.size后，sender才会发送数据</li><li>linger.ms 如果数据迟迟未达到batch.size，senner等待linger.ms设置的时间，到了之后就会发送数据</li></ul></li><li>sender线程开始拉取数据<ul><li>开始发送数据后，sender会读取数据发送到broker中，发送的时候，如果前面的消息未到达，后面的消息是可以继续发送的，连续发送<ul><li>发送数据的应答级别<ul><li>0 生产者发过来的数据不需要等待数据落盘应答</li><li>生产者发来的数据，Leader收到数据后应答</li><li>-1 生产者发送过来的数据，leader和sr队列里面的所有节点收齐数据后应答，-1和all等价</li></ul></li></ul></li></ul></li><li>sender发送成功后继续<ul><li>失败后重试 retries</li></ul></li></ul></li><li>可以把消息清除了</li></ul></li></ul><h4 id="4-2-异步发送API"><a href="#4-2-异步发送API" class="headerlink" title="4.2 异步发送API"></a>4.2 异步发送API</h4><p>异步发送是表示将外部数据发送到队列中的过程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka-clients<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发送数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="hljs-string">&quot;server1:9092,server2:9092,server3:9092&quot;</span>);<br>        <span class="hljs-comment">// 指定对应的keu 和 value的序列化类型</span><br>        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());<br>        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,StringSerializer.class.getName());<br>        KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaProducer</span>&lt;&gt;(properties);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            kafkaProducer.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;&gt;(<span class="hljs-string">&quot;first&quot;</span>,<span class="hljs-string">&quot;hellow&quot;</span> + i));<br>            System.out.println(<span class="hljs-string">&quot;发送完毕&quot;</span>);<br>        &#125;<br>        kafkaProducer.close();<br></code></pre></td></tr></table></figure><h4 id="4-3-带回调的异步发送流程"><a href="#4-3-带回调的异步发送流程" class="headerlink" title="4.3 带回调的异步发送流程"></a>4.3 带回调的异步发送流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><h4 id="4-4-生产者分区"><a href="#4-4-生产者分区" class="headerlink" title="4.4 生产者分区"></a>4.4 生产者分区</h4><p>分区的好处</p><ul><li>便于合理的存储资源，每个Partition在一个broker上存储，可以把海量的数据按照分区一块一块数据存储在多太Broker上，合理的控制分区的任务，可以实现负载均衡的效果</li><li>提高并行度，生产者可以以分区为单位发送数据，消费者可以以分区为单向消费数据</li></ul><p><strong>分区策略</strong></p><p>默认的分区规则是<strong>DefaultPartition</strong></p><ul><li>如果指定分区了，放到指定的分区</li><li>如果没有指定分区按照key的哈希值对分区数量取模</li><li>如果没有key，采用粘性分区器，会随机选择一个分区，并尽可能一直使用该分区，直到该分区batch满了，如果满了之后在随机选一个分区，必须和上一次不同</li><li>生产环境一般建议用表名做key</li></ul><p><strong>自定义分区实现</strong></p><p>需求：</p><p><strong>实现Partitioner接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myPartition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Partitioner</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(String s, Object o, <span class="hljs-type">byte</span>[] bytes, Object o1, <span class="hljs-type">byte</span>[] bytes1, Cluster cluster)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(Map&lt;String, ?&gt; map)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>设置自定义分区器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">properties.put(ProducerConfig.PARTITIONER_CLASS_CONFIG,<span class="hljs-string">&quot;com.tangcheng.myPartition&quot;</span>);<br><br></code></pre></td></tr></table></figure><h4 id="4-5-生产者如何提高吞吐量"><a href="#4-5-生产者如何提高吞吐量" class="headerlink" title="4.5 生产者如何提高吞吐量"></a>4.5 生产者如何提高吞吐量</h4><ul><li>batch.size：批次大小，默认16k</li><li>linger.ms：等待时间，修改为5-100ms</li><li>compression.type: 压缩snappy</li><li>RecordAccumulator：缓冲区大小，修改为64m</li></ul><h4 id="4-5-数据可靠性"><a href="#4-5-数据可靠性" class="headerlink" title="4.5 数据可靠性"></a>4.5 数据可靠性</h4><p>在数据发送流程中sender线程发送数据，后会收到三个应答等级，分别是</p><ul><li>0：生产者发回来的数据，不需要等数据落盘应答</li><li>1：生产者发送过来的数据，Leader收到数据后应答<ul><li>收到后就应答，不需要同步完成</li></ul></li><li>-1：生产者发送过来的数据，Leader和isr队列里面的所有节点收齐数据后应答</li></ul><p><strong>ACK &#x3D; 0</strong></p><p>生产者发送过来的数据，不需要等数据落盘应答</p><p><strong>ACK &#x3D; 1</strong></p><p>生产者发送数据，Leader落盘完成了，但是foller没有同步</p><ul><li>风险<ul><li>leader挂了 数据丢失</li></ul></li></ul><p><strong>ACK &#x3D; 2</strong></p><p>生产者发送数据，Leader和ISR队列里面所有的节点收齐数据后应答</p><ul><li>风险<ul><li>follow挂了，无法返回应答整个系统停止<ul><li>Leader维护了一个动态的ISR，以为和Leader保持同步的Follewer+Leader的集合</li></ul></li></ul></li></ul><p>如果分区副本设置为1个或者ISR里应答的最小副本数量设置为1，和ack &#x3D; 1的效果一样，也有丢数风险</p><p>完全可靠条件：ACK级别设置为-1，分区副本大于等于2，ISR里应答最小副本大于2</p><p><strong>对比</strong></p><p>0：生产者发来数据就不管了，可靠性差，效率高</p><p>1：生产者发来的数据leader应答，可靠性中等，效率低</p><p>-1：生产者发送过来的数据Leader和ISR队列里面所有的Follwer应答，可靠性高，效率低</p><p><strong>数据重复分析</strong></p><p>在 ACK &#x3D; -1 的时候产生的问题</p><p>在follower 同步完成的时候leader挂了，应答后没有成功，当新的leader选举后，数据就会被重复消费</p><p><strong>如何配置 ACK</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">properties.put(ProducerConfig.ACKS_CONFIG,<span class="hljs-number">1</span>);<br><br></code></pre></td></tr></table></figure><h4 id="4-6-数据重复"><a href="#4-6-数据重复" class="headerlink" title="4.6 数据重复"></a>4.6 数据重复</h4><p>数据传递语义</p><p>至少一次</p><p>ACK级别设置为-1，分区副本大于等于2，ISR里应答的最小副本数量大于等于2</p><p>最多一次</p><p>ACK 级别设置为0</p><p>至少一次，保证了数据不会丢失</p><p>最多一次，保证数据不重复，不保证数据不丢失</p><p>精确一次</p><p>幂等性事物</p><p><strong>幂等性就是生产者无论向生产者发送多少次重复数据，Broker都只会持久化一条，保证了不重复</strong></p><p>精确一次 &#x3D; 幂等性 + ack设置为-1 分区副本&gt;&#x3D;2 isr 最小副本数量&gt;&#x3D;2</p><p>重复数据的判断标准</p><p>具有 PID Patition SeqNumber 相同主键的消息提交时，Broker只会持久化一条，其中PID是Kafka每次重启都会分配一个新的，Partition表示分区号，SeqNumber 是单调递增的，是序列化号</p><p>幂等性只能保证的是单分区，单会话内数据不重复</p><p><strong>配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">enable.idempotence<br></code></pre></td></tr></table></figure><p><strong>生产者事务</strong></p><p>开启事物，必须开启幂等性</p><p>每一个broker都有一个事物协调器</p><p>每个broker都有一个事物分区</p><p>生产者在使用事物功能前，必须先自定义一个唯一的事物ID，有了事物ID，即使客户端挂掉了，重启后也能继续处理未完成的事物</p><p><strong>API</strong></p><p>指定事物ID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">properties.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG,&quot;mytranscation&quot;);<br>        KafkaProducer&lt;String, String&gt; kafkaProducer = new KafkaProducer&lt;&gt;(properties);<br><br>        kafkaProducer.initTransactions();<br>        kafkaProducer.beginTransaction();<br>        try &#123;<br>            for (int i = 0; i &lt; 10; i++) &#123;<br>                kafkaProducer.send(new ProducerRecord&lt;&gt;(&quot;first&quot;, &quot;a&quot;,&quot;h&quot; + i), new Callback() &#123;<br>                    @Override<br>                    public void onCompletion(RecordMetadata recordMetadata, Exception e) &#123;<br>                        if (e == null)&#123;<br>                            System.out.println(&quot;正常返回&quot; + recordMetadata.topic() + &quot;分区&quot; + recordMetadata.partition());<br>                        &#125;<br>                    &#125;<br>                &#125;);<br>                System.out.println(&quot;发送完毕&quot;);<br>            &#125;<br>            kafkaProducer.commitTransaction();<br>        &#125;catch (Exception e)&#123;<br>            kafkaProducer.abortTransaction();<br>        &#125;<br>        kafkaProducer.close();<br></code></pre></td></tr></table></figure><h4 id="4-7-如何保证数据消费是有序的"><a href="#4-7-如何保证数据消费是有序的" class="headerlink" title="4.7 如何保证数据消费是有序的"></a>4.7 如何保证数据消费是有序的</h4><p>多分区无法保障数据有序</p><p>单分区内有序</p><p>如何要求多分区有序</p><p><strong>数据乱序</strong></p><p>在发送数据的过程中，生产者有一个缓存请求，在对方没有回应的时候会暂存到请求队列中，会导致数据乱序问题</p><p>Kafka在1.x以后的版本保证数据单分区有序，条件如下</p><p>未开启幂等性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">max.in.flight.request.per.connection 需要设置为1<br></code></pre></td></tr></table></figure><p>开启了幂等性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">max.in.flight.rquests.per.connection 需要设置小于等于5<br></code></pre></td></tr></table></figure><p>kafka缓存最近的五个请求后，在全部收到请求后会根据seqid对他进行重排序</p><h3 id="5、Broker"><a href="#5、Broker" class="headerlink" title="5、Broker"></a>5、Broker</h3><p>在Zookeeper中的服务端存储的kafka相关信息</p><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/broker.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/kafka/brokers/ids  记录了有哪些服务<br></code></pre></td></tr></table></figure><h4 id="5-1-Kafkabroker的总体工作流程"><a href="#5-1-Kafkabroker的总体工作流程" class="headerlink" title="5.1 Kafkabroker的总体工作流程"></a>5.1 Kafkabroker的总体工作流程</h4><ul><li>每台Kafka启动后都会向zookeeper中注册</li><li>每台节点都有controller<ul><li>谁先抢到controller leader节点后成为选举领导</li><li>选举规则：<ul><li>在isr中存活为前提，按照AR中排在前面的优先，例如ar[1,0,2],isr[1,0,2],那么leader就会按照102的顺序进行选举</li></ul></li><li>选举完成上传到zk</li><li>其他controller从zk同步相关信息</li></ul></li></ul><h4 id="5-2-节点的服务和退役"><a href="#5-2-节点的服务和退役" class="headerlink" title="5.2 节点的服务和退役"></a>5.2 节点的服务和退役</h4><p><strong>服役新节点</strong></p><p>服役的新节点没有自动同步新的节点的topic</p><p><strong>执行负载均衡操作</strong></p><ul><li><p>创建一个要负载均衡的主题</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">vim topics-to-move.json<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;topics&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;topic&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;first&quot;</span><span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>形成负载均衡计划</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-reassign-partitions.sh --bootstrap-server server1:9092 --topics-to-move-json-file topics-to-move.json --broker-list &quot;0,1,2,3&quot; --generate<br></code></pre></td></tr></table></figure></li><li><p>形成了负载均衡计划</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">Current partition replica assignment<br>&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[0,2,1],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;,&quot;any&quot;]&#125;]&#125;<br><br>Proposed partition reassignment configuration<br>&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[0,1,2],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;,&quot;any&quot;]&#125;]&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>创建副本存储计划</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim increase-replication-factor.json<br>&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[0,1,2],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;,&quot;any&quot;]&#125;]&#125;<br></code></pre></td></tr></table></figure></li><li><p>执行副本存储计划</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-reassign-partitions.sh --bootstrap-server server1:9092 --reassignment-json-file increase-replication-factor.json --execute<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Current partition replica assignment<br><br>&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[0,2,1],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;,&quot;any&quot;]&#125;]&#125;<br><br>Save this to use as the --reassignment-json-file option during rollback<br>Successfully started partition reassignment for first-0<br><br></code></pre></td></tr></table></figure></li><li><p>验证副本存储计划</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-reassign-partitions.sh --bootstrap-server server1:9092 --reassignment-json-file increase-replication-factor.json --verify<br></code></pre></td></tr></table></figure></li></ul><p><strong>退役旧节点</strong></p><p>创建一个排除旧的节点的方案就行</p><p>参超服役新节点</p><h4 id="5-3-副本"><a href="#5-3-副本" class="headerlink" title="5.3 副本"></a>5.3 副本</h4><ul><li>副本的作用是提高可靠性</li><li>默认的副本是1个，生产环境一般配置2个保证数据可靠性，太多副本会增加磁盘空间，增加网络上的传输</li><li>副本分为leader 和 flower副本，kafka生产者只会把数据发给leader，然后follower找leader进行数据同步</li><li>kafka分区中所有的副本统称为AR</li></ul><p>AR &#x3D; ISR + OSR</p><p>isr 表示和leader保持同步的floower集合，当30s leader和follower没有通信就会被提出isr</p><p>osr 表示的被踢出去的，超时的副本</p><h4 id="5-4-Leader-选举流程"><a href="#5-4-Leader-选举流程" class="headerlink" title="5.4 Leader 选举流程"></a>5.4 Leader 选举流程</h4><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/Leader%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B.png"></p><p>首先broker启动后会在zookeeper中注册</p><p>每个broker中有一个controller节点负责选取，谁先来的谁就是leader controller</p><p>选举出来的leadercontroller 负责监听broker节点的变化</p><p>controller监听到节点的变化后进行选举</p><p>选举就则是：在ISR中存活的为前提，按照AR中排在最前面的优先</p><h4 id="5-5-Leader-和-Follower的故障处理细节"><a href="#5-5-Leader-和-Follower的故障处理细节" class="headerlink" title="5,5 Leader 和 Follower的故障处理细节"></a>5,5 Leader 和 Follower的故障处理细节</h4><p><strong>LEO（log end offset）:</strong></p><p>每个副本最后一个offset，leo其实就是最新的offset + 1</p><p><strong>HW （high watermark）：</strong></p><p>所有副本中最小的LEO</p><p><strong>Follower 故障</strong></p><p>1、Follower发生故障后会被临时踢出 ISR</p><p>2、这个期间Leader和Follower继续接收数据</p><p>3、等待Follower恢复后，Follower会读取本地磁盘记录的上次的HW，并将log文件高于hw的部分截取掉，从hw开始向leader进行同步</p><p>4、等到Follower追上leader之后，就可以重新加入isr了</p><p><strong>Leader故障</strong></p><p>1、Leader发生故障后，会从ISR中选出一个新的Leader</p><p>2、为了保证多个副本之间的数据一致性，其余的Follower会先将各自的log文件高于HW的部分截取掉，然后从新的Leader中同步数据</p><p>3、只能保证数据一致性，不能保证完整性</p><h4 id="5-6-分区副本分配"><a href="#5-6-分区副本分配" class="headerlink" title="5.6 分区副本分配"></a>5.6 分区副本分配</h4><p>如何kafka只有四个节点，那么设置kafka的分区大于服务器的台数，kafka是如何分配存储副本的呢</p><p>尽可能的打撒副本和主节点</p><p><strong>手动调整分区副本</strong></p><p>在生产环境中，每台服务器的配置和性能不一致，但是kafka只会根据自己的代码规则创建对应的分区副本，就会导致个别服务器压力过大</p><ul><li><p>创建副本存储计划</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim increase-replication-factor.json<br>&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[0,1,2],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;,&quot;any&quot;]&#125;]&#125;<br></code></pre></td></tr></table></figure></li><li><p>执行副本存储计划</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-reassign-partitions.sh --bootstrap-server server1:9092 --reassignment-json-file increase-replication-factor.json --execute<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Current partition replica assignment<br><br>&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[0,2,1],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;,&quot;any&quot;]&#125;]&#125;<br><br>Save this to use as the --reassignment-json-file option during rollback<br>Successfully started partition reassignment for first-0<br><br></code></pre></td></tr></table></figure></li><li><p>验证副本存储计划</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-reassign-partitions.sh --bootstrap-server server1:9092 --reassignment-json-file increase-replication-factor.json --verify<br></code></pre></td></tr></table></figure></li></ul><p><strong>Leader Partition 负载平衡</strong></p><p>正常情况下，Kafka本身会自动把Leader Partition均匀分散在各个机器上，来保证每台机器的读写和吞吐量是均匀的，但是如果某些broker宕机，会导致Leader partition过于集中在其他少部分broker上，这会导致少数几台的broker的读写请求压力过高，其他宕机的broker重启之后都是followe partition，读写请求很低，造成集群负载不均衡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">auto.leader.rebalance.enable true <br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 默认是true，会自动Leader Partition平衡</span></span><br>leader。imbalance.per.broker.percentage <br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#默认是10%，每个broker允许的不平衡leader的比率，如果每个broker超过了这个值就会触发leader这个值</span></span><br></code></pre></td></tr></table></figure><p>如何计算不平衡的比例</p><p>leader 0 副本 3 0 2 1</p><p>针对这个节点，目前3是优先节点，但是3却不是leader，所以不平衡数+1，AR副本总数是4 所以比例是1&#x2F;4</p><p><strong>增加副本因子</strong></p><p>在生产环境中，由于某个主题的重要等级需要提升，考虑增加副本，副本数的增加需要先制定计划，然后根据计划执行</p><h4 id="5-7-kafka的文件存储"><a href="#5-7-kafka的文件存储" class="headerlink" title="5.7 kafka的文件存储"></a>5.7 kafka的文件存储</h4><p>Topic是一个逻辑上的概念，patition是物理上的概念，每个partition对应一个log文件，该log文件中存储的就是Produceter生产者的数据，Producer生产的数据会被不断地追加到该log文件末端，为了防止log文件过大导致数据定位效率低下，Kafka采取了分片和索引的机制，将每个partition分为多个segment，每个segment包括，index文件，log文件和timeindex文件，这些文件位于一个文件夹下，该文件夹的命名规则为topic名称+分区序号</p><p>一个Topic会被分成多个分片</p><p>一个分片对应了一个log文件</p><p>log文件被拆分成为了segment</p><p>一个segment包含了</p><ul><li>index 偏移量索引文件</li><li>timeindex 时间戳索引文件</li><li>其他文件</li></ul><p>文件的命名规则 topic+序号</p><p>如何查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kafka-run-class.sh kafka.tools.DumpLogSegments --files ../logs/first0/00000000000000000000.index<br></code></pre></td></tr></table></figure><h4 id="5-8-Log-文件和Index文件详解"><a href="#5-8-Log-文件和Index文件详解" class="headerlink" title="5.8 Log 文件和Index文件详解"></a>5.8 Log 文件和Index文件详解</h4><p>1、Index为稀疏索引，大约每往log文件写入4kb的数据，会王index文件写入一条索引，参数log.index.interval.byte默认为4kb</p><p>2、Index文件中保存的offset为相对的offset，这样能确保offset的值所占空间不会过大，因此能够将offset的值控制在固定大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./../../bin/kafka-run-class.sh kafka.tools.DumpLogSegments --files 00000000000000000000.index<br>Dumping 00000000000000000000.index<br></code></pre></td></tr></table></figure><p>如何在log文件中定位到offset为600的记录呢</p><p>根据目标的offset定位到Segment文件</p><p>找到小于其目标offset的最大offset对应的索引项</p><p>定位到log文件</p><p>向下遍历找到目标Record</p><h4 id="5-9-文件删除策略"><a href="#5-9-文件删除策略" class="headerlink" title="5.9 文件删除策略"></a>5.9 文件删除策略</h4><p>默认七天删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">log.retention.hours ## 配置时间<br>log.retention.check.interval.ms ## 负责检查周期<br></code></pre></td></tr></table></figure><p><strong>清除策略</strong></p><p>delete 和 compant</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">log.cleanup = delete ## 所有数据启用删除策略<br></code></pre></td></tr></table></figure><p>以所有的记录中最大的时间戳作为该文件的时间戳</p><p><strong>如果一个segment中，一部分数据过期，一部分数据没过期，怎么处理</strong></p><p>基于大小删除最早的segment</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">log.retention.bytes ## 默认 -1<br></code></pre></td></tr></table></figure><p><strong>压缩策略</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">log.cleanup = compact ## 日志删除<br></code></pre></td></tr></table></figure><p>压缩后的offset可能不是连续的，</p><h4 id="5-10-Broker高效读写数据"><a href="#5-10-Broker高效读写数据" class="headerlink" title="5.10 Broker高效读写数据"></a>5.10 Broker高效读写数据</h4><ul><li>kafka本身就是分布式集群，可以采用分区技术，并行度更高</li><li>读数据采用稀疏索引，快速定位要消费的数据</li><li>顺序写磁盘</li><li>页缓存+零拷贝技术<ul><li>零拷贝<ul><li>kafka的数据加工处理操作交给了kafka生产者和消费者处理，Broker不关心存储的数据，所以不用走应用层，传输效率更高</li></ul></li><li>Pagecache页缓存<ul><li>kafka重度依赖底层操作系统提供的pageCache功能，当上层有写操作时，操作系统只是将数据写入Pagecache，当读操作发生时，先从pageCache中查找，如果找不到，再去磁盘中读取</li></ul></li></ul></li></ul><h3 id="6、消费者"><a href="#6、消费者" class="headerlink" title="6、消费者"></a>6、消费者</h3><h4 id="6-1-消费总体流程"><a href="#6-1-消费总体流程" class="headerlink" title="6.1 消费总体流程"></a>6.1 消费总体流程</h4><p>消费方式 pull 模式 push模式 kafka采用的拉方式</p><p>由于每个消费者处理能力不同，所以根据自身的情况去拉取数据</p><ul><li>缺点<ul><li>如果kafka没有数据，消费者会陷入循环，一直返回空数据</li></ul></li></ul><p>一个消费者可以消费多个分区的数据</p><p>每个分区的数据只能消费者组中的一个消费者消费</p><p>每个消费者的offset由消费者提交到系统主题保存</p><h4 id="6-2-消费者组"><a href="#6-2-消费者组" class="headerlink" title="6.2 消费者组"></a>6.2 消费者组</h4><p>消费者组是由多个消费者组成，形成一个消费者组的条件的groupid相同</p><ul><li>消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费</li><li>消费者组之间互不影响，所有的消费者都属于某个消费者组，即消费者组逻辑上是一个订阅者</li></ul><h4 id="6-3-消费者组的初始化流程"><a href="#6-3-消费者组的初始化流程" class="headerlink" title="6.3 消费者组的初始化流程"></a>6.3 消费者组的初始化流程</h4><p><strong>coordinator</strong></p><p>辅助实现消费者组的初始化和分区的数量</p><p>coordinator 节点选择 &#x3D; groupID的hashcode值% 50(_consumer_offsets的分区数量)</p><ul><li>所有的消费者都会向coordinator发送JoinGroup请求</li><li>选出一个consumer作为leader</li><li>把要小费的topic情况发送给leader消费者</li><li>leader会负责制定消费方案</li><li>把消费方案发送给coordinator</li><li>coordinator根据消费方案把数据下发到各个消费方</li><li>每个消费者都会和coordinator保持心跳，一旦超时，消费者会被移除，触发再平衡，或者消费者处理消息的时间过长，也会触发再平衡</li></ul><h4 id="6-4-消费者组的详细消费流程"><a href="#6-4-消费者组的详细消费流程" class="headerlink" title="6.4 消费者组的详细消费流程"></a>6.4 消费者组的详细消费流程</h4><p><img src="https://wodebokea.oss-cn-beijing.aliyuncs.com/img/%E6%B6%88%E8%B4%B9%E6%B5%81%E7%A8%8B.png"></p><h4 id="6-4-消费者代码"><a href="#6-4-消费者代码" class="headerlink" title="6.4 消费者代码"></a>6.4 消费者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="hljs-string">&quot;server1:9092,server2:9092,server3:9092&quot;</span>);<br>        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());<br>        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,StringDeserializer.class.getName());<br>        properties.put(ConsumerConfig.GROUP_ID_CONFIG,<span class="hljs-string">&quot;user&quot;</span>);<br>        KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaConsumer</span>&lt;&gt;(properties);<br>        ArrayList&lt;String&gt; topicList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        topicList.add(<span class="hljs-string">&quot;first&quot;</span>);<br>        kafkaConsumer.subscribe(topicList);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            ConsumerRecords&lt;String, String&gt; poll = kafkaConsumer.poll(Duration.ofSeconds(<span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : poll) &#123;<br>                System.out.println(record.toString());<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="6-5-指定分区消费"><a href="#6-5-指定分区消费" class="headerlink" title="6.5 指定分区消费"></a>6.5 指定分区消费</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jaba">ArrayList&lt;TopicPartition&gt; topicList = new ArrayList&lt;&gt;();<br>        topicList.add(new TopicPartition(&quot;first&quot;,0));<br>        kafkaConsumer.assign(topicList);<br></code></pre></td></tr></table></figure><h4 id="6-6-分区的分配及再平衡"><a href="#6-6-分区的分配及再平衡" class="headerlink" title="6.6 分区的分配及再平衡"></a>6.6 分区的分配及再平衡</h4><p>一个消费者组中有多个消费者，一个topic有多个分片，到底由哪个消费者来消费分片的数据</p><p>kafka有四种策略</p><ul><li>range</li><li>roundrange</li><li>sticky</li><li>coooperativeSticky</li></ul><p><strong>分区分配策略 - Range</strong></p><p>range是针对每个topic而言的</p><p>首先对于topic中的分区按照序号进行排序，并对消费者按照字母顺序进行排序</p><p>例如有七个分区，三个消费者，那么就是0，1，2，3，4，5，6，</p><p>消费者C0，C1，C2</p><p>如何能除不开，就让第一个多消费一些</p><blockquote><p>如果只针对1个topic而言，C0消费者多消费一个分区的影响不是很大，但是如果有n多个topic，那么针对每个topic，消费者C0都将多消费1个分区，topic越多，c0消费的分区会被其他消费者明显多消费N个分区</p></blockquote><p>容易产生数据倾斜</p><p><strong>分区分配策略 -RoundRobin</strong></p><p>RoundRobin针对集群中所有的topic而言</p><p>RoundRobin 轮询分区策略，是把所有的分区和所有的消费者都列出来，然后按照hashcode进行排序，通过轮询算法来分配分区给各个消费者</p><p><strong>分区分配策略- 粘性分区再平衡</strong>、</p><p>粘性分区尽量均匀且随机，与range相比随机性比较强</p><h4 id="6-6-offset的默认维护"><a href="#6-6-offset的默认维护" class="headerlink" title="6.6 offset的默认维护"></a>6.6 offset的默认维护</h4><p>offset是消费位置</p><p>offset维护在系统主题中，_consumer_offsets中</p><p>使用key v 进行存储的，key是groupid + topic + 分区号</p><p><strong>默认不允许查看系统主题数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim config/consumer.properties 中添加配置<br>exclude.internal.topics=false<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 默认是true</span></span><br></code></pre></td></tr></table></figure><p>查看消费情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kafka-console-consumer.sh --topic__consumer_offsets --bootstrap-server server1:9092 --consumer.config con<br></code></pre></td></tr></table></figure><h4 id="6-7-自动提交offset"><a href="#6-7-自动提交offset" class="headerlink" title="6.7 自动提交offset"></a>6.7 自动提交offset</h4><p>为了使我们能够专注于业务逻辑，Kafka提供了自动提交offset的功能，自动提交offset的相关参数</p><ul><li>enable.auto.commit 是否开启自动提交默认开启</li><li>auto.commit.intervaLms 自动提交的时间间隔，默认5s</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,<span class="hljs-literal">true</span>);<br>properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h4 id="6-8-手动提交offset"><a href="#6-8-手动提交offset" class="headerlink" title="6.8 手动提交offset"></a>6.8 手动提交offset</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>生产者手动提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">kafkaConsumer.commitSync(); <span class="hljs-comment">// 同步</span><br>kafkaConsumer.commitAsync();<span class="hljs-comment">// 异步</span><br></code></pre></td></tr></table></figure><h4 id="6-9-指定offset消费"><a href="#6-9-指定offset消费" class="headerlink" title="6.9 指定offset消费"></a>6.9 指定offset消费</h4><ul><li><p>earliest 自动将偏移量重置为最早的偏移量</p></li><li><p>latest 自动将偏移量重置为最新的偏移量</p></li><li><p>none 如果未找到消费者组的先前偏移量，则向消费者抛出异常</p></li><li><p>从任意位置开始消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="hljs-string">&quot;server1:9092,server2:9092,server3:9092&quot;</span>);<br>        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());<br>        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,StringDeserializer.class.getName());<br>        properties.put(ConsumerConfig.GROUP_ID_CONFIG,<span class="hljs-string">&quot;user&quot;</span>);<br>        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,1000);</span><br>        KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaConsumer</span>&lt;&gt;(properties);<br>        ArrayList&lt;String&gt; topicList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        topicList.add(<span class="hljs-string">&quot;userinfo&quot;</span>);<br>        kafkaConsumer.subscribe(topicList);<br>        <span class="hljs-comment">// 指定位置进行消费</span><br>        Set&lt;TopicPartition&gt; assignment = kafkaConsumer.assignment();<br>        <span class="hljs-keyword">while</span> (assignment.size() == <span class="hljs-number">0</span>)&#123;<br>            kafkaConsumer.poll(Duration.ofSeconds(<span class="hljs-number">1</span>));<br>            assignment = kafkaConsumer.assignment();<br>        &#125;<br>        <span class="hljs-comment">// 指定消费的offset</span><br>        <span class="hljs-keyword">for</span> (TopicPartition topicPartition : assignment) &#123;<br>            kafkaConsumer.seek(topicPartition,<span class="hljs-number">1000</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            ConsumerRecords&lt;String, String&gt; poll = kafkaConsumer.poll(Duration.ofSeconds(<span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : poll) &#123;<br>                TimeUnit.NANOSECONDS.sleep(<span class="hljs-number">500</span>);<br>                System.out.println(record.toString());<br>            &#125;<br>            kafkaConsumer.commitSync();<br>            kafkaConsumer.commitAsync();<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>从指定时间开始消费，一分钟前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定位置进行消费</span><br>        Set&lt;TopicPartition&gt; assignment = kafkaConsumer.assignment();<br>        <span class="hljs-keyword">while</span> (assignment.size() == <span class="hljs-number">0</span>)&#123;<br>            kafkaConsumer.poll(Duration.ofSeconds(<span class="hljs-number">1</span>));<br>            assignment = kafkaConsumer.assignment();<br>        &#125;<br>        HashMap&lt;TopicPartition, Long&gt; topicLongHashmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (TopicPartition topicPartition : assignment) &#123;<br>            topicLongHashmap.put(topicPartition,System.currentTimeMillis() -  <span class="hljs-number">10</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>);<br>        &#125;<br>        <span class="hljs-comment">// 获得消费的offset列表</span><br>        Map&lt;TopicPartition, OffsetAndTimestamp&gt; topicPartitionOffsetAndTimestampMap = kafkaConsumer.offsetsForTimes(topicLongHashmap);<br>        <span class="hljs-comment">// 指定消费的offset</span><br>        <span class="hljs-keyword">for</span> (TopicPartition topicPartition : assignment) &#123;<br>            kafkaConsumer.seek(topicPartition,topicPartitionOffsetAndTimestampMap.get(topicPartition).offset());<br>        &#125;<br></code></pre></td></tr></table></figure><p>核心的逻辑是，先通过时间找到offset</p></li></ul><h4 id="6-10-漏消费和重复消费"><a href="#6-10-漏消费和重复消费" class="headerlink" title="6.10 漏消费和重复消费"></a>6.10 漏消费和重复消费</h4><p><strong>重复消费</strong></p><p>重复消费是自动offset提交引起的</p><p>还没有等到一个提交offset周期 consumer就执行了，但是之后他挂了，所以下次从头消费</p><p><strong>漏消费</strong></p><p>设置offset为手动提交，当offset被提交时，数据还在内存中未落盘，此时刚好消费者线程被kill掉，那么offset他已经提交，但是数据未处理</p><h4 id="6-11-消费者事物"><a href="#6-11-消费者事物" class="headerlink" title="6.11 消费者事物"></a>6.11 消费者事物</h4><p>如果完成精确的一次性消费，需要kafka消费端将消费过程和提交offset过程做原子绑定</p><h4 id="6-12-数据积压"><a href="#6-12-数据积压" class="headerlink" title="6.12 数据积压"></a>6.12 数据积压</h4><ul><li><p>如果消费能力不足，可以考虑增加Topic的分区数，同时提升消费组的消费者数量</p></li><li><p>提高每个批次拉去的数据量，使处理的数据小于生产的数据，也会造成数据积压</p><ul><li>修改每次拉取数据的条数</li><li>对应修改批次的大小</li></ul></li></ul><h3 id="7、Kafka-和-Springboot-集成"><a href="#7、Kafka-和-Springboot-集成" class="headerlink" title="7、Kafka 和 Springboot 集成"></a>7、Kafka 和 Springboot 集成</h3><h4 id="7-1-生产者"><a href="#7-1-生产者" class="headerlink" title="7.1 生产者"></a>7.1 生产者</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.kafka.bootstrap-servers</span>=<span class="hljs-string">server1:9092,server2:9092.server3:9092</span><br><span class="hljs-attr">spring.kafka.producer.key-serializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span><br><span class="hljs-attr">spring.kafka.producer.value-serializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>KafkaTemplate&lt;String,String&gt; kafka;<br><span class="hljs-meta">@RequestMapping(&quot;/add&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">data</span><span class="hljs-params">(String msg)</span>&#123;<br>    kafka.send(<span class="hljs-string">&quot;first&quot;</span>,msg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-2-消费"><a href="#7-2-消费" class="headerlink" title="7.2 消费"></a>7.2 消费</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br>    <span class="hljs-meta">@KafkaListener(topics = &quot;first&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumerTopic</span><span class="hljs-params">(String msg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;收到消息&quot;</span> + msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8、Kafka的调优"><a href="#8、Kafka的调优" class="headerlink" title="8、Kafka的调优"></a>8、Kafka的调优</h4><h5 id="8-1-硬件配置"><a href="#8-1-硬件配置" class="headerlink" title="8.1 硬件配置"></a>8.1 硬件配置</h5><p>每天数据量大概1亿条</p><p>每秒钟1150条</p><p>每条日志 0.5-2k</p><p>平均值每秒80m</p><p>服务器台数 &#x3D; 2 x 生产者峰值生产速率 * 副本数&#x2F;100 + 1</p><p><strong>内存选择</strong></p><p>百分之25的数据再页缓存当中就很合适</p><h4 id="8-2-生产者调优"><a href="#8-2-生产者调优" class="headerlink" title="8.2 生产者调优"></a>8.2 生产者调优</h4><table><thead><tr><th>参数名称</th><th>描述</th></tr></thead><tbody><tr><td>buffer.memory</td><td>RecordAccumulator 缓冲区总大小</td></tr><tr><td>bacth.size</td><td>缓冲区一批数据的最大时，默认16k可以适当的增减这个值，但是如果值增加的过大，会导致数据传输时延增加</td></tr><tr><td>linger.ms</td><td>如果数据迟迟味道到batch.size，等待后就会发送数据，默认是0ms，生产环境建议设置在5ms-100ms之间</td></tr><tr><td>compression。type</td><td>生产者发送数据的压缩方式，默认是none，支持压缩类型有none，gzip，snappy，lz4和zstd</td></tr></tbody></table><h4 id="8-3-Broker调优"><a href="#8-3-Broker调优" class="headerlink" title="8.3 Broker调优"></a>8.3 Broker调优</h4><ul><li>增加分区</li><li>增加副本因子</li><li>手动调整分区副本存储</li><li>负载平衡</li></ul><h4 id="8-4-消费者调优"><a href="#8-4-消费者调优" class="headerlink" title="8.4 消费者调优"></a>8.4 消费者调优</h4><ul><li>扩大拉取数据的条数</li><li>扩大拉取数据的内存</li></ul><h4 id="8-5-总体调优"><a href="#8-5-总体调优" class="headerlink" title="8.5 总体调优"></a>8.5 总体调优</h4><p><strong>如何提升吞吐量</strong></p><ul><li>提升生产者吞吐量<ul><li>buffer.memory 发送消息的缓冲区大小，默认32 可以增加到64</li><li>batch.size 默认16k，如果batch设置太小会导致频繁网络请求</li><li>linger.ms 是个未达到batch后多久发送数据</li><li>compression.type 数据压缩</li></ul></li><li>增加分区</li><li>消费者提高吞吐量<ul><li>调整fetch.max.byte 大小</li><li>调整max.poll.recorrs 默认500条</li></ul></li></ul><p><strong>数据精准</strong></p><ul><li>生产者<ul><li>ack 设置为 -1</li><li>幂等性 开启幂等性 + 事物</li></ul></li><li>broker<ul><li>分区副本大于2</li><li>isr最小副本大于2</li></ul></li><li>消费者<ul><li>事物+手动提交offset</li><li>消费者的输出目的地必须支持事物</li></ul></li></ul><p><strong>合理设置分区数</strong></p><p><strong>服务器挂了怎么办</strong></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器常用软件的安装</title>
    <link href="/2021/11/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/11/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="Linux新的服务器基础环境搭建快捷文档"><a href="#Linux新的服务器基础环境搭建快捷文档" class="headerlink" title="Linux新的服务器基础环境搭建快捷文档"></a>Linux新的服务器基础环境搭建快捷文档</h3><h4 id="1、安装SSH"><a href="#1、安装SSH" class="headerlink" title="1、安装SSH"></a>1、安装SSH</h4><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install openssh-server<br></code></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/ssh/sshd_config<br>配置Port<br>配置PermitRootLogin<br></code></pre></td></tr></table></figure><ul><li>启动服务</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start sshd.service<br></code></pre></td></tr></table></figure><ul><li>查看启动状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl status sshd.service<br></code></pre></td></tr></table></figure><ul><li>设置开机启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable sshd.service<br></code></pre></td></tr></table></figure><ul><li>检查22端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -an | grep 22<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有开放则使用以下命令</span><br>firewall-cmd --permanent --zone=public --add-port=22/tcp<br>firewall-cmd --permanent --zone=public --add-port=22/udp<br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><h4 id="2、安装JDK"><a href="#2、安装JDK" class="headerlink" title="2、安装JDK"></a>2、安装JDK</h4><ul><li>国内源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nmcli connection reload<br></code></pre></td></tr></table></figure><ul><li>新建&#x2F;usr&#x2F;java</li><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zvxf jdk-8u202-linux-x64.tar.gz<br></code></pre></td></tr></table></figure><ul><li>配置环境变量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/profile<br></code></pre></td></tr></table></figure><ul><li>加入如下内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">JAVA_HOME=/usr/java/jdk1.8.0_60<br><br>PATH=$JAVA_HOME/bin:$PATH<br><br>CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar<br><br>export PATH JAVA_HOME CLASSPATH<br></code></pre></td></tr></table></figure><ul><li>重载source文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure><h4 id="3、安装DOCKER"><a href="#3、安装DOCKER" class="headerlink" title="3、安装DOCKER"></a>3、安装DOCKER</h4><p>Docker帮助文档 <a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a></p><p><strong>第一步卸载旧版docker</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$ sudo yum remove docker <span class="hljs-string">\</span><br>                  docker-client <span class="hljs-string">\</span><br>                  docker-client-latest <span class="hljs-string">\</span><br>                  docker-common <span class="hljs-string">\</span><br>                  docker-latest <span class="hljs-string">\</span><br>                  docker-latest-logrotate <span class="hljs-string">\</span><br>                  docker-logrotate <span class="hljs-string">\</span><br>                  docker-engine<br></code></pre></td></tr></table></figure><p><strong>需要的安装包</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> -y yum-utils<br></code></pre></td></tr></table></figure><p><strong>设置镜像仓库</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo yum-config-manager \<br>    --add-repo \<br>    http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/centos/</span>docker-ce.repo    <br></code></pre></td></tr></table></figure><p><strong>安装Docker相关的内容</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo yum install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io<br></code></pre></td></tr></table></figure><p>ce版本为社区版本 ee为企业授权版</p><p><strong>更新环境</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yum makecache fast</span> <br></code></pre></td></tr></table></figure><p><strong>启动docker</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo systemctl <span class="hljs-literal">start</span> docker<br></code></pre></td></tr></table></figure><p>通过docker-version查看docker安装是否成功</p><p><strong>测试helloworld</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo docker <span class="hljs-built_in">run</span> hello-world<br></code></pre></td></tr></table></figure><h4 id="附录-问题处理"><a href="#附录-问题处理" class="headerlink" title="附录 问题处理"></a>附录 问题处理</h4><h5 id="1、为-repo-‘AppStream‘-下载元数据失败"><a href="#1、为-repo-‘AppStream‘-下载元数据失败" class="headerlink" title="1、为 repo ‘AppStream‘ 下载元数据失败"></a>1、为 repo ‘AppStream‘ 下载元数据失败</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/yum.repos.d/CentOS-Base.repo<br></code></pre></td></tr></table></figure><p>注释掉换成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">baseurl=https://mirrors.aliyun.com/centos/$releasever-stream/BaseOS/$basearch/os/<br> http://mirrors.aliyuncs.com/centos/$releasever-stream/BaseOS/$basearch/os/<br> http://mirrors.cloud.aliyuncs.com/centos/$releasever-stream/BaseOS/$basearch/os/<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim  /etc/yum.repos.d/CentOS-AppStream.repo<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">baseurl=https://mirrors.aliyun.com/centos/$releasever-stream/AppStream/$basearch/os/<br>        http://mirrors.aliyuncs.com/centos/$releasever-stream/AppStream/$basearch/os/<br>        http://mirrors.cloud.aliyuncs.com/centos/$releasever-stream/AppStream/$basearch/os/<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim  /etc/yum.repos.d/CentOS-Extras.repo<br>baseurl=https://mirrors.aliyun.com/centos/$releasever-stream/extras/$basearch/os/<br>        http://mirrors.aliyuncs.com/centos/$releasever-stream/extras/$basearch/os/<br>        http://mirrors.cloud.aliyuncs.com/centos/$releasever-stream/extras/$basearch/os/<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum clean all<br>yum makecache<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>安装部署文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>JDK</tag>
      
      <tag>安装文档</tag>
      
      <tag>DOCKER</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百度云Api与SpringBoot实现的人脸识别登录功能</title>
    <link href="/2021/09/21/%E7%99%BE%E5%BA%A6%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%ABAPI/"/>
    <url>/2021/09/21/%E7%99%BE%E5%BA%A6%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%ABAPI/</url>
    
    <content type="html"><![CDATA[<h4 id="百度云Api与SpringBoot实现的人脸识别登录功能"><a href="#百度云Api与SpringBoot实现的人脸识别登录功能" class="headerlink" title="百度云Api与SpringBoot实现的人脸识别登录功能"></a>百度云Api与SpringBoot实现的人脸识别登录功能</h4><p><strong>任何问题都可通过bilibli私信我，虽然我很菜，但是很乐意解答</strong><br><a href="https://space.bilibili.com/97483909">bilibli</a><br>项目中非常重要的gettoken的方法中AK与SK需要自己从百度云人脸识别库获取（代码中删去了这部分）</p><h4 id="1、项目简介"><a href="#1、项目简介" class="headerlink" title="1、项目简介"></a>1、项目简介</h4><p>项目中使用了SpringBoot+Thymleaf+百度云的API接口实现的人脸识别功能，其中融合了人脸库的管理功能，实现对人脸的增删改查。<br>对于原生的百度云API文档可以点击下载<br><a href="https://githubpicture.oss-cn-beijing.aliyuncs.com/FACE.pdf">点击下载百度云API官方文档–32M</a><br>项目演示和流程介绍可参考视频<br><a href="https://www.bilibili.com/video/av93519949#reply2469727748">视频演示</a><br><img src="https://githubpicture.oss-cn-beijing.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20200304214346.png?ynotemdtimestamp=1652771803320" alt="image"><br><img src="https://githubpicture.oss-cn-beijing.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20200304214430.png?ynotemdtimestamp=1652771803320" alt="image"><br><img src="https://githubpicture.oss-cn-beijing.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20200304215800.png?ynotemdtimestamp=1652771803320" alt="image"><br><img src="https://githubpicture.oss-cn-beijing.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20200304214510.png?ynotemdtimestamp=1652771803320" alt="image"></p><h4 id="2、接口方法"><a href="#2、接口方法" class="headerlink" title="2、接口方法"></a>2、接口方法</h4><p>Face包下的的BaiduAiFace类是整个核心功能的接口<br><strong>FaceRegistration</strong> 方法为人脸注册<br><strong>FaceUpdate</strong> 方法为人脸更新<br><strong>FindPersonFaceList</strong> 方法为查询人脸信息<br><strong>FindGroupList</strong> 为查询本组的面部信息<br><strong>DelPersonFace</strong> 为删除人脸<br><strong>FaceSearch</strong> 为查找人脸</p><h4 id="3、接口参数"><a href="#3、接口参数" class="headerlink" title="3、接口参数"></a>3、接口参数</h4><p>对于每个参数的具体含义与提要提供的参数参考百度云官方文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Setingmodel</span> &#123;<br>    <span class="hljs-keyword">private</span> String imgpath;<br>    <span class="hljs-keyword">private</span> String GroupID;<br>    <span class="hljs-keyword">private</span> String UserID;<br>    <span class="hljs-keyword">private</span> String Quality_Control;<br>    <span class="hljs-keyword">private</span> String Image_Type;<br>    <span class="hljs-keyword">private</span> String Liveness_Control;<br>    <span class="hljs-keyword">private</span> String Userinf;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserinf</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Userinf;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserinf</span><span class="hljs-params">(String userinf)</span> &#123;<br>        Userinf = userinf;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Setingmodel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 图片类型</span><br><span class="hljs-comment">         * BASE64:图片的base64值，base64编码后的图片数据，编码后的图片大小不超过2M；</span><br><span class="hljs-comment">         * URL:图片的 URL地址( 可能由于网络等原因导致下载图片时间过长)；</span><br><span class="hljs-comment">         * FACE_TOKEN：人脸图片的唯一标识，调用人脸检测接口时</span><br><span class="hljs-comment">         * 会为每个人脸图片赋予一个唯一的FACE_TOKEN</span><br><span class="hljs-comment">         * 同一张图片多次检测得到的FACE_TOKEN是同一个。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-built_in">this</span>.Image_Type = <span class="hljs-string">&quot;BASE64&quot;</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 图片质量控制</span><br><span class="hljs-comment">         * NONE: 不进行控制</span><br><span class="hljs-comment">         * LOW:较低的质量要求</span><br><span class="hljs-comment">         * NORMAL: 一般的质量要求</span><br><span class="hljs-comment">         * HIGH: 较高的质量要求</span><br><span class="hljs-comment">         * 默认 NONE</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-built_in">this</span>.Quality_Control = <span class="hljs-string">&quot;NONE&quot;</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 活体检测控制</span><br><span class="hljs-comment">         * NONE: 不进行控制</span><br><span class="hljs-comment">         * LOW:较低的活体要求(高通过率 低攻击拒绝率)</span><br><span class="hljs-comment">         * NORMAL: 一般的活体要求(平衡的攻击拒绝率, 通过率)</span><br><span class="hljs-comment">         * HIGH: 较高的活体要求(高攻击拒绝率 低通过率)</span><br><span class="hljs-comment">         * 默认NONE</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-built_in">this</span>.Liveness_Control = <span class="hljs-string">&quot;NONE&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getImgpath</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> imgpath;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setImgpath</span><span class="hljs-params">(String imgpath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.imgpath = imgpath;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getGroupID</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> GroupID;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setGroupID</span><span class="hljs-params">(String groupID)</span> &#123;<br>        GroupID = groupID;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserID</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> UserID;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserID</span><span class="hljs-params">(String userID)</span> &#123;<br>        UserID = userID;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getQuality_Control</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Quality_Control;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setQuality_Control</span><span class="hljs-params">(String quality_Control)</span> &#123;<br>        Quality_Control = quality_Control;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getImage_Type</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Image_Type;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setImage_Type</span><span class="hljs-params">(String image_Type)</span> &#123;<br>        Image_Type = image_Type;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLiveness_Control</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Liveness_Control;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLiveness_Control</span><span class="hljs-params">(String liveness_Control)</span> &#123;<br>        Liveness_Control = liveness_Control;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>人脸识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
